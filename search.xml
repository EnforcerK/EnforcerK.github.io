<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>数据库粗略回顾（二）</title>
      <link href="/2020/05/25/title-shu-ju-ku-cu-lue-hui-gu-er/"/>
      <url>/2020/05/25/title-shu-ju-ku-cu-lue-hui-gu-er/</url>
      
        <content type="html"><![CDATA[<p>标签（空格分隔）： SQL  查询语句</p><h2 id="四、查询数据"><a href="#四、查询数据" class="headerlink" title="四、查询数据"></a>四、查询数据</h2><h3 id="4-1-基本查询"><a href="#4-1-基本查询" class="headerlink" title="4.1 基本查询"></a>4.1 基本查询</h3><p>要查询数据库表的数据，我们使用如下的SQL语句：</p><pre><code>SELECT * FROM &lt;表名&gt;</code></pre><p>假设表名是students，要查询students表的所有行，我们用如下SQL语句：    </p><pre><code>SELECT * FROM students</code></pre><p>使用SELECT <em> FROM students时，SELECT是关键字，表示将要执行一个查询，**</em>表示“所有列”**，FROM表示将要从哪个表查询，本例中是students表。</p><p>该SQL将查询出students表的<strong>所有数据</strong>。注意：<strong>查询结果也是一个二维表</strong>，它包含列名和每一行的数据。</p><p>要查询classes表的所有行，我们用如下SQL语句：</p><pre><code>SELECT * FROM classes</code></pre><p>SELECT语句其实并不要求一定要有FROM子句。我们来试试下面的SELECT语句：<br>SELECT语句其实并不要求一定要有FROM子句。我们来试试下面的SELECT语句：</p><pre><code>SELECT 100+200;100 + 200300</code></pre><p>上述查询会直接计算出表达式的结果。虽然SELECT可以用作计算，但它并不是SQL的强项。但是，不带FROM子句的SELECT语句有一个有用的用途，就是用来<strong>判断当前到数据库的连接是否有效</strong>。许多检测工具会执行一条SELECT 1;来测试数据库连接。</p><h4 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h4><p><strong>使用SELECT查询的基本语句SELECT <em> FROM  &lt;表名&gt; 可以查询一个表的所有行和所有列的数据。<br>SELECT查询的结果是一个</em>二维表*。</strong></p><hr><h3 id="4-2-条件查询"><a href="#4-2-条件查询" class="headerlink" title="4.2 条件查询"></a>4.2 条件查询</h3><p>根据条件选择性地获取指定条件的记录例如，查询分数在80分以上的学生记录。在一张表有数百万记录的情况下，获取所有记录不仅费时，还费内存和网络带宽。</p><p>SELECT语句可以通过<strong>WHERE条件</strong>来设定查询条件，查询结果是满足查询条件的记录。例如，要指定条件“分数在80分或以上的学生”，写成WHERE条件就是</p><pre><code>SELECT * FROM students WHERE score &gt;= 80。</code></pre><p>其中，WHERE关键字后面的score &gt;= 80就是条件。score是列名，该列存储了学生的成绩，因此，score &gt;= 80就筛选出了指定条件的记录：</p><p>因此，条件查询的语法就是：</p><pre><code>SELECT * FROM &lt;表名&gt; WHERE &lt;条件表达式&gt;</code></pre><p>条件表达式可以用&lt;条件1&gt; AND &lt;条件2&gt;表达满足条件1并且满足条件2。例如，符合条件“分数在80分或以上”，并且还符合条件“男生”，把这两个条件写出来：</p><pre><code>SELECT * FROM students WHERE score &gt;=80 AND gender = &#39;M&#39;</code></pre><p>第二种条件是&lt;条件1&gt; OR &lt;条件2&gt;，表示满足条件1或者满足条件2。</p><pre><code>SELECT * FROM students WHERE score &gt;= 80 OR gender = &#39;M&#39;</code></pre><p>第三种条件是NOT &lt;条件&gt;，表示“不符合该条件”的记录。<br>eg:</p><pre><code>SELECT * FROM students WHERE NOT class_id =2;</code></pre><p>上述NOT条件<code>NOT class_id = 2</code>其实等价于<code>class_id &lt;&gt; 2</code>，因此，NOT查询不是很常用。</p><p>要组合三个或者更多的条件，就需要用小括号()表示如何进行条件运算。例如，编写一个复杂的条件：分数在80以下或者90以上，并且是男生：</p><pre><code>SELECT * FROM students WHERE (score &lt;80 OR score &gt; 90) AND gender = &#39;M&#39;;</code></pre><p>如果不加括号，条件运算按照NOT、AND、OR的优先级进行，即NOT优先级最高，其次是AND，最后是OR。加上括号可以改变优先级。</p><h4 id="常用的条件表达式"><a href="#常用的条件表达式" class="headerlink" title="常用的条件表达式"></a>常用的条件表达式</h4><p>=   &gt;  &gt;=  &lt;  &lt;= </p><pre><code>&lt;&gt;      不等于      score &lt;&gt; 80    name &lt;&gt; &#39;abc&#39;使用LIKE判断相似    name LIKE &#39;ab%&#39;            name LIKE &#39;%bc%&#39;    %表示任意字符，例如&#39;ab%&#39;将匹配&#39;ab&#39;，&#39;abc&#39;，&#39;abcd&#39;</code></pre><h4 id="小结-1"><a href="#小结-1" class="headerlink" title="小结"></a>小结</h4><p>通过WHERE条件查询，可以筛选出符合指定条件的记录，而不是整个表的所有记录。</p><hr><h3 id="4-3-投影查询"><a href="#4-3-投影查询" class="headerlink" title="4.3 投影查询"></a>4.3 投影查询</h3><p>使用<code>SELECT * FROM &lt;表名&gt; WHERE &lt;条件&gt;</code>可以选出表中的若干条记录。我们注意到返回的二维表结构和原表是相同的，即<strong>结果集的所有列与原表的所有列都一一对应。</strong></p><p>如果我们只希望返回某些列的数据，而不是所有列的数据，我们可以用<strong>SELECT 列1, 列2, 列3 FROM …，</strong>让结果集仅包含指定列。这种操作称为<em>投影查询</em></p><p>例如，从students表中返回id、score和name这三列：</p><pre><code>SELECT id, score, name FROM students;</code></pre><p>这样返回的结果集就只包含了我们指定的列，并且，<strong>结果集的列的顺序和原表可以不一样。</strong></p><p>使用<code>SELECT 列1, 列2, 列3 FROM ...</code>时，还可以给每一列起个别名，这样，结果集的列名就可以与原表的列名不同。它的语法是<code>SELECT 列1 别名1, 列2 别名2, 列3 别名3 FROM ...</code></p><p>例如，以下SELECT语句将列名score重命名为points，而id和name列名保持不变：</p><pre><code>SELECT id, score points, name FROM students;</code></pre><p>投影查询同样可以接WHERE条件，实现复杂的查询：</p><p>SELECT id, score points, name FROM students WHERE gender = ‘M’;</p><h4 id="小结-2"><a href="#小结-2" class="headerlink" title="小结"></a>小结</h4><p>使用SELECT <em>表示查询表的所有列，使用SELECT 列1, 列2, 列3则可以仅返回指定列，这种操作称为<em>*投影</em></em>。</p><p>SELECT语句可以对结果集的列进行<strong>重命名</strong>。</p><hr><h3 id="4-4-排序"><a href="#4-4-排序" class="headerlink" title="4.4 排序"></a>4.4 排序</h3><p>使用SELECT查询时，查询结果集通常是按照id排序的，也就是根据主键排序。如果我们要根据其他条件排序，可以加上ORDER BY子句。<br>例如按照成绩从低到高进行排序：</p><pre><code>SELECT id, name, gender, score FROM students ORDER BY score;</code></pre><p>如果要反过来，按照成绩从高到底排序，我们可以加上 DESC 表示“倒序”：(DESCEND的缩写啊）</p><pre><code>SELECT id, name, gender, score FROM students    ORDER BY score  DESC;</code></pre><p>如果score列有相同的数据，要进一步排序，可以继续添加列名。例如，使用<code>ORDER BY score DESC, gender</code>表示先按score列倒序，如果有相同分数的，再按gender列排序：</p><pre><code>SELECT id, name, gender, score  FROM    students ORDER BY score DESC, gender;</code></pre><p>默认的排序规则是<strong>ASC</strong>：“升序”，即从小到大。ASC可以省略，即ORDER BY score ASC和ORDER BY score效果一样。</p><p>如果有WHERE子句，那么ORDER BY子句要放到WHERE子句后面。例如，查询一班的学生成绩，并按照倒序排序：</p><pre><code>SELECT id, name, gender, socre  FROM students WHERE class_id = 1 ORDER BY score DESC;</code></pre><p>这样，结果集仅包含符合WHERE条件的记录，并按照ORDER BY的设定排序。</p><h4 id="小结-3"><a href="#小结-3" class="headerlink" title="小结"></a>小结</h4><p>使用ORDER BY可以对结果集进行排序；<br>可以对多列进行升序、倒序排序。</p><hr><h3 id="4-5-分页查询"><a href="#4-5-分页查询" class="headerlink" title="4.5 分页查询"></a>4.5 分页查询</h3><p>使用SELECT查询时，如果结果集数据量很大，比如几万行数据，放在一个页面显示的话数据量太大，不如分页显示，每次显示100条。</p><p>分页实际上就是从结果集中“截取”出第M~N条记录。这个查询可以通过<code>LIMIT &lt;M&gt; OFFSET &lt;N&gt;</code>子句实现。<br>我们先把所有学生按照成绩从高到低进行排序：</p><pre><code>SELECT id, name, gender, score FROM students ORDER BY score DESC;</code></pre><p>现在，我们把结果集分页，每页3条记录。要获取第1页的记录，可以使用 LIMIT 3 OFFSET 0：</p><pre><code>SELECT id, name, gender, scoreFROM studentsORDER BY score DESCLIMIT 3 OFFSET 0;</code></pre><p>上述查询LIMIT 3 OFFSET 0表示，<em>对结果集从0号记录开始，最多取3条</em>。<strong>注意SQL记录集的索引从0开始。</strong></p><p>如果要查询第2页，那么我们只需要“跳过”头3条记录，也就是对结果集从3号记录开始查询，把OFFSET设定为3：</p><pre><code>SELECT id, name, gender, scoreFROM studentsORDER BY score DESCLIMIT 3 OFFSET 3;</code></pre><p>类似的，查询第3页的时候，OFFSET应该设定为6:</p><pre><code>SELECT id, name, gender, scoreFROM studentsORDER BY score DESCLIMIT 3 OFFSET 6;</code></pre><p>查询第4页的时候，OFFSET应该设定为9:</p><p>由于第4页只有1条记录，因此最终结果集按实际数量1显示。LIMIT 3表示的意思是“最多3条记录”。</p><p>可见，分页查询的关键在于，首先要确定每页需要显示的结果数量pageSize（这里是3），然后根据当前页的索引pageIndex（从1开始），确定 LIMIT 和 OFFSET 应该设定的值：</p><p>REMEMBER</p><ul><li>LIMIT总是设定为pageSize；</li><li>OFFSET计算公式为pageSize * (pageIndex - 1)。</li></ul><p>这样就能正确查询出第N页的记录集。</p><p>如果原本记录集一共就10条记录，但我们把OFFSET设置为20，会得到什么结果呢？</p><pre><code>SELECT id, name, gender, scoreFROM studentsORDER BY score DESCLIMIT 3 OFFSET 20;</code></pre><p>OFFSET超过了查询的最大数量并不会报错，而是得到一个空的结果集。</p><h4 id="注意"><a href="#注意" class="headerlink" title="注意"></a>注意</h4><p>OFFSET是可选的，如果只写LIMIT 15，那么相当于LIMIT 15 OFFSET 0。</p><p>在MySQL中，LIMIT 15 OFFSET 30还可以<strong>简写</strong>成LIMIT 30, 15。</p><p>使用<code>LIMIT &lt;M&gt; OFFSET &lt;N&gt;</code>分页时，随着N越来越大，查询效率也会越来越低。</p><h4 id="小结-4"><a href="#小结-4" class="headerlink" title="小结"></a>小结</h4><p>使用<code>LIMIT &lt;M&gt; OFFSET &lt;N&gt;</code>可以对结果集进行分页，每次查询返回结果集的一部分；</p><p>分页查询需要先确定每页的数量和当前页数，然后确定LIMIT和OFFSET的值。</p><hr><h3 id="4-6-聚合查询"><a href="#4-6-聚合查询" class="headerlink" title="4.6 聚合查询"></a>4.6 聚合查询</h3><p>对于 统计总数、平均数 这类计算，SQL提供了专门的聚合函数，使用聚合函数进行查询，就是<strong>聚合查询</strong>，它可以快速获得结果。</p><p>以查询students表一共有多少条记录为例，我们可以使用SQL<strong>内置的COUNT()函数</strong>查询：</p><pre><code>SELECT COUNT(*) FROM students;COUNT(*)10</code></pre><p>COUNT(*)表示查询所有列的行数，要注意聚合的计算结果虽然是一个数字，但查询的结果仍然是一个二维表，只是这个二维表只有一行一列，并且列名是COUNT(*)</p><p>通常，使用聚合查询时，我们应该给<strong>结果集的列名</strong>设置一个别名，便于处理结果：</p><pre><code>SELECT COUNT(*) num FROM students;</code></pre><p>COUNT(*)和COUNT(id)（或者score啊，gender啊）实际上是一样的效果。另外注意，聚合查询同样可以使用WHERE条件，因此我们可以方便地统计出有多少男生、多少女生、多少80分以上的学生等：</p><pre><code>SELECT COUNT(*) boys FROM students WHERE  gender = &#39;M&#39;</code></pre><p>除了COUNT()函数外，SQL还提供了如下聚合函数：</p><pre><code>函数    说明SUM    计算某一列的合计值，该列必须为数值类型AVG    计算某一列的平均值，该列必须为数值类型MAX    计算某一列的最大值MIN    计算某一列的最小值</code></pre><p><strong>注意</strong>，MAX()和MIN()函数并不限于数值类型。如果是字符类型，MAX()和MIN()会返回排序最后和排序最前的字符。 (大小写不敏感）</p><p>要统计男生的平均成绩，我们用下面的聚合查询：</p><pre><code>SELECT AVG(score) average FROM students WHERE gender =&#39;M&#39;;</code></pre><p>要特别注意：如果聚合查询的WHERE条件没有匹配到任何行，COUNT()会返回<strong>0</strong>，而SUM()、AVG()、MAX()和MIN()会返回<strong>NULL</strong>：</p><pre><code> 每页3条记录，如何通过聚合查询获得总页数？  SELECT CEILING(COUNT(*) / 3) FROM students;</code></pre><h4 id="分组"><a href="#分组" class="headerlink" title="分组"></a>分组</h4><p>如果我们要统计一班的学生数量，我们知道，可以用SELECT COUNT(*) num FROM students WHERE class_id = 1;。如果要继续统计二班、三班的学生数量，难道必须不断修改WHERE条件来执行SELECT语句吗？</p><p><strong>（我的理解是 ：分组的意义在于可以查询多个同样条件的值）</strong></p><p>对于聚合查询，SQL还提供了“分组聚合”的功能  </p><pre><code>按class_id分组:SELECT MAX(*) num FROM students GROUP BY class_id;//resultnumNULLNULLNULL</code></pre><p>执行这个查询，COUNT()的结果不再是一个，而是3个，这是因为，GROUP BY子句指定了按class_id分组，因此，执行该SELECT语句时，<strong>会把class_id相同的列先分组，再分别计算，因此，得到了3行结果。</strong></p><p>但是这3行结果分别是哪三个班级的，不好看出来，所以我们可以把class_id列也放入结果集中：</p><pre><code>SELECT class_id, COUNT(*) num FROM students GROUP BY class_id; //resultclass_id    num1           42           33           3</code></pre><p>这下结果集就可以一目了然地看出各个班级的学生人数。我们再试试把name放入结果集：</p><pre><code>SELECT name, class_id, COUNT(*) num FROM students GROUP BY class_id;//resultname    class_id    numNULL    1           4NULL    2            3NULL    3            3</code></pre><p>不出意外，执行这条查询我们会得到一个语法错误，因为在任意一个分组中，只有class_id都相同，name是不同的，<strong>SQL引擎不能把多个name的值放入一行记录中</strong>。因此，聚合查询的列中，只能放入分组的列。</p><p>也可以使用多个列进行分组。例如，我们想统计各班的男生和女生人数：</p><pre><code>-- 按class_id, gender分组:SELECT class_id, gender, count(*) num FROM students GROUP BY class_id, gender;   //共 3 * 2  = 6 条记录分别对应各班级的男生和女生人数</code></pre><h4 id="练习"><a href="#练习" class="headerlink" title="练习"></a>练习</h4><p>1.请使用一条SELECT查询查出每个班级的平均分：</p><pre><code> 查出每个班级的平均分，结果集应当有3条记录: SELECT class_id, AVG(score) average_of_class  FROM students GROUP BY class_id（不分组的话不能返回多个啊）//RESULTSclass_id    average_of_class1           86.52            73.666666666666673            89.33333333333333</code></pre><ol start="2"><li><p>请使用一条SELECT查询查出每个班级男生和女生的平均分：</p><pre><code> SELECT class_id, gender, AVG(score) average FROM students GROUP BY class_id, gender;</code></pre></li></ol><pre><code>    //RESULTS    class_id    gender    average        1           M        89        1           F       84        2           F       81        2           M        70        3           F        89.5        3           M       89</code></pre><h4 id="小结-5"><a href="#小结-5" class="headerlink" title="小结"></a>小结</h4><p>使用SQL提供的聚合查询，我们可以方便地计算总数、合计值、平均值、最大值和最小值；<br>聚合查询也可以添加WHERE条件。</p><hr><h3 id="4-7-多表查询"><a href="#4-7-多表查询" class="headerlink" title="4.7 多表查询"></a>4.7 多表查询</h3><p>SELECT查询不但可以从一张表查询数据，还可以从多张表同时查询数据。查询多张表的语法是：<br><code>SELECT * FROM &lt;表1&gt; &lt;表2&gt;。</code></p><p>如，同时从students表和classes表的<strong>“乘积”</strong>，即查询数据，可以这么写：</p><pre><code>SELECT * FROM students, classes;//最后得到了四十条数据 十个人 四个班</code></pre><p>这种一次查询两个表的数据，查询的结果也是一个二维表，它是students表和classes表的“乘积”，即<strong>students表的每一行与classes表的每一行都两两拼在一起返回</strong>。<br>结果集的<strong>列数</strong>是students表和classes表的列数之<strong>和</strong>，<strong>行数</strong>是students表和classes表的行数之<strong>积</strong>。</p><p>这种多表查询又称<strong>笛卡尔查询</strong>，使用笛卡尔查询时要非常小心，由于结果集是目标表的行数乘积，对两个各自有100行记录的表进行笛卡尔查询将返回1万条记录，对两个各自有1万行记录的表进行笛卡尔查询将返回1亿条记录。</p><pre><code>id    class_id    name    gender    score    id    name1    1            小明        M       90    1    一班1    1            小明        M      90    2    二班1    1            小明        M      90    3    三班1    1            小明        M       90    4    四班2    1            小红        F      95    1    一班2    1           小红        F       95    2    二班2    1            小红        F      95    3    三班2    1            小红        F       95    4    四班。。。。。。。。。。。。。。。。。。。。。。。。。。</code></pre><p>上述查询的结果集（省略）有两列id和两列name，两列id是因为其中一列是students表的id，而另一列是classes表的id，但是在结果集中，不好区分。两列name同理</p><p>要解决这个问题，我们仍然可以利用投影查询的“<strong>设置列的别名</strong>”来给两个表各自的id和name列起别名：</p><pre><code>-- set alias:SELECT     students.id     sid,    students.name,    students.gender,    students.score,    class.id    cid,    class.name  cnameFROM students, classes;</code></pre><p><strong>注意</strong>，多表查询时，要使用 <code>表名.列名</code> 这样的方式来引用列和设置别名，这样就避免了结果集的列名重复问题。但是，用<code>表名.列名</code><br>这种方式列举两个表的所有列实在是很麻烦，所以SQL还允许<strong>给表设置一个别名</strong>，让我们在投影查询中引用起来稍微简洁一点：    </p><pre><code>-- set table alias:SELECT    s.id    sid,    s.name,    s.gender,    s.score,    c.id    cid,    c.name  cname    //这里不需要逗号！！！FROM    students    s, classes  c;//细节啊</code></pre><p>注意到FROM子句给表设置别名的语法是FROM &lt;表名1&gt; &lt;别名1&gt;, &lt;表名2&gt; &lt;别名2&gt;。这样我们用别名s和c分别表示students表和classes表。</p><p>多表查询也是可以添加WHERE条件的</p><pre><code>-- set where clause:SELECT     s.id sid,    s.name,    s.gender,    s.score,    c.id cid,    c.name cnameFROM students s, classes cWHERE s.gender = &#39;M&#39;  AND c.id =1//得到 5*1 = 5个记录</code></pre><p>这个查询的结果集每行记录都满足条件s.gender = ‘M’和c.id = 1。添加WHERE条件后结果集的数量大大减少了。    </p><h4 id="小结-6"><a href="#小结-6" class="headerlink" title="小结"></a>小结</h4><ul><li>使用多表查询可以获取M x N行记录；</li><li>多表查询的结果集可能非常巨大，小心使用。</li></ul><hr><h3 id="4-8-连接查询"><a href="#4-8-连接查询" class="headerlink" title="4.8 连接查询"></a>4.8 连接查询</h3><p>连接查询是另一种类型的多表查询。连接查询对多个表进行JOIN运算，简单地说，就是<strong>先确定一个主表作为结果集，然后，把其他表的行有选择性地“连接”在主表结果集上</strong></p><p>例如，我们想要选出students表的所有学生信息，可以用一条简单的SELECT语句完成：</p><pre><code>SELECT     s.id, s.name,     s.class_id, s.gender,    s.score FROM     students s;</code></pre><p>但是，假设我们希望结果集同时包含所在班级的名称，上面的结果集只有class_id列，缺少对应班级的name列。</p><p>现在问题来了，存放班级名称的name列存储在classes表中，只有根据students表的class_id，<strong>找到classes表对应的行，再取出name列</strong>，就可以获得班级名称。</p><p>这时，连接查询就派上了用场。我们先使用最常用的一种<strong>内连接——INNER JOIN</strong>来实现：</p><pre><code>-- 选出所有学生，同时返回班级名称SELECT    s.id,   s.name, s.class_id,    c.name  class_name,    s.gender,   s.scoreFROM    students    sINNER JOIN  classe  cON  s.class_id  =   c.id;id    name    class_id    class_name    gender    score1    小明        1           一班        M        902    小红        1           一班        F        953    小军        1           一班        M        884    小米        1            一班        F        735    小白        2            二班        F        816    小兵        2           二班      M        557    小林        2            二班        M        858    小新        3            三班        F        919    小王        3           三班        M        8910    小丽        3            三班        F        88</code></pre><p>注意INNER JOIN查询的写法是：</p><ul><li>1、先确定主表，仍然使用FROM &lt;表1&gt;的语法；</li><li>2、再确定需要连接的表，使用INNER JOIN &lt;表2&gt;的语法；</li><li>3、然后确定连接条件，使用<code>ON &lt;条件...&gt;</code>，这里的条件是<code>s.class_id = c.id</code>，表示students表的class_id列与classes表的id列相同的行需要连接；</li><li>4、可选：加上WHERE子句、ORDER BY等子句。</li></ul><p>使用别名不是必须的，但可以更好地简化查询语句。</p><p>那什么是内连接（INNER JOIN）呢？先别着急，有内连接（INNER JOIN）就有外连接（OUTER JOIN）。我们把内连接查询改成外连接查询，看看效果：</p><pre><code>-- 使用OUTER JOINSELECT        s.id,   s.name, s.class_id,        c.name  class_name,        s.gender,   s.scoreFROM    students    sRIGHT OUTER JOIN  classe  cON  s.class_id  =   c.id;//结果略</code></pre><p>执行上述RIGHT OUTER JOIN可以看到，和INNER JOIN相比，RIGHT OUTER JOIN多了一行，多出来的一行是“四班”，但是，学生相关的列如name、gender、score都为NULL。</p><p>这也容易理解，因为根据ON条件s.class_id = c.id，classes表的id=4的行正是“四班”，但是，students表中并不存在class_id=4的行。</p><p>有RIGHT OUTER JOIN，就有LEFT OUTER JOIN，以及FULL OUTER JOIN。它们的区别是：</p><ul><li><p>1、INNER JOIN只返回同时存在于两张表的行数据，由于students表的class_id包含1，2，3，classes表的id包含1，2，3，4，所以，INNER JOIN根据条件s.class_id = c.id返回的结果集仅包含1，2，3。</p></li><li><p>2、RIGHT OUTER JOIN返回右表都存在的行。如果某一行仅在右表存在，那么结果集就会以NULL填充剩下的字段。</p></li><li><p>3、LEFT OUTER JOIN则返回左表都存在的行。如果我们给students表增加一行，并添加class_id=5，由于classes表并不存在id=5的行，所以，LEFT OUTER JOIN的结果会增加一行，对应的class_name是NULL：</p></li></ul><pre><code>   -- 先增加一列class_id=5:    INSERT INTO students (class_id, name, gender, score) values (5, &#39;新生&#39;, &#39;M&#39;, 88);    -- 使用LEFT OUTER JOIN    SELECT         s.id, s.name, s.class_id,                 c.name class_name, s.gender,              s.score    FROM students s    LEFT OUTER JOIN classes c    ON s.class_id = c.id;    //RESULTS 多了一行    id    name    class_id    class_name    gender    score    11    新生    5    NULL    M    88</code></pre><p>最后，我们使用FULL OUTER JOIN，它会把两张表的所有记录全部选择出来，并且，自动把对方不存在的列填充为NULL：</p><pre><code>-- 使用FULL OUTER JOINSELECT             s.id, s.name, s.class_id,                 c.name class_name, s.gender,              s.score        FROM students s        FULL OUTER JOIN classes c        ON s.class_id = c.id;        //RESULTS 多了两行id        name    class_id    class_name    gender        score11        新生        5            NULL        M           88 NULL    NULL        NULL        四班        NULL        NULL</code></pre><h4 id="小结-7"><a href="#小结-7" class="headerlink" title="小结"></a>小结</h4><ul><li>总的来说，我觉得<br>INNER JOIN 即  A ∩ B<br>LEFT OUTER JOIN 即 A∪ （A∩B）<br>RIGHT OUTER JOIN 即 B∪ （A∩B）<br>FULL OUTER JOIN 即 A ∪ B<br>（有图更形象）</li><li>JOIN查询需要先确定主表，然后把另一个表的数据“附加”到结果集上；INNER JOIN是最常用的一种JOIN查询，它的语法是    SELECT … FROM &lt;表1&gt; INNER JOIN &lt;表2&gt; ON &lt;条件…&gt;；</li><li>JOIN查询仍然可以使用WHERE条件和ORDER BY排序。</li></ul><hr>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>MySQL 学习： DQL、约束、范式</title>
      <link href="/2020/05/25/title-mysql-xue-xi-dql-yue-shu-fan-shi/"/>
      <url>/2020/05/25/title-mysql-xue-xi-dql-yue-shu-fan-shi/</url>
      
        <content type="html"><![CDATA[<p>标签（空格分隔）： DQL 约束 范式 </p><h1 id="内容"><a href="#内容" class="headerlink" title="内容"></a>内容</h1><pre><code>    一、 DQL 查询语句        1.排序查询        2.聚合函数        3.分组查询        4.分页查询    二、约束    三、多表间关系    四、范式    五、数据库备份与还原</code></pre><hr><h2 id="DQL-查询语句"><a href="#DQL-查询语句" class="headerlink" title="DQL 查询语句"></a>DQL 查询语句</h2><h3 id="排序查询"><a href="#排序查询" class="headerlink" title="排序查询"></a>排序查询</h3><p> <strong>语法</strong>：<code>ORDER BY 子句</code><br> <strong>eg:</strong> </p><pre><code>ORDER BY 排序字段1 排序方式1， 排序字段2 排序方式2 ....</code></pre><p><strong>排序方式：</strong>   </p><pre><code>ASC 升序 默认方式DESC 降序 </code></pre><p> <strong>注意：</strong>  如果有多个排序条件，则当前面的条件值相同时才考虑后面的排序条件      </p><h3 id="聚合函数"><a href="#聚合函数" class="headerlink" title="聚合函数"></a>聚合函数</h3><pre><code>    将一列数据作为一个整体，进行纵向计算</code></pre><ol><li>count</li><li>max, min</li><li>sum, avg</li></ol><p><strong>注</strong>：聚合函数的计算排除了 NULL值， </p><p><strong>解决方案：</strong><br>1.一般选择非空的列:主键<br>2.IFNULL</p><p>eg:</p><pre><code>SELECT COUNT(english)) FROM student;//排除NULLSELECT COUNT(IFNULL(english, 0)) FROM student; //有NULL作0</code></pre><h3 id="分组查询"><a href="#分组查询" class="headerlink" title="分组查询"></a>分组查询</h3><p> <strong>语法</strong>：<code>GROUP BY 子句</code><br> <strong>注意!：</strong><br> 1.分组之后查询的字段： 分组字段、聚合函数</p><ol start="2"><li><p>where 和 having 的区别</p><p>a. where 在分组前进行限定，若不满足条件，则不参与分组。having 在分组之后进行线性，若不满足条件，则不会被查询出来。<br>b. where 后不可以跟聚合函数， having 可以进行聚合函数的判断</p></li></ol><p> eg:</p><pre><code>-- 按照性别分组，分别查询男女同学平均分SELECT  sex, AVG(math) FROM student GROUP BY sex;-- 按照性别分组，分别查询男女同学平均分，人数SELECT sex, AVG(math), COUNT(id) FROM student GROUP BY sex;-- 按照性别分组，分别查询男女同学平均分，人数 要求：分数低于70分的人，不参与分组（分组前添加限定条件）SELECT sex, AVG(math), COUNT(id) FROM studentWHERE math&gt; 70 GROUP BY sex;-- 按照性别分组，分别查询男女同学平均分，人数 要求：分数低于70分的人，不参与分组，分组之后，人数要大于两个人(分组之后限定条件）SELECT sex, AVG(math), COUNT(id) numberFROM studentWHERE math&gt;70GROUP BY SEXHAVING number &gt;2; //起别名判断更方便</code></pre><h3 id="分页查询"><a href="#分页查询" class="headerlink" title="分页查询"></a>分页查询</h3><p><strong>语法</strong>：<code>limit 开始的索引， 每页查询的条数;</code><br><strong>公式</strong>： <code>开始的索引 = （当前页码 - 1） *每页显示的条数</code><br>limit 是一个“方言”，不同数据库对应函数不同。<br>eg:</p><pre><code>-- 每页显示三条记录SELECT *FROM student LIMIT 0,3;    --第一页SELECT *FROM student LIMIT 3,3;    --第二页SELECT *FROM student LIMIT 6,3;    --第二页</code></pre><hr><h2 id="约束"><a href="#约束" class="headerlink" title="约束"></a>约束</h2><p><strong>概念：</strong>对表中数据进行限定，保证数据的正确性、有效性、完整性<br><strong>分类：</strong><br>1.主键约束： primary key<br>2.非空约束:  not null<br>3.唯一约束:  unique<br>4.外键约束:  foreign key</p><h3 id="非空约束-NOT-NULL"><a href="#非空约束-NOT-NULL" class="headerlink" title="非空约束 NOT NULL"></a>非空约束 NOT NULL</h3><pre><code>某一列值不能为NULL；</code></pre><p>1.创建表时添加约束</p><pre><code>CRETE TABLE stu{    id INT,    name VARCHAR(20) NOT NULL  --name非空}；-- 删除 name的非空约束ALTER TABLE stu  MODIFY NAME VARCHAR(20);</code></pre><p>2 . 创建表后，添加约束</p><pre><code>       ALTER TABLE stu  MODIFY NAME VARCHAR(20) NOT NULL；</code></pre><h3 id="唯一约束"><a href="#唯一约束" class="headerlink" title="唯一约束"></a>唯一约束</h3><pre><code>某一列值不能重复</code></pre><p><strong>注意</strong>：唯一约束可以NULL值，但只能有一条记录为NULL。<br>1.创建表时添加约束</p><pre><code>CRETE TABLE stu{    id INT,    phone_number VARCHAR(20) UNIQUE  --name非空}；-- 删除唯一约束（错误方法 ×），和删除非空约束不太一样ALTER TABLE stu  MODIFY phone_number VARCHAR(20);-- 删除唯一约束的正确操作ALTER TABLE stu DROP INDEX phone_numher;</code></pre><p>2.创建表后添加约束</p><pre><code>ALTER TABLE stu MODIFY phone_number VARCHAR(20) UNIQUE;</code></pre><h3 id="主键约束"><a href="#主键约束" class="headerlink" title="主键约束"></a>主键约束</h3><p>1、注意：</p><pre><code>1.含义：非空且唯一 2.一张表只能有一个字段为主键3.主键是表中记录的唯一标识</code></pre><p>2、创建表时，添加主键约束</p><pre><code>CREATE TABLE stu{    id INT  PRIMARY KEY, -- 给id 添加主键约束    name VARCHAR(20)};</code></pre><p>3、删除主键</p><pre><code>-- 错误做法 alter table stu modify id int;--正确做法,因为只有一个主键，不必指明ALTER TABLE stu DROP PRIMARY KEY;</code></pre><p>4、创建表后，添加主键</p><pre><code>ALTER TABLE stu MODIFY id INT PRIMARY KEY;</code></pre><p>5、自动增长(一般配合主键使用)</p><pre><code>1.概念：如果某一列为数值类型，使用 auto_increment 可以用来完成值的自动增长2.在创建表时，添加主键约束，并且完成主键自增长(和上条记录相关）create table stu{    id int primary key auto_increment, -- 给id 添加主键约束    name varchar(20)};3. --删除自动增长    alter table stu modiy id int;         (并不会删除主键）4. --添加自动增长    alter table stu modiy id int auto_increment;</code></pre><h3 id="外键约束"><a href="#外键约束" class="headerlink" title="外键约束"></a>外键约束</h3><pre><code>让表间产生关系，保证数据的正确性</code></pre><ol><li><p>创建表时，可以添加外键<br>语法：</p><pre><code>create table 表名{    ...    外键列,    constraint 外键名称 foreign key ( 外键列名称) references 主表名称(主表主键名称)}；</code></pre><p>eg:</p><pre><code>--部门表CREATE TBALE department{        id INT PRIMARY KEY AUTO_INCREMENT,        dep_name VARCHAR(20),        dep_lacation VARCHAR(20)};--创建员工表    多方、从表CREATE TBALE employee{        id INT PRIMARY KEY AUTO_INCREMENT,        name VARCHAR(20),        age INT,        dep_id INT，    -- 外键对应主表的主键        CONSTRAINT emp_dept_fk FOREIGN KEY(dep_id) REFERENCES department(id);};</code></pre></li><li><p>删除外键</p><pre><code> ALTER TABLE 表名 DROP FOREIGN KEY 外键名称;</code></pre></li><li><p>添加外键</p><pre><code>ALTER TABLE 表名ADD CONSTRAINT 外键名称 FOREIGN   KEY(外键字段名称) REFERENCES 主表名称(主表列名称);</code></pre></li></ol><p>4.级联操作<br>    添加外键时设置级联更新<br>    1.语法：</p><pre><code>        ALTER TABLE 表名        ADD CONSTRAINT 外键名称 FOREIGN   KEY(外键字段名称)         REFERENCES 主表名称(主表列名称)        ON UPDATE CASCADE; --更新</code></pre><p>2.分类：<br>    a.级联更新: ON UPDATE CASCADE （谨慎使用级联)<br>    b.级联删除：ON DELETE CASCADE</p><hr><h2 id="数据库设计"><a href="#数据库设计" class="headerlink" title="数据库设计"></a>数据库设计</h2><h3 id="一-多表之间的关系"><a href="#一-多表之间的关系" class="headerlink" title="一.多表之间的关系"></a>一.多表之间的关系</h3><pre><code>   A.  分类        1.一对一        2.一对多（多对一）            *分析：部分和员工间        3.多对多            *分析：学生和课程选课关系   B.  实现            1.一对多（多对一）            * 实现方式： 在多的一方（从表）建立外键，指向一（主表）的主键        2.多对多 （学生选课）            * 实现方式： 引入中间表             三种方式图解如下  </code></pre><p>一对一关系实现</p><p><img src="http://static.zybuluo.com/Adward-Wang/8vd4dju9cw0au4di3y50ozx4/%E4%B8%80%E5%AF%B9%E4%B8%80%E5%85%B3%E7%B3%BB%E5%AE%9E%E7%8E%B0.bmp" alt="一对一关系实现.bmp-2398.6kB"> </p><p>一对多关系实现            </p><p><img src="http://static.zybuluo.com/Adward-Wang/0y7a3l32se7hnuevbnntdco5/%E4%B8%80%E5%AF%B9%E5%A4%9A%E5%85%B3%E7%B3%BB%E5%AE%9E%E7%8E%B0.bmp" alt="一对多关系实现.bmp-2398.6kB"></p><p> 多对多关系实现</p><p><img src="http://static.zybuluo.com/Adward-Wang/wdwicrsnmlqaod5kl4hqxqdj/%E5%A4%9A%E5%AF%B9%E5%A4%9A%E5%85%B3%E7%B3%BB%E5%AE%9E%E7%8E%B0.bmp" alt="多对多关系实现.bmp-2398.6kB"></p><h3 id="二-数据库设计范式"><a href="#二-数据库设计范式" class="headerlink" title="二.数据库设计范式"></a>二.数据库设计范式</h3><p>1、第一范式（1NF）：数据库表的每一列都是不可分割的原子数据项<br>2、第二范式（2NF）<br>在1NF的基础上，非码属性必须完全依赖于候选码（在1NF基础上消除非主属性对主码的部分函数依赖）<br>3、第三范式（3NF）<br>在2NF基础上，任何非主属性不依赖于其它非主属性（在2NF基础上消除传递依赖）</p><p><strong>对三大范式的通俗理解:</strong></p><pre><code>1.第一范式：    原子性，不可分割2.第二范式：    消除部分依赖（通过表的拆分）3.第三范式：    消除传递依赖（还是通过表的拆分）*** 几个概念        1.函数依赖： A--&gt;B ,如果通过A属性的值，可以确定唯一B属性的值，则称B依赖于A    例如： 学号 --&gt; 姓名  (学号，课程名称） --&gt;分数     2.完全函数依赖： A --&gt; B, 如果A 是一个属性组， 则B属性值的确定需要依赖于A属性组中所有属性的值。    例如 （学号， 课程名称） --&gt;  分数     3.部分函数依赖： A --&gt; B, 如果A是一个属性组，则B属性值的确定只需要依赖A属性组中的某一些值即可。    例如： （学号, 课程名称) --&gt; 姓名     4.传递函数依赖： A--&gt; B, B --&gt;C， 如果通过A属性（属性组）的值，可以确定唯一B属性的值，再通过B属性（属性组）的值可以确定唯一C属性的值，则称C传递函数依赖于 A.     例如： 学号 --&gt; 系名 --&gt; 系主任     5.码： 如果一张表中，一个属性或者属性组 被 其他所有属性所完全依赖，则称这个属性（属性值）为该笔的码。     例如：该表中为（学号，课程名称）            * 主属性： 码属性组中的所有属性            * 非主属性： 不是码中的属性</code></pre><h3 id="数据库的备份和还原"><a href="#数据库的备份和还原" class="headerlink" title="数据库的备份和还原"></a>数据库的备份和还原</h3><p>1.命令行：</p><pre><code>备份语法： mysqldump -u用户名 -p密码 数据库名称 &gt;保存路径还原：     1.登录数据库    2.创建数据库   create database ***    3.使用数据库   use ***    4.执行文件（ source  数据库路径）</code></pre><p>2.图形界面<br>    导出sql 文件<br>    用Navicat导入时，我发现不能直接导入数据，必须新建数据库，再在表里右键选择导入sql  文件。</p><hr><h2 id="总结："><a href="#总结：" class="headerlink" title="总结："></a>总结：</h2><p>这算是在MySQL 基础上进一步说了一些知识了，关于 范式的内容也明白清晰了不少，还是觉得sql语句应该多用才能孰能生巧，并且应用到实际开发过程中，不能纸上谈兵！！！</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>MySQL多表 &amp;事务</title>
      <link href="/2020/05/25/title-mysql-duo-biao-shi-wu/"/>
      <url>/2020/05/25/title-mysql-duo-biao-shi-wu/</url>
      
        <content type="html"><![CDATA[<p>标签（空格分隔）： MySQL</p><h1 id="今日内容"><a href="#今日内容" class="headerlink" title="今日内容"></a>今日内容</h1><pre><code>1. 多表查询2. 事务3. DCL</code></pre><h2 id="多表查询"><a href="#多表查询" class="headerlink" title="多表查询"></a>多表查询</h2><h3 id="一、内连接查询"><a href="#一、内连接查询" class="headerlink" title="一、内连接查询"></a>一、内连接查询</h3><pre><code>    1.隐式内连接：使用where条件 消除无用    SELECT         t1.name, -- 员工表姓名        t1.gender, --员工表性别        t2.name, --部门表名称    FROM        emp t1,        dept t2,    WHERE        t1.dep_id = t2.id;    2. 显示内连接        语法：select 字段列表 from 表名1 （inner） join 表名2 on 条件；        eg:   select *from emp (inner) join dept on emp.dept_id = dept.id;    3. 内连接查询        a. 从哪些表中获取数据        b. 查询条件是什么        c. 查询哪些字段</code></pre><h3 id="二、外连接查询："><a href="#二、外连接查询：" class="headerlink" title="二、外连接查询："></a>二、外连接查询：</h3><pre><code>1.左外连接    语法：select 字段列表 from 表1 left [outer] join 表2 on 条件;    ** 查询的是左表所有数据以及其交集部分2.右外连接    语法：select 字段列表 from 表1 right [outer] join 表2 on 条件;    ** 查询的是右表所有数据以及其交集部分    </code></pre><h3 id="三、子查询"><a href="#三、子查询" class="headerlink" title="三、子查询"></a>三、子查询</h3><pre><code>** 概念：查询中嵌套查询，称嵌套查询为子查询--  查询工资最高的员工信息-- 1. 查询最高工资为多少  9000    SELECT MAX(salary) FROM emp;-- 2.查询员工信息，并且工资等于9000的    SELECT * FROM emp WHERE emp.salary = 9000;-- 一条SQL 完成上述操作. 子查询    SELECT * FROM emp WHERE emp.salary =(SELECT MAX(salary) FROM emp);** 子查询的不同情况    1. 子查询的结果是单行单列的；        * 子查询的结果可以作为条件，使用运算符去判断。运算符: &gt; &gt;= &lt; &lt;= =                       SELECT *FROM emp WHERE emp.salary &lt; (SELECT AVG(salary) FROM emp);    2. 子查询的结果是多行单列的；        * 子查询作为条件，使用运算符in 来判断        -- 查询‘财务部’和‘市场部’所有的员工信息        SELECT id FROM dept WHERE NAME =&#39;财务部&#39; OR NAME =&#39;市场部&#39;;        SELECT * FROM emp WHERE dep_id =3 OR dep_id =2;        --子查询        SELECT * FROM emp WHERE dep_id IN(SELECT id FROM dept WHERE NAME =&#39;财务部&#39; OR NAME =&#39;市场部&#39;);    3. 子查询的结是多行多列的         * 子查询可作为一张虚拟表        -- 查询员工入职日期是2011-11-11号之后的员工信息和部门信息        SELECT *FROM dept t1, (SELECT * FROM emp WHERE emp.join_date &gt;&#39;2011-11-11&#39;) t2        WHERE t1.id =t2.dep_id;</code></pre><h2 id="事务"><a href="#事务" class="headerlink" title="事务"></a>事务</h2><h3 id="一、事务的基本介绍"><a href="#一、事务的基本介绍" class="headerlink" title="一、事务的基本介绍"></a>一、事务的基本介绍</h3><pre><code>1.概念 ：  在实际的开发过程中，一个业务操作如：转账，往往是要多次访问数据库才能完成的。转账是一个用户扣钱，另一个用户加钱。如果其中有一条SQL语句出现异常，这条SQL就可能执行失败。 事务执行是一个整体，所有的SQL语句都必须执行成功。如果其中有1条SQL语句出现异常，则所有的SQL语句都要回滚，整个业务执行失败。 2.具体操作    1. 开启事务： start transaction;    2. 回滚：   roll back;    3. 提交：   commit;    4. MySQL 中事务默认自动提交    * 事务提交的两种方式        * 自动提交：            * MySQL就是自动提交        * 手动提交            * Oracle 默认手动提交事务            * 需要开启事务，再提交    * 修改事务的默认提交方式：        * 查看事务的。。。：SELECT @@autocommit; -- 1代表自动提交 0 代表手动提交        * 修改用SET 关键字：SET ... = 1(0);</code></pre><h3 id="二、事务的四大特征-ACID"><a href="#二、事务的四大特征-ACID" class="headerlink" title="二、事务的四大特征(ACID)"></a>二、事务的四大特征(ACID)</h3><pre><code>1.原子性（atomicy)： 是不可分割的最小操作单位2.持久性 (durability)： 当事务提交或回滚后，数据库会持久化地保存数据3.隔离性((isolation)：多个事务之间，相互独立。4.一致性(consistency)：事务操作前后，数据总量不变</code></pre><h3 id="三、事务的隔离级别（了解）"><a href="#三、事务的隔离级别（了解）" class="headerlink" title="三、事务的隔离级别（了解）"></a>三、事务的隔离级别（了解）</h3><pre><code>*概念：多个事务间隔离，相互独立，但是如果多个事务操作同一批数据，则会引发一些问题，设置不同的隔离级别就可以解决这些问题。*存在问题：    1. 脏读 ：一个事务，读取到另一个事务中没有提交的数据    2.不可重复度（虚读）：在同一个事务中，两次读到的数据不一样    3.幻读： 一个事务操作（DML）数据表中所有记录，另一个事务添加了一条数据，则第一个事务查不到自己的修改。*隔离级别：    1. read uncommitted: 读未提交        * 产生的问题： 脏读、不可重复度、幻读    2. read committed: 读已提交     （Oracle 默认)        * 产生的问题：不可重复读，幻读    3. repeatable read: 可重复读 （MySQL 默认)        * 产生的问题： 幻读    4. serializable: 串行化        * 可以解决所有问题    *注意：隔离级别从小到大安全性越来越高，但是效率越来越低。</code></pre><h2 id="DCL："><a href="#DCL：" class="headerlink" title="DCL："></a>DCL：</h2><pre><code>* SQL 分类    1.   DDL: 操作数据库和表    2.   DML： 增删改表中数据    3.   DQL： 查询表中数据    4.   DCL： 管理用户，授权* DBA： 数据库管理员* DCL： 管理用户，授权    1.管理用户        * 添加用户            * 语法： CREATE USER &#39;用户名&#39;@&#39;主机名&#39; IDENTIFIED BY &#39;密码&#39;;        * 删除用户            * 语法： DROP USER &#39;用户名&#39;@&#39;主机名&#39;;        * 修改用户密码            * 语法： UPDATE USER SET PASSWORD = PASSWORD（&#39;新密码&#39;) WHERE USER = &#39;用户名&#39;;//            SET PASSWORD FOR &#39;用户名’@&#39;主机名&#39;= PASSWORD(&#39;新密码&#39;);        * 查询用户            --1.切换到mysql数据库            USE mysql;            --2.查询user表            SELECT *FROM USER；            通配符：%表示可以在任意主机上登录    2.权限管理：        1.查询权限：            -- SHOW GRANTS FOR &#39;用户名&#39;@&#39;主机名&#39;;        2.授予权限：            -- GRANT 权限列表 ON 数据库名.表名 TO &#39;用户名&#39;@&#39;主机名&#39;;            -- 给与所以权限，在任意数据库任意表上             GRANT ALL ON *.* TO &#39;用户名&#39;@&#39;localhost&#39;;        3.撤销权限：            -- REVOKE 权限列表 ON 数据库名.表名 FROM &#39;用户名&#39;@&#39;主机名&#39;;</code></pre>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>Network Protocols and Architecture (1)</title>
      <link href="/2020/05/24/network-protocols-architecture-1/"/>
      <url>/2020/05/24/network-protocols-architecture-1/</url>
      
        <content type="html"><![CDATA[<h1 id="一、Week1"><a href="#一、Week1" class="headerlink" title="一、Week1"></a>一、Week1</h1><h2 id="1-Establishing-the-Rules"><a href="#1-Establishing-the-Rules" class="headerlink" title="1. Establishing the Rules"></a>1. Establishing the Rules</h2><h3 id="1-1-Reading-About-This-Course"><a href="#1-1-Reading-About-This-Course" class="headerlink" title="1.1 Reading: About This Course"></a>1.1 Reading: About This Course</h3><p>有几个这个课程提出的学习目标，等学完用来检测一下自己的学习情况。<br>At the end of this course, you will be able to:</p><ol><li>Explain how protocols and standards benefit a global internetwork.<br>解释协议和标准的作用方式？？？</li><li>Describe how the Ethernet Protocol transmits data within a LAN.<br>描述局域网下以太网协议如何传输数据？？？</li><li>Explain IPv4 addressing and the role of subnet masks.<br>解释IPv4寻址以及子网掩码的作用？？？</li><li>Use Cisco Packet Tracer to connect hosts to a wireless router in a LAN.<br>使用软件在局域网环境下将主机连接到无线路由器</li><li>Use a protocol analyzer or “packet sniffer” to open and examine a data packet that has been transmitted across a network.<br>使用协议分析器或者数据包分析器来打开并检查一个网络上的数据包</li><li>Examine a Windows computer to locate the physical or MAC address used send and receive data.<br>检查Windows计算机，找到用于发送和接收数据的物理地址（或MAC地址）。</li></ol><h3 id="1-2-Reading-Cisco-Packet-Tracer-软件介绍"><a href="#1-2-Reading-Cisco-Packet-Tracer-软件介绍" class="headerlink" title="1.2 Reading: Cisco Packet Tracer 软件介绍"></a>1.2 Reading: Cisco Packet Tracer 软件介绍</h3><h3 id="1-3-Reading-The-Three-Elements"><a href="#1-3-Reading-The-Three-Elements" class="headerlink" title="1.3 Reading: The Three Elements"></a>1.3 Reading: The Three Elements</h3><p>自古至今 任何一种网络的主要目的都是给我们提供一种交流和分享信息的途径。而分享信息则会让人类进步。</p><p>所有通信都以一条消息开始，从一个个体或者设备发送到另一个。而随着科技进步，消息发送、接收、传递的方法都会改变。</p><p>所有通信方法都具有<strong>三个共同要素</strong>：</p><ol><li>Message source or Sender</li><li>Destination or Receiver of the message</li><li>Transmission medium or channel</li></ol><p>Watch the animation below to see how messages are sent and received in human and computer communication.</p><p><img src="http://static.zybuluo.com/Adward-Wang/efjwwht0mklyazyi05h50n4z/The_Three_Elements.gif" alt="The_Three_Elements.gif-222.6kB"></p><h3 id="1-4-Reading-Communication-Protocols"><a href="#1-4-Reading-Communication-Protocols" class="headerlink" title="1.4 Reading: Communication Protocols"></a>1.4 Reading: Communication Protocols</h3><p>日常生活中的通信具有不同形式，不同的应用场景具有不同规则。<br>在开始彼此沟通之前，我们建立规则或协议来管理对话，如图1至图3所示。为了成功地传递和理解消息，必须遵循这些规则或协议。成功的人类交流协议包括:</p><ul><li>An identified sender and receiver    已标志的发送方和接收方</li><li>Agreed upon method of communicating (face-to-face, telephone, letter, photograph) 商定的沟通方式</li><li>Common language and grammar 共同的语言和语法</li><li>Speed and timing of delivery 交付的速度和时间</li><li>Confirmation or acknowledgment requirements 确认需求</li></ul><p>网络通信中使用的技术与人类间对话的基本原理类似。</p><p><img src="http://static.zybuluo.com/Adward-Wang/4jiuu83j1u8wnwln201ulfgj/1Method.jpg" alt="1Method.jpg-41.6kB"><br>Firgure1. Method</p><p><img src="http://static.zybuluo.com/Adward-Wang/l3jhtd0uayq0q2ihiafuz8a1/2Language.jpg" alt="2Language.jpg-39.9kB"><br>Firgure2. Language</p><p><img src="http://static.zybuluo.com/Adward-Wang/0lrqb0rh3tuxso8d0g0fpogp/3Confirmation.jpg" alt="3Confirmation.jpg-40kB"><br>Firgure1. Confirmation</p><h3 id="1-5-Video-Network-Protocols"><a href="#1-5-Video-Network-Protocols" class="headerlink" title="1.5 Video: Network Protocols"></a>1.5 Video: Network Protocols</h3><h3 id="1-6-Reading-Why-Protocols-Matter-为何协议很重要？"><a href="#1-6-Reading-Why-Protocols-Matter-为何协议很重要？" class="headerlink" title="1.6 Reading: Why Protocols Matter 为何协议很重要？"></a>1.6 Reading: Why Protocols Matter 为何协议很重要？</h3><p>In both a wired and wireless environment, a local network is defined as an area where all hosts must “speak the same language” or in computer terms “share a common protocol”.<br>在有线和无线环境中，<strong>局域网</strong>均定义为所有主机必须“说同一语言”或用计算机术语“共享通用协议”的区域。<br>Networking protocols define many aspects of communication over the local network, including: message format, message size, timing, encoding, and message patterns.</p><p>Review the figure below for more information.</p><p><img src="http://static.zybuluo.com/Adward-Wang/b73s0rd7z2s6wdi5s5z9q9vv/Why_Protocols_matter.jpg" alt="Why_Protocols_matter.jpg-36kB"></p><p><strong>Timing</strong><br>Many network communication functions are dependent on timing. Timing determines the speed at which the bits are transmitted across the network. It also affects when an individual host can send data and the total amount of data that can be sent in any one transmission.<br><strong>时序</strong><br>许多网络通信功能取决于时序。时序决定了比特在网络上传输的速度。它还会影响单个主机何时可以发送数据以及在任何一次传输中可以发送的数据总量。</p><p><strong>Message Size</strong> Message可译为报文<br>The rules that govern the size of the pieces communicated across the network are very strict. They can also be different, depending on the channel used. When a long message is sent from one host to another over a network, it may be necessary to break the message into smaller pieces in order to ensure that the message can be delivered reliably.</p><p><strong>Encapsulation</strong> 封装<br>Each message transmitted on a network must include a header that contains addressing information that identifies the source and destination hosts, otherwise it cannot be delivered. Encapsulation is the process of adding this information to the pieces of data that make up the message. In addition to addressing, there may be other information in the header that ensures that the message is delivered to the correct application on the destination host.</p><p><strong>Message Format</strong><br>When a message is sent from source to destination, it must use a specific format or structure. Message formats depend on the type of message and the channel that is used to deliver the message.</p><p><strong>Encoding</strong><br>Messages sent across the network are first converted into bits by the sending host. Each bit is encoded into a pattern of sounds, light waves, or electrical impulses depending on the network media over which the bits are transmitted. The destination host receives and decodes the signals in order to interpret the message.</p><p><strong>Message Patterns</strong><br>Some messages require an acknowledgment before the next message can be sent. This type of request/response pattern is a common aspect of many networking protocols. However, there are other types of messages that may be simply streamed across the network, without concern as to whether or not they reach their destination.<br>（暗示TCP UDP？？？）</p><hr><h2 id="2-So-Who-Makes-the-Rules"><a href="#2-So-Who-Makes-the-Rules" class="headerlink" title="2. So Who Makes the Rules"></a>2. So Who Makes the Rules</h2><h3 id="2-1-Reading-The-Internet-and-Standards"><a href="#2-1-Reading-The-Internet-and-Standards" class="headerlink" title="2.1 Reading: The Internet and Standards"></a>2.1 Reading: The Internet and Standards</h3><p>标准是一组规则，用来决定必须如何做某事。网络和Internet标准确保所有连接到网络的设备以相同的方式实现相同的规则或协议集。使用标准，不同类型的设备可以通过互联网互相发送信息.</p><p><img src="http://static.zybuluo.com/Adward-Wang/xu7c0gjcknd9bnav3vy1561k/Internet_Standards.gif" alt="Internet_Standards.gif-2904.5kB"></p><h3 id="2-2-Reading-Network-Standards-Organizations"><a href="#2-2-Reading-Network-Standards-Organizations" class="headerlink" title="2.2 Reading: Network Standards Organizations"></a>2.2 Reading: Network Standards Organizations</h3><p>Internet标准是讨论，问题解决和测试的全面循环的最终结果。如图所示，这些不同的标准由各种组织开发，发布和维护。当提出新标准时，开发和批准过程的每个阶段都记录在编号为Request for Comments（RFC）的文档中，以便跟踪该标准的演变。Internet标准的RFC由Internet工程任务组（IETF）发布和管理。</p><pre><code>Q: 没有统一的标准码？这段话是不是这个意思？“？</code></pre><p>You can check out the IETF website at <a href="http://ietf.org" target="_blank" rel="noopener">http://ietf.org</a>.</p><p><img src="http://static.zybuluo.com/Adward-Wang/c6g8l3brl0d97n4xkiearecj/n_organization.jpg" alt="n_organization.jpg-64.4kB"></p><hr><h2 id="3-Visualizing-How-Protocols-Work"><a href="#3-Visualizing-How-Protocols-Work" class="headerlink" title="3. Visualizing How Protocols Work"></a>3. Visualizing How Protocols Work</h2><h3 id="3-1-Reading-Stacking-Them-up"><a href="#3-1-Reading-Stacking-Them-up" class="headerlink" title="3.1 Reading: Stacking Them up"></a>3.1 Reading: Stacking Them up</h3><p>主机之间的成功通信需要多种协议之间的交互。而这些协议通过安装在每个主机和网络设备上的软件和硬件来实现。<br>The interaction between the different protocols on a device can be shown as a <strong>protocol stack</strong>, as shown in the figure. A stack illustrates the protocols as a <strong>layered hierarchy</strong>, with each higher-level protocol depending on the services of the protocols shown in the lower levels.（协议栈分层）</p><p>The separation of functions enables each layer in the stack to operate independently of others. For example, you can use your laptop computer connected to a cable modem at home to access your favorite website, or view the same website on your laptop using wireless at the library. The function of the web browser is not affected by the change in the physical location nor the method of connectivity.<br>功能的分离使堆栈中的每一层都可以独立运行。例如，您可以在家里使用连接到电缆调制解调器的便携式计算机访问您喜欢的网站，或在图书馆使用无线方式在便携式计算机上查看同一网站。Web浏览器的功能不受物理位置的更改或连接方法的影响。</p><pre><code>网上的精选摘要TCP/IP（Transmission Control Protocol/Internet Protocol，传输控制协议/网际协议）是指能够在多个不同网络间实现信息传输的协议簇。</code></pre><h3 id="3-2-Reading-Using-a-Layered-Model"><a href="#3-2-Reading-Using-a-Layered-Model" class="headerlink" title="3.2 Reading: Using a Layered Model"></a>3.2 Reading: Using a Layered Model</h3><pre><code>　　tcp/ip是事实标准，分4层。osi模型是国际标准，分7层。讲课的时候，一般把他们综合起来讲，就说是5层。他把网络接口层分开为数据链路层和物理层了。</code></pre><p>分层模型帮助我们可视化各种协议如何协同工作以支持网络通信。分层模型描述了在每一层中发生的协议的操作，以及与它上面和下面的层的交互。分层模型有很多好处:</p><ul><li>协助协议设计，因为在特定层上运行的协议定义了它们所作用的信息，并定义了上下层的接口</li><li>促进竞争，因为来自不同供应商的产品可以一起工作</li><li>允许技术更改在一个层次发生，而不影响其他层次</li><li>提供描述网络功能和功能的通用语言</li></ul><p>第一个网络通信的分层模型创建于20世纪70年代初，被称为Internet模型。它定义了通信成功所必须具备的四类功能。用于Internet通信的一套TCP/IP协议遵循这个模型的结构，如图所示。因此，Internet模型通常称为TCP/IP模型。</p><p><img src="http://static.zybuluo.com/Adward-Wang/j2v62n5f0zrlcwqxmtmq7jej/TCP_IP_Model.jpg" alt="TCP_IP_Model.jpg-43.6kB"></p><h3 id="3-3-Video-Protocols-Stacking-Them-Up"><a href="#3-3-Video-Protocols-Stacking-Them-Up" class="headerlink" title="3.3 Video: Protocols-Stacking Them Up"></a>3.3 Video: Protocols-Stacking Them Up</h3><p><img src="http://static.zybuluo.com/Adward-Wang/x57nw9u8p1uaj9964jg5tpn8/TCP_IP_Model2.jpg" alt="TCP_IP_Model2.jpg-57.9kB"></p><pre><code>**  Q：（每个层次不只有这么多协议，这里只是个范例？）**</code></pre><ul><li>1、The Ethernet protocol is used for NIC card, network interface card to network interface card communications in the same network.  </li><li>2、IP协议（4或6） makes sure that the message gets from the original source to the final destination, whether or not that message is within the same network or has to go across multiple networks</li><li>3、 TCP makes sure that the information, the message gets there reliably</li><li>4、 This case HTTP. HTTP governs the exchange or transfer of HTML</li></ul><h3 id="3-4-Reading-Different-Types-of-Network-Models"><a href="#3-4-Reading-Different-Types-of-Network-Models" class="headerlink" title="3.4 Reading: Different Types of Network Models"></a>3.4 Reading: Different Types of Network Models</h3><p>两种基本类型的模型： 协议模型 &amp; 参考模型</p><ul><li>1、协议模型 —— 该模型与特定协议套件结构非常匹配。协议套件包括一组相关协议，这些协议通常提供与数据网络通信所需的所有功能。<strong>TCP/IP模型</strong>是一个协议模型，因为它描述了<strong>TCP/IP套件</strong>中每一层协议上发生的功能。</li><li>2、参考模型 —— 这种类型的模型描述了必须在特定层完成的功能，但没有确切说明应如何完成功能。参考模型并不打算提供足够的细节来精确定义每个协议在每个层上的工作方式。参考模型的主要目的是帮助更清晰地理解网络通信所需的功能和过程。</li></ul><p>最广为人知的互联网络参考模型是由国际标准化组织（ISO）的开放系统互连项目创建的。它用于数据网络设计，操作规范和故障排除。该模型通常称为OSI模型。<br>下面是关于OSI模型的不同层的更多信息。</p><pre><code>Application 应用层The application layer provides the means for end-to-end connectivity between individuals in the human network using data networks.Presentation 表示层The presentation layer provides for common representation of the data transferred between application layer services.Session 会话层The session layer provides services to the presentation layer to organize its dialogue and to manage data exchange.Transport 传输层The transport layer defines services to segment, transfer, and reassemble the data for individual communications between the end devices.Network 网络层The network layer provides services to exchange the individual pieces of data over the network between identified end devices.Data Link 数据链路层The data link layer protocol describes methods for exchanging data frames between devices over a common medium.Physical 物理层The physical layer protocol describes the mechanical, electrical, functional, and procedural means to activate, maintain, and de-activate physical connections for bit transmission to and from a network device.</code></pre><hr><h2 id="4-Working-with-the-OSI-Model"><a href="#4-Working-with-the-OSI-Model" class="headerlink" title="4. Working with the OSI Model"></a>4. Working with the OSI Model</h2><h3 id="4-1-Reading-Dividing-the-Tasks"><a href="#4-1-Reading-Dividing-the-Tasks" class="headerlink" title="4.1 Reading: Dividing the Tasks"></a>4.1 Reading: Dividing the Tasks</h3><p>OSI 模型将网络通信分解为多个过程。每个过程只是较大任务的一小部分。<br>类比汽车制造厂，装配一辆汽车的复杂任务可以分解为多个子任务让其变得更加简单。</p><p>类似的，OSI模型帮助我们在进行故障排除以识别和解决网络问题时关注于一个层。网络团队经常通过OSI模型层的数量来引用网络中发生的不同功能，OSI模型层指定了该功能。例如，为跨媒体传输而对数据位进行编码的过程发生在第1层，即物理层。数据的格式可以通过笔记本电脑或手机中的网络连接进行解释，该格式描述在第2层，即数据链路层。</p><p><img src="http://static.zybuluo.com/Adward-Wang/rk9pkd3xgcjs8lmr4jrqhea7/OSI7.jpg" alt="OSI7.jpg-64.7kB"></p><h3 id="4-2-Reading-Comparing-the-OSI-and-TCP-Models"><a href="#4-2-Reading-Comparing-the-OSI-and-TCP-Models" class="headerlink" title="4.2 Reading: Comparing the OSI and TCP Models"></a>4.2 Reading: Comparing the OSI and TCP Models</h3><pre><code>The OSI model was created in the early 1980’s as a conceptual reference model with seven layers that specify characteristics and standards for the end-to-end communication process. Its goal was the interoperability of different communications systems.</code></pre><p><code>OSI模型</code>是在1980年代初期创建的，作为概念性参考模型，具有七个层，用于指定端到端通信过程的特征和标准。其目标是实现不同通信系统的互操作性。</p><pre><code>The TCP/IP model is another model with only four layers that relate to the OSI layers. This reference model also provides characteristics and standards for end-to-end communications. The TCP/IP model is more of an implementation model and is currently more widely referenced than the OSI model.</code></pre><p><code>TCP / IP模型</code>是另一个只有四个与OSI层相关的层的模型。该参考模型还提供了端到端通信的特性和标准。 TCP / IP模型更多地是一种 <strong>实现模型</strong>，并且与OSI模型相比，目前被更广泛地引用。</p><pre><code>Because TCP/IP is the protocol suite in use for Internet communications, why do we need to learn the OSI model as well?</code></pre><p>因为<code>TCP/IP</code>是用于互联网通信的<strong>协议套件</strong>，为什么我们还需要学习OSI模型?</p><pre><code>The TCP/IP model is a method of visualizing the interactions of the various protocols that make up the TCP/IP protocol suite. It does not describe general functions that are necessary for all networking communications. It describes the networking functions specific to those protocols in use in the TCP/IP protocol suite. For example: At the network access layer, the TCP/IP protocol suite does not specify which protocols to use when transmitting over a physical medium, nor the method of encoding the signals for transmission. OSI Layers 1 and 2 discuss the necessary procedures to access the media and the physical means to send data over a network.</code></pre><p><code>TCP/IP模型</code>是一种可视化构成<code>TCP/IP协议套件</code>的各种协议的交互的方法。它没有描述所有网络通信所必需的一般功能。它描述了特定于<code>TCP/IP协议套件</code>中使用的那些协议的网络功能。例如:在网络访问层，<code>TCP/IP协议套件</code>没有指定在物理介质上传输时使用哪个协议，也没有指定传输信号的编码方法。OSI第1层和第2层讨论访问媒体的必要程序和通过网络发送数据的物理方法。</p><p>The protocols that make up the TCP/IP protocol suite can be described in terms of the OSI reference model. The functions that occur at the Internet layer in the TCP/IP model are contained in the network layer of the OSI Model, as shown in the figure. The transport layer functionality is the same between both models. However, the network access layer and the application layer of the TCP/IP model are further divided in the OSI model to describe discrete functions that must occur at these layers.<br>可以根据<code>OSI参考模型</code>来描述构成<code>TCP / IP协议套件</code>的协议。如图所示，在<code>TCP / IP模型</code>的Internet层发生的功能包含在<code>OSI模型</code>的网络层中。两种模型之间的传输层功能相同。但是，在OSI模型中进一步划分了<code>TCP / IP模型</code>的网络访问层和应用程序层，以描述必须在这些层上发生的离散功能。</p><p><img src="http://static.zybuluo.com/Adward-Wang/x7anv930y81clfijwf4fs8ye/OSI_TCP_IP.jpg" alt="OSI_TCP_IP.jpg-56.6kB"></p><hr><h2 id="5-Protocols-for-Wired-Networks"><a href="#5-Protocols-for-Wired-Networks" class="headerlink" title="5. Protocols for Wired Networks"></a>5. Protocols for Wired Networks</h2><h3 id="5-1-Reading-Why-Ethernet"><a href="#5-1-Reading-Why-Ethernet" class="headerlink" title="5.1 Reading: Why Ethernet"></a>5.1 Reading: Why Ethernet</h3><p>在网络的早期，每个供应商都使用他们自己的专有方法来互连网络设备和网络协议。如果从不同的供应商购买设备，并不能保证这些设备可以协同工作。来自一个供应商的设备可能无法与来自另一个供应商的设备通信。</p><p>随着网络的日益普及，各种标准应运而生，这些标准定义了不同供应商的网络设备操作规则。标准在很多方面都有利于网络:</p><ul><li>方便设计</li><li>简化产品开发</li><li>促进竞争</li><li>提供一致的互连</li><li>促进培训</li><li>为客户提供更多供应商选择</li></ul><p>目前尚无官方的局域网标准协议，但随着时间的流逝，以太网技术已经变得比其他技术更为普遍。 <strong>以太网协议</strong>定义了如何格式化数据以及如何通过<strong>有线网络</strong>传输数据。以太网标准指定了在OSI模型的第1层和第2层运行的协议。如图所示，它已经成为事实上的标准，这意味着以太网是几乎所有<strong>有线局域网</strong>使用的技术。</p><p><img src="http://static.zybuluo.com/Adward-Wang/darf7635b04vaze25vod75q7/Why_Ethernet.jpg" alt="Why_Ethernet.jpg-40.6kB"></p><h3 id="5-2-Reading-Ethernet-is-Constantly-Evolving"><a href="#5-2-Reading-Ethernet-is-Constantly-Evolving" class="headerlink" title="5.2 Reading: Ethernet is Constantly Evolving"></a>5.2 Reading: Ethernet is Constantly Evolving</h3><pre><code>The Institute of Electrical and Electronic Engineers, or IEEE (pronounced eye-triple-e), maintains the networking standards, including Ethernet and wireless standards. IEEE committees are responsible for approving and maintaining the standards for connections, media requirements and communications protocols. Each technology standard is assigned a number that refers to the committee that is responsible for approving and maintaining the standard. The committee responsible for the Ethernet standards is 802.3.</code></pre><p>电气和电子工程师协会（IEEE，发音为eye-triple-e）维护网络标准，包括以太网和无线标准。IEEE委员会负责批准和维护连接，媒体要求和通信协议的标准。每个技术标准都分配有一个编号，该编号表示负责批准和维护该标准的委员会。负责以太网标准的委员会是<code>802.3</code>。</p><pre><code>Since the creation of Ethernet in 1973, standards have evolved for specifying faster and more flexible versions of the technology. This ability for Ethernet to improve over time is one of the main reasons that it has become so popular. Each version of Ethernet has an associated standard. For example, 802.3 100BASE-T represents the 100 Megabit Ethernet using twisted-pair cable standards. The standard notation translates as:• 100 is the speed in Mb/s• BASE stands for baseband transmission• T stands for the type of cable, in this case, twisted-pair.</code></pre><p>1973年以太网诞生, 标准不断演变，更快速度，更灵活的版本推出。以太网的这种随时间推移不断改进的能力是它变得如此受欢迎的主要原因之一。每个版本的以太网都有一个相关的标准。例如，<code>802.3 100BASE-T</code>表示使用双绞线标准的100兆以太网。标准符号翻译为:</p><ul><li>100Mb/s 带宽</li><li>BASE代表基带传输</li><li>T代表电缆的类型，在这种情况下为双绞线。</li></ul><h3 id="5-3-Reading-Ethernet-Addressing"><a href="#5-3-Reading-Ethernet-Addressing" class="headerlink" title="5.3 Reading: Ethernet Addressing"></a>5.3 Reading: Ethernet Addressing</h3><p>所有通信都需要一种方法来标识源和目标。而人际交流中的来源和目的地由姓名表示。<br>（类比）当别人叫你的名字时，你会听到并作出回应，而听到消息的其他人则会忽略该消息，因为并不是叫他们。</p><p>在以太网中，有一种类似的方法来标识源主机和目标主机。为连接到以太网的每个主机分配一个物理地址，该地址用于标识网络上的主机。</p><p>观看下面的动画，了解如何在主机之间发送以太网帧。</p><p><img src="http://static.zybuluo.com/Adward-Wang/4xhvsaf03b5656u5lvfiw2jn/Ethernet_Addressing.gif" alt="Ethernet_Addressing.gif-381.1kB"></p><h3 id="5-4-Video-Ethernet-Addressing"><a href="#5-4-Video-Ethernet-Addressing" class="headerlink" title="5.4 Video: Ethernet Addressing"></a>5.4 Video: Ethernet Addressing</h3><h3 id="5-5-Lab-Determine-the-MAC-Address-of-a-Host"><a href="#5-5-Lab-Determine-the-MAC-Address-of-a-Host" class="headerlink" title="5.5 Lab-Determine the MAC Address of a Host"></a>5.5 Lab-Determine the MAC Address of a Host</h3><p>六个字节组成<br>前三个为 <code>组织唯一标识符</code> OUI  (Organizationally unique identifier)； 我的是 94-57-A5 ，惠普生产<br>后三个为 <code>接口唯一标识符</code></p>]]></content>
      
      
      <categories>
          
          <category> 计算机网络 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 网络基础 </tag>
            
            <tag> Cisco </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>杂记 0415</title>
      <link href="/2020/04/15/title-za-ji-0415/"/>
      <url>/2020/04/15/title-za-ji-0415/</url>
      
        <content type="html"><![CDATA[<p>貌似很久没更博客了，这些天一直忙着毕业论文的事，虽然现在还没弄好，但我觉得快了（又是我觉得，手动狗头）</p><hr><h3 id="01-读书有感"><a href="#01-读书有感" class="headerlink" title="01 读书有感"></a>01 读书有感</h3><p>昨天在看一本书时，上面写到了这么一段话：</p><blockquote><p>对于计算机开发来说，懂得底层原理，这是技术能力；懂得算法参数，这是方法论。这两者都不是工程能力。而工程能力是把一堆杂乱的数据整理成结构化数据，并运用算法对数据进行加工，得到某些结论。</p></blockquote><p>我被这句话触动了许久，因为我觉得一直以来自己的学习陷入了怪区，零散化没有体系，又或是学习没有目的性，始终抱着学生思维：<code>即做一件事我要从他的相关基础开始学习，等学好了我再去做</code>，其实知识永远学不完的，理论知识只有在实践中才能出真知。 做一件个项目，做一件事，你得清楚地知道你需要哪些知识，哪些知识是重要的，哪些是次要的，做成一个项目你需要做哪些相关的准备工作下一步怎么做等等，这些都需要去考虑，千万不能想着学个透彻，当然，不是说学深入不好，而是有时候面临时间、人力问题，等你准备好了黄花菜都凉了，我觉得那应该叫自我感动，其实是很低效的准备。</p><p><strong>做一件事或者项目应该动手动脑子想想思路</strong>，没有思路可以去网上借鉴别人，再不行找前辈大佬去文，我觉得信息时代带给我最大的便利就是 很多问题我都可以在网上找到答案或者找到人去寻求帮助。</p><p>再之就是，我想了许久，本科学习究竟给我带来了什么？我觉得就是素养、理论基础以及对计算机的热爱，工程能力学校并没有教或者说我学的不够好。所以我现在还是需要去不断提高自己的实践能力，光谈理论都是花架子。企业需要的是可以解决问题有工程能力的人才，而不是会考试或者说谈理论的人。对，我应该早点想清楚这一点的，可是身边也没有人指点我，或许人在某个阶段总会迷茫困惑吧。</p><hr><h3 id="02-观影有感"><a href="#02-观影有感" class="headerlink" title="02 观影有感"></a>02 观影有感</h3><p>前几天，看了一部电影解说，里面有一句话让我印象很深，我就把记了下来。</p><blockquote><p>就好像你是一只拼尽全力从粪坑里爬出来的蛆，你努力蜕壳长上了一双翅膀，可就算别人把你当作鸟类，可你自己却清楚地知道你变成的也只不过是一只苍蝇。当你鼓足勇气想要飞向你爱慕的花朵时，当看到蝴蝶飞来，你总会及时停下望而却步，毕竟在别人眼中，鲜花和蝴蝶才是该有的般配。</p></blockquote><p>这句话很粗，但是我被深深触动了，我来自农村，我也能脑补出那种场景，一瞬间我感觉我就是解说里所说的那只蛆，我在努力地爬出那个坑。下一秒我又努力摇头让自己拒绝这种想法。我或许是苍蝇又或许不是，但是这重要吗？</p><p>我为什么要在意别人的看法呢，我自己有我自己的坚持，有我的尊严去守护。我会去努力爬出这个坑。或许鲜花和蝴蝶才算般配，但是换个角度来说，鲜花会选择蝴蝶是出于选择更好的，那它又真的能够配得上那只不起眼的苍蝇呢？</p><p>这几个月我一直熬夜，或许夜深比较安静，世界仿佛都属于我，又或许深夜我又可以停下来胡思乱想了。傅妈说，贫穷是有后遗症的。我想或许吧，除了有些自卑至少我现在没有体会到什么是所谓的后遗症，我也相信学的东西多了，见识广了，一切都会好，一切的烦恼源自自己的无知</p><hr><h3 id="03-生活有感（胡说八道）"><a href="#03-生活有感（胡说八道）" class="headerlink" title="03 生活有感（胡说八道）"></a>03 生活有感（胡说八道）</h3><p>不知道为什么，自己的消费观和从前有了很大变化，买一个东西更考虑它能带来的用户体验以及能够提高生产力吗。<br>开网盘会员可以提高生产力，节约时间，存放资料等用户，也算作一种投资。<br>网易云音乐可以让我听到我想听的歌，改善我的心情，这些只需要一些小小的金钱投入就能带来回报，为什么不呢？ 为什么我以前就没有这样想呢？</p><p>可能以前消费观太局限性了，现在更考虑投资和产出的比例，可能自己更物质了吧，我也不知道自己究竟是变好或者变坏了，只是觉得这样的观念应该比以前的观念要好，仅此而已。</p><hr><p>算了不早了，睡觉， 胡思乱想 作于 4月15日 凌晨2：31</p>]]></content>
      
      
      <categories>
          
          <category> 浮生日记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 闲人闲语 </tag>
            
            <tag> 杂记 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>数据库粗略回顾（三）</title>
      <link href="/2020/03/03/title-shu-ju-ku-cu-lue-hui-gu-san/"/>
      <url>/2020/03/03/title-shu-ju-ku-cu-lue-hui-gu-san/</url>
      
        <content type="html"><![CDATA[<h2 id="五、修改数据"><a href="#五、修改数据" class="headerlink" title="五、修改数据"></a>五、修改数据</h2><p>关系数据库的基本操作就是增删改查，即CRUD：Create、Retrieve、Update、Delete。其中，对于查询，我们已经详细讲述了SELECT语句的详细用法。</p><p>而对于增、删、改，对应的SQL语句分别是：</p><ul><li>INSERT：插入新记录；</li><li>UPDATE：更新已有记录；</li><li>DELETE：删除已有记录。</li></ul><h3 id="5-1-Insert"><a href="#5-1-Insert" class="headerlink" title="5.1 Insert"></a>5.1 Insert</h3><p>当我们需要向数据库表中插入一条新记录时，就必须使用<code>INSERT</code>语句。</p><p><strong>Insert 基本语法：</strong></p><pre><code>INSERT INTO &lt;表名&gt; (字段1， 字段2， ...)    VALUES (值1， 值2， ...);</code></pre><p><strong>例如</strong>，我们向students表插入一条新记录，先列举出需要插入的字段名称，然后在VALUES子句中依次写出对应字段的值：</p><pre><code>-- 添加一条新记录INSERT INTO students (class_id, name, gender, score) VALUES (2, &#39;大牛&#39;, &#39;M&#39;, 80);-- 并观察结果SELECT * FROM students;//RESULTS11    2    大牛    M    80</code></pre><p>我们并没有列出id字段, 而id字段是一个自增主键，它的值可以由数据库自己推算出来， 此外，如果一个字段有默认值，那么在INSERT语句中也可以不出现。</p><p><strong>注意</strong>，字段顺序不必和数据库表的字段顺序一致，但值的顺序必须和字段顺序一致。<br>也就是说，可以写INSERT INTO students (score, gender, name, class_id) …，但是对应的VALUES就得变成(80, ‘M’, ‘大牛’, 2)。</p><p>还<strong>可以一次性添加多条记录</strong>，只需要在VALUES子句中指定多个记录值，每个记录是由<strong>(…)</strong>包含的一组值：</p><p>INSERT INTO<br>    students<br>    (class_id, name, gender, score)<br>VALUES<br>    (1, ‘大宝’, ‘M’, 87),<br>    (2, ‘二宝’, ‘M’, 81);</p><p>SELECT *FROM students;</p><h4 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h4><p>使用INSERT，我们就可以一次向一个表中插入一条或多条记录。</p><hr><h3 id="5-2-UPDATE"><a href="#5-2-UPDATE" class="headerlink" title="5.2 UPDATE"></a>5.2 UPDATE</h3><p><strong>UPDATE语句的基本语法是：</strong></p><pre><code>UPDATE &lt;表名&gt; SET 字段1 = 值1, 字段2 =值2, ... WHERE ...;eg:更新id=1的记录UPDATE students    SET name = &#39;大牛&#39;, score = 66    WHERE id =1;-- 查询并观察结果:SELECT * FROM students where id = 1;</code></pre><p>注意到UPDATE语句的WHERE条件和SELECT语句的WHERE条件其实是一样的，因此完<strong>全可以一次更新多条记录</strong>： </p><pre><code>-- 更新id=5,6,7的记录UPDATE students     SET name = &#39;小牛&#39;, score = 77    WHERE  id &gt;=5   AND id &lt;=7;-- 查询并观察结果:SELECT * FROM students;</code></pre><p>在UPDATE语句中，<strong>更新字段时可以使用表达式</strong>。例如，把所有80分以下的同学的成绩加10分：    </p><pre><code>UPDATE  students     SET  score = score +10    WHERE   score &lt; 80;</code></pre><p>SET score=score+10就是给当前行的score字段的值加上了10。</p><p>如果WHERE条件没有匹配到任何记录，UPDATE语句不会报错，也不会有任何记录被更新。例如：</p><pre><code>UPDATE students SET score=100 WHERE id=999;</code></pre><p>最后，要特别小心的是，UPDATE语句可以没有WHERE条件，例如：</p><pre><code>UPDATE students SET score=60;</code></pre><p>这时，整个表的所有记录都会被更新。所以，<strong>在执行UPDATE语句时要非常小心，最好先用SELECT语句来测试WHERE条件是否筛选出了期望的记录集，然后再用UPDATE更新。</strong>    </p><h4 id="MySQL"><a href="#MySQL" class="headerlink" title="MySQL"></a>MySQL</h4><p>在使用MySQL这类真正的关系数据库时，UPDATE语句会返回更新的行数以及WHERE条件匹配的行数。</p><p>例如，更新id=1的记录时：</p><pre><code>mysql&gt; UPDATE students SET name=&#39;大宝&#39; WHERE id=1;Query OK, 1 row affected (0.00 sec)Rows matched: 1  Changed: 1  Warnings: 0</code></pre><p>MySQL会返回1，可以从打印的结果Rows matched: 1 Changed: 1看到。</p><p>当更新id=999的记录时：</p><pre><code>mysql&gt; UPDATE students SET name=&#39;大宝&#39; WHERE id=999;Query OK, 0 rows affected (0.00 sec)Rows matched: 0  Changed: 0  Warnings: 0</code></pre><p>MySQL会返回0，可以从打印的结果Rows matched: 0 Changed: 0看到。</p><h4 id="小结-1"><a href="#小结-1" class="headerlink" title="小结"></a>小结</h4><p>使用UPDATE，我们就可以一次更新表中的一条或多条记录。</p><h3 id="5-3-DELETE"><a href="#5-3-DELETE" class="headerlink" title="5.3 DELETE"></a>5.3 DELETE</h3><p>DELETE语句的基本语法是：</p><pre><code>DELETE FROM &lt;表名&gt; WHERE ...;</code></pre><p>例如，我们想删除students表中id=1的记录</p><pre><code>DELETE FROM students WHERE id=1;-- 查询并观察结果:SELECT * FROM students;</code></pre><p>注意到DELETE语句的WHERE条件也是用来筛选需要删除的行，因此和UPDATE类似，<strong>DELETE语句也可以一次删除多条记录</strong>：</p><pre><code>-- 删除id=5,6,7的记录DELETE FROM students WHERE id&gt;= 5 AND id &lt;= 7;</code></pre><p>如果WHERE条件没有匹配到任何记录，DELETE语句不会报错，也不会有任何记录被删除。(同UPDATE)</p><p>最后，要特别小心的是，和UPDATE类似，不带WHERE条件的DELETE语句会删除整个表的数据：</p><pre><code>DELETE FROM students;</code></pre><p>这时，整个表的所有记录都会被删除。所以，<strong>在执行DELETE语句时也要非常小心，最好先用SELECT语句来测试WHERE条件是否筛选出了期望的记录集，然后再用DELETE删除。</strong></p><h4 id="MySQL-1"><a href="#MySQL-1" class="headerlink" title="MySQL"></a>MySQL</h4><p>在使用MySQL这类真正的关系数据库时，DELETE语句也会返回删除的行数以及WHERE条件匹配的行数。</p><p>例如，分别执行删除id=1和id=999的记录：</p><pre><code>mysql&gt; DELETE FROM students WHERE id=1;Query OK, 1 row affected (0.01 sec)mysql&gt; DELETE FROM students WHERE id=999;Query OK, 0 rows affected (0.01 sec)</code></pre><h4 id="小结-2"><a href="#小结-2" class="headerlink" title="小结"></a>小结</h4><p>使用DELETE，我们就可以一次删除表中的一条或多条记录。</p><hr><h2 id="六、MySQL"><a href="#六、MySQL" class="headerlink" title="六、MySQL"></a>六、MySQL</h2><p>安装完MySQL后，除了MySQL Server，即真正的MySQL服务器外，还附赠一个MySQL Client程序。MySQL Client是一个命令行客户端，可以通过MySQL Client登录MySQL，然后，输入SQL语句并执行。</p><p>打开命令提示符，输入命令<code>mysql -u root -p</code>，<br>提示输入口令。填入MySQL的root口令，如果正确，就连上了MySQL Server，同时提示符变为mysql&gt;</p><p>输入<code>exit</code>断开与MySQL Server的连接并返回到命令提示符。</p><p> <strong>注意</strong>：MySQL Client的可执行程序是mysql，MySQL Server的可执行程序是mysqld。</p><p>MySQL Client和MySQL Server的关系如下： </p><pre><code>┌──────────────┐  SQL   ┌──────────────┐│ MySQL Client │───────&gt;│ MySQL Server │└──────────────┘  TCP   └──────────────┘</code></pre><p>在MySQL Client中输入的SQL语句通过TCP连接发送到MySQL Server。默认端口号是3306，即如果发送到本机MySQL Server，地址就是 <strong>127.0.0.1:3306</strong>。</p><p>也可以只安装MySQL Client，然后连接到远程MySQL Server。假设远程MySQL Server的IP地址是10.0.1.99，那么就使用-h指定IP或域名：</p><pre><code>mysql -h 10.0.1.99 -u root -p</code></pre><p><strong>小结</strong></p><p>命令行程序mysql实际上是MySQL客户端，真正的MySQL服务器程序是mysqld，在后台运行。</p><hr><h3 id="6-1-管理MySQL"><a href="#6-1-管理MySQL" class="headerlink" title="6.1 管理MySQL"></a>6.1 管理MySQL</h3><p>要管理MySQL，可以使用可视化图形界面MySQL Workbench。</p><p>MySQL Workbench可以用可视化的方式查询、创建和修改数据库表，但是，归根到底，MySQL Workbench是一个图形客户端，它对MySQL的操作仍然是发送SQL语句并执行。因此，本质上，MySQL Workbench和MySQL Client命令行都是客户端，和MySQL交互，唯一的接口就是SQL。</p><p>因此，MySQL提供了大量的SQL语句用于管理。虽然可以使用MySQL Workbench图形界面来直接管理MySQL，<strong>但是，很多时候，通过SSH远程连接时，只能使用SQL命令，所以，了解并掌握常用的SQL管理操作是必须的。</strong></p><h4 id="数据库"><a href="#数据库" class="headerlink" title="数据库"></a>数据库</h4><p>在一个运行MySQL的服务器上，实际上可以创建多个数据库（Database）。要列出所有数据库，使用命令：</p><pre><code>mysql&gt; SHOW DATABASES;+--------------------+| Database           |+--------------------+| information_schema || mysql              || performance_schema || shici              || sys                || test               || school             |+--------------------+</code></pre><p>其中，information_schema、mysql、performance_schema和sys是系统库，不要去改动它们。其他的是用户创建的数据库。</p><p>要<strong>创建一个新数据库</strong>，使用命令：</p><pre><code>mysql&gt; CREATE DATABASE test;Query OK, 1 row affected (0.01 sec)(注意结束的分号；)</code></pre><p>要<strong>删除一个数据库</strong>，使用命令：</p><pre><code>mysql&gt; DROP DATABASE test;Query OK, 0 rows affected (0.01 sec) //not DELETE</code></pre><p><strong>注意</strong>：删除一个数据库将导致该数据库的所有表全部被删除。</p><p>对一个数据库进行操作时，要首先将其切换为当前数据库：</p><pre><code>mysql&gt; USE test;Database changed</code></pre><h4 id="表"><a href="#表" class="headerlink" title="表"></a>表</h4><p>列出当前数据库的所有表，使用命令：</p><pre><code>mysql&gt; SHOW TABLES;+---------------------+| Tables_in_test      |+---------------------+| classes             || statistics          || students            || students_of_class1  |+---------------------+</code></pre><p>要查看一个表的结构，使用命令：    </p><pre><code>mysql&gt; DESC students;+----------+--------------+------+-----+---------+----------------+| Field    | Type         | Null | Key | Default | Extra          |+----------+--------------+------+-----+---------+----------------+| id       | bigint(20)   | NO   | PRI | NULL    | auto_increment || class_id | bigint(20)   | NO   |     | NULL    |                || name     | varchar(100) | NO   |     | NULL    |                || gender   | varchar(1)   | NO   |     | NULL    |                || score    | int(11)      | NO   |     | NULL    |                |+----------+--------------+------+-----+---------+----------------+5 rows in set (0.00 sec)</code></pre><p>还可以使用以下命令查看创建表的SQL语句：</p><pre><code>mysql&gt; SHOW CREATE TABLE students;   +----------+-------------------------------------------------------+| students | CREATE TABLE `students` (                             ||          |   `id` bigint(20) NOT NULL AUTO_INCREMENT,            ||          |   `class_id` bigint(20) NOT NULL,                     ||          |   `name` varchar(100) NOT NULL,                       ||          |   `gender` varchar(1) NOT NULL,                       ||          |   `score` int(11) NOT NULL,                           ||          |   PRIMARY KEY (`id`)                                  ||          | ) ENGINE=InnoDB AUTO_INCREMENT=1 DEFAULT CHARSET=utf8 |+----------+-------------------------------------------------------+1 row in set (0.00 sec)</code></pre><p>创建表使用<code>CREATE TABLE</code>语句，而删除表使用<code>DROP TABLE</code>语句：</p><pre><code>mysql&gt; DROP TABLE students;Query OK, 0 rows affected (0.01 sec)</code></pre><p>修改表就比较复杂。如果要给students表<strong>新增一列</strong>birth，使用：</p><pre><code>ALTER TABLE students ADD COLUMN birth VARCHAR(10) NOT NULL;//改变表 students  加一列 birth 数据类型 非空</code></pre><p>要修改birth列，例如把列名改为birthday，类型改为VARCHAR(20)：</p><pre><code>ALTER TABLE students CHANGE COLUMN birth birthday VARCHAR(20) NOT NULL;</code></pre><p>要删除列，使用：</p><pre><code>ALTER TABLE students DROP COLUMN birthday;</code></pre><h4 id="退出MySQL"><a href="#退出MySQL" class="headerlink" title="退出MySQL"></a>退出MySQL</h4><pre><code>mysql&gt; EXITBye</code></pre><p><strong>注意:</strong> <code>EXIT</code>仅仅断开了客户端和服务器的连接，MySQL服务器仍然继续运行。</p><hr><h3 id="6-2-实用SQL语句"><a href="#6-2-实用SQL语句" class="headerlink" title="6.2 实用SQL语句"></a>6.2 实用SQL语句</h3><pre><code>在编写SQL时，灵活运用一些技巧，可以大大简化程序逻辑。</code></pre><h4 id="插入或替换"><a href="#插入或替换" class="headerlink" title="插入或替换"></a>插入或替换</h4><p>如果我们希望插入一条新记录（INSERT），但如果记录已经存在，就先删除原记录，再插入新记录。此时，可以使用<strong>REPLACE语句</strong>，这样就不必先查询，再决定是否先删除再插入：</p><pre><code>REPLACE INTO students (id, class_id, name, gender, score)VALUES (1, 1, &#39;小明&#39;, &#39;F&#39;, 99);</code></pre><p>若id=1的记录不存在，REPLACE语句将插入新记录，否则，当前id=1的记录将被删除，然后再插入新记录。</p><h4 id="插入或更新"><a href="#插入或更新" class="headerlink" title="插入或更新"></a>插入或更新</h4><p>如果我们希望插入一条新记录（INSERT），但如果记录已经存在，就<strong>更新该记录</strong>，此时，可以使用<code>INSERT INTO ... ON DUPLICATE KEY UPDATE ...</code>语句：</p><pre><code>INSERT INTO     students    (id, class_id, name, gender, score)    VALUES    (1, 1, &#39;小明&#39;, &#39;F&#39;, 99)    ON DUPLICATE KEY VALUE     name = &#39;小明&#39;, gender =&#39;F&#39;, score = 99;</code></pre><p><em>若id=1的记录不存在，INSERT语句将插入新记录，否则，当前id=1的记录将被更新，更新的字段由UPDATE指定。</em></p><h4 id="插入或忽略"><a href="#插入或忽略" class="headerlink" title="插入或忽略"></a>插入或忽略</h4><p>如果我们希望插入一条新记录（INSERT），但如果记录已经存在，就啥事也不干直接忽略，此时，可以使用<code>INSERT IGNORE INTO ...</code>语句：</p><pre><code>  INSERT IGNORE INTO students  (id, class_id, name, gender, score)    VALUES    （1, 1, &#39;小明&#39;, &#39;F&#39;, 99);</code></pre><p><em>若id=1的记录不存在，INSERT语句将插入新记录，否则，不执行任何操作。</em></p><h4 id="快照"><a href="#快照" class="headerlink" title="快照"></a>快照</h4><p>如果想要对一个表进行快照，即复制一份当前表的数据到一个新表，可以<strong>结合CREATE TABLE和SELECT：</strong></p><pre><code>-- 对class_id=1的记录进行快照，并存储为新表students_of_class1:CREATE TABLE students_of_class1     SELECT * FROM students     WHERE        class_id = 1;</code></pre><p>新创建的表结构和SELECT使用的表结构完全一致。           </p><h4 id="写入查询结果集"><a href="#写入查询结果集" class="headerlink" title="写入查询结果集"></a>写入查询结果集</h4><p>如果查询结果集需要写入到表中，可以<strong>结合INSERT和SELECT</strong>，将SELECT语句的结果集直接插入到指定表中。</p><p>eg:创建一个统计成绩的表statistics，记录各班的平均成绩：</p><pre><code>CREATE TABLE statistics(    id BIGINT NOT NULL AUTO_INCREMENT,    class_id BIGINT NOT NULL,    average DOUBLE NOT NULL,    PRIMARY KEY(id)    );    //用圆括号 字段名 数据类型 非空    加上主键</code></pre><p>然后，我们就可以用一条语句写入各班的平均成绩：</p><pre><code>INSERT INTO statistics     (class_id, average)    SELECT  class_id, AVG(score)  FROM students GROUP BY class_id;</code></pre><p><strong>确保INSERT语句的列和SELECT语句的列能一一对应</strong>，就可以在statistics表中直接保存查询的结果：</p><pre><code>&gt; SELECT * FROM statistics;+----+----------+--------------+| id | class_id | average      |+----+----------+--------------+|  1 |        1 |         86.5 ||  2 |        2 | 73.666666666 ||  3 |        3 | 88.333333333 |+----+----------+--------------+3 rows in set (0.00 sec)</code></pre><h4 id="强制使用指定索引"><a href="#强制使用指定索引" class="headerlink" title="强制使用指定索引"></a>强制使用指定索引</h4><p>在查询的时候，数据库系统会自动分析查询语句，并选择一个最合适的索引。但是很多时候，数据库系统的查询优化器并不一定总是能使用最优索引。如果我们知道如何选择索引，可以使用<code>FORCE INDEX</code><strong>强制查询使用指定的索引</strong>。<br>例如：</p><pre><code>&gt;SELECT * FROM students FORCE INDEX     (idx_class_id) WHERE   class_id =1 ORDER   BY id DESC;</code></pre><p><strong>指定索引的前提是索引idx_class_id必须存在。</strong></p><hr>]]></content>
      
      
      <categories>
          
          <category> 数据库 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> MySQL </tag>
            
            <tag> SQL </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>数据库粗略回顾（一）</title>
      <link href="/2020/03/01/title-shu-ju-ku-cu-lue-hui-gu-yi/"/>
      <url>/2020/03/01/title-shu-ju-ku-cu-lue-hui-gu-yi/</url>
      
        <content type="html"><![CDATA[<pre><code>本科阶段已经学习过一个学期的数据库，但是很多理论性的知识因为很久不用所以忘得差不多了，现特抽出几天时间简单回顾下。</code></pre><h2 id="一、关系数据库概述"><a href="#一、关系数据库概述" class="headerlink" title="一、关系数据库概述"></a>一、关系数据库概述</h2><p>数据库作为一种专门管理数据的软件。应用程序不需要自己管理数据，而是通过数据库软件提供的<strong>接口</strong>来读写数据。至于数据本身如何存储到文件，那是数据库软件的事情，应用程序自己并不关心：</p><pre><code>┌──────────────┐│ application  │└──────────────┘       ▲│       ││   read││write       ││       │▼┌──────────────┐│   database   │└──────────────┘</code></pre><p>这样一来，编写应用程序的时候，数据读写的功能就被大大地简化了。</p><h3 id="数据模型"><a href="#数据模型" class="headerlink" title="数据模型"></a>数据模型</h3><p>三种</p><ul><li>层次模型</li><li>网状模型</li><li><strong>关系模型</strong></li></ul><p><strong>层次模型</strong>就是以“上下级”的层次关系来组织数据的一种方式，层次模型的数据结构看起来就像一颗树：</p><pre><code>            ┌─────┐            │     │            └─────┘               │       ┌───────┴───────┐       │               │    ┌─────┐         ┌─────┐    │     │         │     │    └─────┘         └─────┘       │               │   ┌───┴───┐       ┌───┴───┐   │       │       │       │┌─────┐ ┌─────┐ ┌─────┐ ┌─────┐│     │ │     │ │     │ │     │└─────┘ └─────┘ └─────┘ └─────┘</code></pre><p><strong>网状模型</strong>把每个数据节点和其他很多节点都连接起来，它的数据结构看起来就像很多城市之间的路网：</p><pre><code>     ┌─────┐      ┌─────┐   ┌─│     │──────│     │──┐   │ └─────┘      └─────┘  │   │    │            │     │   │    └──────┬─────┘     │   │           │           │┌─────┐     ┌─────┐     ┌─────┐│     │─────│     │─────│     │└─────┘     └─────┘     └─────┘   │           │           │   │     ┌─────┴─────┐     │   │     │           │     │   │  ┌─────┐     ┌─────┐  │   └──│     │─────│     │──┘      └─────┘     └─────┘</code></pre><p><strong>关系模型</strong>把数据看作是一个二维表格，任何数据都可以通过行号+列号来唯一确定，<strong><strong>它的数据模型看起来就是一个Excel表</strong></strong>：</p><pre><code>┌─────┬─────┬─────┬─────┬─────┐│     │     │     │     │     │├─────┼─────┼─────┼─────┼─────┤│     │     │     │     │     │├─────┼─────┼─────┼─────┼─────┤│     │     │     │     │     │├─────┼─────┼─────┼─────┼─────┤│     │     │     │     │     │└─────┴─────┴─────┴─────┴─────┘</code></pre><h3 id="数据类型"><a href="#数据类型" class="headerlink" title="数据类型"></a>数据类型</h3><p>对于一个关系表，除了定义每一列的名称外，还需要定义每一列的数据类型。关系数据库支持的标准数据类型包括数值、字符串、时间等：</p><pre><code>名称                  类型            说明INT                    整型            4字节整数类型，范围约+/-21亿BIGINT             长整型           8字节整数类型，范围约+/-922亿亿REAL                浮点型           4字节浮点数，范围约+/-1038DOUBLE                浮点型           8字节浮点数，范围约+/-10308DECIMAL(M,N)        高精度小数    由用户指定精度的小数，例如，DECIMAL(20,10)表示一共20位，其中小数10位，通常用于财务计算CHAR(N)    定长字符串    存储指定长度的字符串，例如，CHAR(100)总是存储100个字符的字符串VARCHAR(N)            变长字符串    存储可变长度的字符串，例如，VARCHAR(100)可以存储0~100个字符的字符串BOOLEAN                布尔类型    存储True或者FalseDATE                日期类型    存储日期，例如，2018-06-22TIME                时间类型    存储时间，例如，12:20:59DATETIME            日期和时间类型    存储日期+时间，例如，2018-06-22 12:20:59</code></pre><p>上述是常用数据类型，很多数据类型还有别名，REAL ——&gt; FLOAT(24), 还有一些不常用的数据类型TINYINT(0~255)、JSON等等。</p><p>选择数据类型的时候，要根据业务规则选择合适的类型。通常来说，BIGINT能满足整数存储的需求，VARCHAR(N)能满足字符串存储的需求，这两种类型是使用最广泛的。</p><h3 id="主流数据库介绍"><a href="#主流数据库介绍" class="headerlink" title="主流数据库介绍"></a>主流数据库介绍</h3><p>目前，主流的关系数据库主要分为以下几类：<br>1.<strong>商用数据库</strong>，例如：Oracle，SQL Server，DB2等；<br>2.<strong>开源数据库</strong>，例如：MySQL，PostgreSQL等；<br>3.<strong>桌面数据库</strong>，以微软Access为代表，适合桌面应用程序使用；<br>4.<strong>嵌入式数据库</strong>，以Sqlite为代表，适合手机应用和桌面程序。</p><h3 id="SQL介绍"><a href="#SQL介绍" class="headerlink" title="SQL介绍"></a>SQL介绍</h3><p>SQL是结构化查询语言的缩写，用来访问和操作数据库系统。不同的数据库，都支持SQL。</p><p>各个不同的数据库对标准的SQL支持不太一致。并且，大部分数据库都在标准的SQL上做了扩展。也就是说，如果只使用标准SQL，<strong>理论上所有数据库都可以支持</strong>，但如果使用某个特定数据库的扩展SQL，换一个数据库就不能执行了。例如，Oracle把自己扩展的SQL称为PL/SQL，Microsoft把自己扩展的SQL称为T-SQL。</p><p><strong>现实情况</strong>是，如果我们只使用标准SQL的核心功能，那么所有数据库通常都可以执行。不常用的SQL功能，不同的数据库支持的程度都不一样。而各个数据库支持的各自扩展的功能，通常我们把它们称之为“方言”。</p><p>总的来说，SQL语言定义了这么几种操作数据库的能力：</p><p>DDL：Data Definition Language<br>DDL允许用户定义数据，也就是<strong>创建表、删除表、修改表结构</strong>这些操作。通常，DDL由数据库管理员执行。</p><p>DML：Data Manipulation Language<br>DML为用户提供<strong>添加、删除、更新数据</strong>的能力，这些是应用程序对数据库的日常操作。</p><p>DQL：Data Query Language<br>DQL允许<strong>用户查询数据</strong>，这也是通常最频繁的数据库日常操作。</p><h3 id="语法特点"><a href="#语法特点" class="headerlink" title="语法特点"></a>语法特点</h3><p>SQL语言关键字不区分大小写，但一般 我们规定SQL关键字大写，表名、列名均使用小写。</p><hr><h2 id="二、安装MySQL"><a href="#二、安装MySQL" class="headerlink" title="二、安装MySQL"></a>二、安装MySQL</h2><pre><code>开源关系数据库，现Oracle 旗下产品</code></pre><p>和其他关系数据库有所不同的是，MySQL本身实际上只是一个SQL接口，它的内部还包含了多种数据引擎，常用的包括：</p><ul><li>InnoDB：由Innobase Oy公司开发的一款支持事务的数据库引擎，2006年被Oracle收购；</li><li>MyISAM：MySQL早期集成的默认数据库引擎，不支持事务。</li></ul><p>MySQL接口和数据库引擎的关系就好比某某浏览器和浏览器引擎（IE引擎或Webkit引擎）的关系。<strong>对用户而言，切换浏览器引擎不影响浏览器界面，<em>切换MySQL引擎不影响自己写的应用程序使用MySQL的接口。</em></strong></p><p>使用MySQL时，不同的表还可以使用不同的数据库引擎。如果你不知道应该采用哪种引擎，记住总是选择InnoDB就好了。</p><p>基于MySQL的衍生版本：MariaDB、Aurora、PolarDB .</p><p>MySQL官方版版本： </p><ul><li><p>Community Edition：社区开源版本，免费；</p></li><li><p>Standard Edition：标准版；</p></li><li><p>Enterprise Edition：企业版；</p></li><li><p>Cluster Carrier Grade Edition：集群版。</p><pre><code> 基本SQL功能相同</code></pre></li></ul><h3 id="安装MySQL"><a href="#安装MySQL" class="headerlink" title="安装MySQL"></a>安装MySQL</h3><p>网 址：<a href="https://dev.mysql.com/downloads/mysql/" target="_blank" rel="noopener">https://dev.mysql.com/downloads/mysql/</a></p><p>Debian和Ubuntu用户可以简单地通过命令</p><pre><code>apt-get install mysql-server</code></pre><p>安装最新的MySQL版本。</p><h3 id="运行MySQL"><a href="#运行MySQL" class="headerlink" title="运行MySQL"></a>运行MySQL</h3><pre><code>MySQL安装后会自动在后台运行。为了验证MySQL安装是否正确，我们需要通过mysql这个命令行程序来连接MySQL服务器。</code></pre><p>在命令提示符下输入<code>mysql -u root -p</code>，然后输入口令，如果一切正确，就会连接到MySQL服务器，同时提示符变为mysql&gt;。</p><p>输入exit退出MySQL命令行。注意，<strong>MySQL服务器仍在后台运行。</strong></p><hr><h2 id="三、关系模型"><a href="#三、关系模型" class="headerlink" title="三、关系模型"></a>三、关系模型</h2><pre><code>关系数据库是建立在关系模型上，而关系模型本质上就是若干个存储数据的二维表，可以把它们看作很多Excel表。</code></pre><p>表的每一行称为<strong>记录</strong>（Record），记录是一个逻辑意义上的数据。</p><p>表的每一列称为<strong>字段</strong>（Column），同一个表的每一行记录都拥有相同的若干字段。</p><p>字段定义了数据类型（整型、浮点型、字符串、日期等），以及是否允许为NULL。注意NULL表示字段数据不存在。<strong>一个整型字段如果为NULL不表示它的值为0，同样的，一个字符串型字段为NULL也不表示它的值为空串’’。</strong></p><pre><code>通常情况下，字段应该避免允许为NULL。不允许为NULL可以简化查询条件，加快查询速度，也利于应用程序读取数据后无需判断是否为NULL。</code></pre><p>和Excel表有所不同的是，关系数据库的表和表之间需要建立<strong>“一对多”，“多对一”和“一对一”</strong>的关系，这样才能够按照应用程序的逻辑来组织和存储数据。</p><p>例如，一个班级表：</p><pre><code>ID         名称              班主任201        二年级一班          王老师202        二年级二班        李老师</code></pre><p>每一行对应着一个班级，而一个班级对应着多个学生，所以<strong>班级表和学生表的关系就是“一对多”</strong>：</p><pre><code>ID    姓名    班级ID    性别    年龄1    小明    201      M       92    小红    202         F       83    小军    202         M       84    小白    201     F       9</code></pre><p>反过来，如果我们先在学生表中定位了一行记录，例如ID=1的小明，要确定他的班级，只需要根据他的“班级ID”对应的值201找到班级表中ID=201的记录，即二年级一班。所以，<strong>学生表和班级表是“多对一”的关系。</strong></p><p>如果我们把班级表分拆得细一点，例如，单独创建一个教师表：</p><pre><code>ID        名称        年龄A1        王老师        26A2        张老师        39A3        李老师      32A4        赵老师      27</code></pre><p>班级表只存储教师ID：</p><pre><code>ID        名称            班主任ID201        二年级一班         A1202     二年级二班        A3</code></pre><p>这样，一个班级总是对应一个教师，<strong>班级表和教师表就是“一对一”关系</strong>。</p><p><strong>在关系数据库中，关系是通过主键和外键来维护的。</strong>我们在后面会分别深入讲解。</p><hr><h3 id="3-1-1-主键"><a href="#3-1-1-主键" class="headerlink" title="3.1.1 主键"></a>3.1.1 主键</h3><p>对于关系表，有个很重要的约束，就是任意两条记录不能重复。不能重复不是指两条记录不完全相同，而是<strong>指能够通过某个字段唯一区分出不同的记录，这个字段被称为<em>主键</em>。</strong></p><p>例如，students表的两行记录：</p><pre><code>id    class_id    name    gender    score1    1            小明        M        902    1            小红        F        95</code></pre><p>假设我们把name字段作为主键，那么通过名字小明或小红就能唯一确定一条记录。但是，这么设定，就没法存储同名的同学了，<strong>因为插入相同主键的两条记录是不被允许的</strong>。</p><p>对主键的要求，最关键的一点是：<strong>记录一旦插入到表中，主键最好不要再修改</strong>，因为主键是用来唯一定位记录的，修改了主键，会造成一系列的影响。</p><p>由于主键的作用十分重要，如何选取主键会对业务开发产生重要影响。如果我们以学生的身份证号作为主键，似乎能唯一定位记录。然而，身份证号也是一种业务场景，如果身份证号升位了，或者需要变更，作为主键，不得不修改的时候，就会对业务产生严重影响。</p><p>所以，选取主键的一个基本原则是：<strong>不使用任何业务相关的字段作为主键。</strong></p><p>因此，身份证号、手机号、邮箱地址这些看上去可以唯一的字段，均<strong>不可</strong>用作主键。</p><p>作为主键最好是<strong>完全业务无关</strong>的字段，我们一般把这个字段命名为id。常见的可作为id字段的类型有：</p><ol><li><strong>自增整数类型</strong>：数据库会在插入数据时自动为每一条记录分配一个<strong>自增整数</strong>，这样我们就完全不用担心主键重复，也不用自己预先生成主键；</li></ol><p>2.<strong>全局唯一GUID类型</strong>：使用一种全局唯一的字符串作为主键，类似8f55d96b-8acc-4636-8cb8-76bf8abc2f57。GUID算法通过网卡MAC地址、时间戳和随机数保证任意计算机在任意时间生成的字符串都是不同的，大部分编程语言都内置了GUID算法，可以自己预算出主键。</p><p>对于大部分应用来说，<strong>通常自增类型的主键就能满足需求</strong>。我们在students表中定义的主键也是BIGINT NOT NULL AUTO_INCREMENT类型。</p><pre><code>如果使用INT自增类型，那么当一张表的记录数超过2147483647（约21亿）时，会达到上限而出错。使用BIGINT自增类型则可以最多约922亿亿条记录。</code></pre><h3 id="3-1-2-联合主键"><a href="#3-1-2-联合主键" class="headerlink" title="3.1.2 联合主键"></a>3.1.2 联合主键</h3><p> 关系数据库实际上还允许通过多个字段唯一标识记录，即两个或更多的字段都设置为主键，这种主键被称为联合主键。</p><p> 对于联合主键，<strong>允许一列主键有重复</strong>，只要不是所有主键列都重复即可：</p><pre><code> id_num              id_type            other columns...    1               A                       ...    2                A                        ...    2                B                       ...</code></pre><p>如果我们把上述表的<strong>id_num和id_type这两列作为联合主键</strong>，那么上面的3条记录都是允许的，因为没有两列主键组合起来是相同的。</p><p>没有必要的情况下，我们尽量不使用联合主键，因为它给关系表带来了复杂度的上升。</p><h3 id="3-1-3-小结"><a href="#3-1-3-小结" class="headerlink" title="3.1.3  小结"></a>3.1.3  小结</h3><p> 主键是关系表中记录的唯一标识。主键的选取非常重要：<strong>主键不要带有业务含义，而应该使用BIGINT自增或者GUID类型。主键也不应该允许NULL。</strong></p><p>可以使用多个列作为联合主键，但联合主键并不常用。</p><hr><h3 id="3-2-1-外键"><a href="#3-2-1-外键" class="headerlink" title="3.2.1  外键"></a>3.2.1  外键</h3><p>当我们用主键唯一标识记录时，我们就可以在 <em>students</em> 表中确定任意一个学生的记录：</p><pre><code>id    name    other columns...1    小明        ...2    小红        ...</code></pre><p>我们还可以在 <em>classes</em> 表中确定任意一个班级记录：</p><pre><code>id    name    other columns...1    一班    ...2    二班    ...</code></pre><p>但是我们如何确定students表的一条记录，例如，id=1的小明，属于哪个班级呢？</p><p>由于一个班级可以有多个学生，在关系模型中，这两个表的关系可以称为<strong>“一对多”</strong>，即一个classes的记录可以对应多个students表的记录。</p><p>为了表达这种一对多的关系，我们需要在students表中加入一列class_id，让它的值与classes表的某条记录相对应：</p><pre><code>id    class_id    name    other columns...1        1        小明        ...2        1       小红        ...5        2        小白        ...</code></pre><p>这样，我们就可以根据class_id这个列直接定位出一个students表的记录应该对应到classes的哪条记录。    </p><p>在students表中，<strong>通过class_id的字段，可以把数据与另一张表关联起来</strong>，这种列称为<strong>外键</strong>。</p><p>外键并不是通过列名实现的，而是<strong>通过定义外键约束实现</strong>的：</p><pre><code>ALTER TABLE studentsADD CONSTRAINT fk_class_idFOREIGN KEY (class_id)REFERENCES classes (id);</code></pre><p>其中，外键约束的名称fk_class_id可以任意，FOREIGN KEY (class_id)指定了class_id作为外键，REFERENCES classes (id)指定了这个外键将关联到classes表的id列（即classes表的主键）。</p><p><strong>通过定义外键约束，关系数据库可以保证无法插入无效的数据</strong>。即如果classes表不存在id=99的记录，students表就无法插入class_id=99的记录。</p><p><em>由于外键约束会降低数据库的性能，大部分互联网应用程序为了追求速度，并不设置外键约束，而是仅靠应用程序自身来保证逻辑的正确性</em>。这种情况下，class_id仅仅是一个普通的列，只是它起到了外键的作用而已。</p><p>要删除一个外键约束，也是通过ALTER TABLE实现的：</p><pre><code>ALTER TABLE studentsDROP FOREIGN KEY fk_class_id;</code></pre><p>注意：<strong>删除外键约束并没有删除外键这一列</strong>。删除列是通过DROP COLUMN …实现的。</p><h3 id="3-2-2-多对多"><a href="#3-2-2-多对多" class="headerlink" title="3.2.2 多对多"></a>3.2.2 多对多</h3><p>通过一个表的外键关联到另一个表，我们可以定义出一对多关系。有些时候，还需要定义“多对多”关系。例如，一个老师可以对应多个班级，一个班级也可以对应多个老师，因此，<strong>班级表和老师表存在多对多关系。</strong></p><p>多对多关系实际上是通过两个一对多关系实现的，即<strong>通过一个中间表，关联两个一对多关系，就形成了多对多关系：</strong></p><p><strong>teachers表：</strong></p><pre><code>id    name1    张老师2    王老师3    李老师4    赵老师</code></pre><p><strong>classes表：</strong></p><pre><code>id    name1    一班2    二班</code></pre><p><strong>中间表teacher_class关联两个一对多关系：</strong></p><pre><code>id    teacher_id    class_id1        1           12       1           23        2            14        2            25        3            16        4            2</code></pre><p>通过中间表teacher_class可知teachers到classes的关系：</p><ul><li>id=1的张老师对应id=1,2的一班和二班；</li><li>id=2的王老师对应id=1,2的一班和二班；</li><li>id=3的李老师对应id=1的一班；</li><li>id=4的赵老师对应id=2的二班。  </li></ul><p>同理可知classes到teachers的关系：</p><ul><li>id=1的一班对应id=1,2,3的张老师、王老师和李老师；</li><li>id=2的二班对应id=1,2,4的张老师、王老师和赵老师；</li></ul><p>因此，通过中间表，我们就定义了一个“多对多”关系。</p><h3 id="3-2-3-一对一"><a href="#3-2-3-一对一" class="headerlink" title="3.2.3 一对一"></a>3.2.3 一对一</h3><pre><code>一对一关系是指，一个表的记录对应到另一个表的唯一一个记录。</code></pre><p>例如，students表的每个学生可以有自己的联系方式，如果<em>把联系方式存入另一个表contacts</em>，我们就可以得到一个“一对一”关系：</p><pre><code>id        student_id        mobile1           1          135xxxx63002            2          138xxxx22093            5          139xxxx8086</code></pre><p>既然是一对一关系，那为啥不给students表增加一个mobile列，这样就能合二为一了？??</p><p>如果业务允许，完全可以把两个表合为一个表。但是，有些时候，如果某个学生没有手机号，那么，contacts表就不存在对应的记录。实际上，<strong>一对一关系准确地说，是contacts表一对一对应students表。</strong>    </p><p>还<strong>有一些应用会把一个大表拆成两个一对一的表，目的是把经常读取和不经常读取的字段分开，以获得更高的性能。</strong>例如，把一个大的用户表分拆为用户基本信息表user_info和用户详细信息表user_profiles，大部分时候，只需要查询user_info表，并不需要查询user_profiles表，这样就提高了查询速度。</p><h3 id="3-2-4-小结"><a href="#3-2-4-小结" class="headerlink" title="3.2.4 小结"></a>3.2.4 小结</h3><pre><code>关系数据库通过外键可以实现一对多、多对多和一对一的关系。外键既可以通过数据库来约束，也可以不设置约束，仅依靠应用程序的逻辑来保证。</code></pre><hr><h3 id="3-3-1-索引"><a href="#3-3-1-索引" class="headerlink" title="3.3.1 索引"></a>3.3.1 索引</h3><pre><code>在关系数据库中，如果有上万甚至上亿条记录，在查找记录的时候，想要获得非常快的速度，就需要使用索引。</code></pre><p><strong>索引</strong>是<strong>关系数据库中对某一列或多个列的值进行<em>预排序</em>的数据结构</strong>。通过使用索引，可以让数据库系统不必扫描整个表，而是直接定位到符合条件的记录，这样就<em>大大加快了查询速度</em>。</p><p>例如，对于students表：</p><pre><code>id        class_id        name    gender        score1            1           小明        M            902            1            小红        F           953           1           小军        M            88</code></pre><p>如果要经常根据score列进行查询，就可以对score列创建索引：</p><pre><code>ALTER TABLE studentsADD INDEX idx_score (score);</code></pre><p>使用 ADD INDEX idx_score (score) 就创建了一个名称为 idx_score ，使用列 score 的索引。索引名称是任意的，索引如果有多列，可以在括号里依次写上，例如：</p><pre><code>ALTER TABLE studentsADD INDEX idx_name_score (name, score);</code></pre><p><strong>索引的效率取决于索引列的值是否散列</strong>，即该列的值如果越<strong>互不相同</strong>，那么索引效率越高。反过来，如果记录的列存在大量相同的值，例如gender列，大约一半的记录值是 M，另一半是 F，因此，对该列创建索引就没有意义。</p><p>可以对一张表创建多个索引。索引的<strong>优</strong>点：提高了查询效率，<strong>缺点</strong>：在插入、更新和删除记录时，需要同时修改索引，因此，<strong>索引越多，插入、更新和删除记录的速度就越慢。</strong></p><p><strong>对于主键，关系数据库会自动对其创建主键索引</strong>。使用主键索引的效率是最高的，因为主键会保证绝对唯一。</p><h3 id="3-3-2-唯一索引"><a href="#3-3-2-唯一索引" class="headerlink" title="3.3.2 唯一索引"></a>3.3.2 唯一索引</h3><p>在设计关系数据表的时候，看上去唯一的列，例如身份证号、邮箱地址等，因为他们具有业务含义，因此不宜作为主键。</p><p>但是，<strong>这些列根据业务要求，又具有唯一性约束</strong>：即不能出现两条记录存储了同一个身份证号。这个时候，就可以给该列添加一个唯一索引。例如，我们假设students表的name不能重复：<br>（即不宜作主键，宜作索引）</p><pre><code>ALTER TABLE studentsADD UNIQUE INDEX uni_name (name);</code></pre><p>通过<strong>UNIQUE关键字</strong>我们就添加了一个唯一索引。<br>也可以只对某一列添加一个唯一约束而不创建唯一索引</p><pre><code>ALTER TABLE studentsADD CONSTRAINT uni_name UNIQUE (name);</code></pre><p>这种情况下，name列没有索引，但仍然具有唯一性保证。</p><p>无论是否创建索引，对于用户和应用程序来说，使用关系数据库不会有任何区别。这里的意思是说，当我们在数据库中查询时，如果有相应的索引可用，数据库系统就会自动使用索引来提高查询效率，如果没有索引，查询也能正常执行，只是速度会变慢。因此，索引可以在使用数据库的过程中逐步优化。</p><h3 id="3-3-3-小结"><a href="#3-3-3-小结" class="headerlink" title="3.3.3 小结"></a>3.3.3 小结</h3><p>通过对数据库表创建索引，可以提高查询速度。</p><p>通过创建唯一索引，可以保证某一列的值具有唯一性。</p><p>数据库索引对于用户和应用程序来说都是<strong>透明的</strong>。</p><hr>]]></content>
      
      
      <categories>
          
          <category> 数据库 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> MySQL </tag>
            
            <tag> SQL </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>十大经典排序算法整理汇总（附代码）</title>
      <link href="/2020/02/16/sort-algorithms/"/>
      <url>/2020/02/16/sort-algorithms/</url>
      
        <content type="html"><![CDATA[<blockquote><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2></blockquote><p>本文整理并总结了十大经典的排序算法（冒泡排序、选择排序、插入排序、快速排序、归并排序、希尔排序、计数排序、基数排序、桶排序、堆排序）的时间复杂度、空间复杂度等性质。</p><p><strong>本文并不会详细讲解每种排序算法的原理</strong>，网上有很多很好的教程，大家可以自己去搜了看。</p><p>最后我还亲自手写了十种排序算法的 c++ 代码，大家可以用来通过 <a href="https://leetcode-cn.com/problems/sort-an-array/" title="LeetCode 912. 排序数组" target="_blank" rel="noopener">LeetCode 912. 排序数组</a> 这道题。</p><h2 id="性质汇总"><a href="#性质汇总" class="headerlink" title="性质汇总"></a>性质汇总</h2><blockquote><p>如果发现表中有错误，请留言告知。</p></blockquote><table><thead><tr><th>算法</th><th>最好</th><th>最坏</th><th>平均</th><th>空间</th><th align="center">稳定性</th><th align="center">是否基于比较</th></tr></thead><tbody><tr><td>冒泡排序</td><td>$O(n)$</td><td>$O(n^2)$</td><td>$O(n^2)$</td><td>$O(1)$</td><td align="center">$\checkmark$</td><td align="center">$\checkmark$</td></tr><tr><td>选择排序</td><td>$O(n^2)$</td><td>$O(n^2)$</td><td>$O(n^2)$</td><td>$O(1)$</td><td align="center">$\times$</td><td align="center">$\checkmark$</td></tr><tr><td>插入排序</td><td>$O(n)$</td><td>$O(n^2)$</td><td>$O(n^2)$</td><td>$O(1)$</td><td align="center">$\checkmark$</td><td align="center">$\checkmark$</td></tr><tr><td>快速排序</td><td>$O(n\log n)$</td><td>$O(n^2)$</td><td>$O(n\log n)$</td><td>$O(\log n)$~$O(n)$</td><td align="center">$\times$</td><td align="center">$\checkmark$</td></tr><tr><td>归并排序</td><td>$O(n\log n)$</td><td>$O(n\log n)$</td><td>$O(n\log n)$</td><td>$O(n)$</td><td align="center">$\checkmark$</td><td align="center">$\checkmark$</td></tr><tr><td>希尔排序</td><td>$O(n^{1.3})$</td><td>$O(n^2)$</td><td>$O(n\log n)$~$O(n^2)$</td><td>$O(1)$</td><td align="center">$\times$</td><td align="center">$\checkmark$</td></tr><tr><td>计数排序</td><td>$O(n+k)$</td><td>$O(n+k)$</td><td>$O(n+k)$</td><td>$O(n+k)$</td><td align="center">$\checkmark$</td><td align="center">$\times$</td></tr><tr><td>基数排序</td><td>$O(nk)$</td><td>$O(nk)$</td><td>$O(nk)$</td><td>$O(n+k)$</td><td align="center">$\checkmark$</td><td align="center">$\times$</td></tr><tr><td>桶排序</td><td>$O(n)$</td><td>$O(n)$</td><td>$O(n)$</td><td>$O(n+m)$</td><td align="center">$\checkmark$</td><td align="center">$\times$</td></tr><tr><td>堆排序</td><td>$O(n\log n)$</td><td>$O(n\log n)$</td><td>$O(n\log n)$</td><td>$O(1)$</td><td align="center">$\times$</td><td align="center">$\checkmark$</td></tr></tbody></table><blockquote><p>如果表格显示有问题的话，还可以直接看下面的汇总图：</p></blockquote><p><img src="1.png" alt="十大经典排序算法性质汇总"></p><h3 id="维基百科"><a href="#维基百科" class="headerlink" title="维基百科"></a>维基百科</h3><p>我觉得还是英文维基百科讲的比较详细、严谨。如果大家看的比较累的话，可以自己百度搜索相应的教程。</p><p><strong>冒泡排序</strong><br><a href="https://en.wikipedia.org/wiki/Bubble_sort" target="_blank" rel="noopener">https://en.wikipedia.org/wiki/Bubble_sort</a></p><p><strong>选择排序</strong><br><a href="https://en.wikipedia.org/wiki/Selection_sort" target="_blank" rel="noopener">https://en.wikipedia.org/wiki/Selection_sort</a></p><p><strong>插入排序</strong><br><a href="https://en.wikipedia.org/wiki/Insertion_sort" target="_blank" rel="noopener">https://en.wikipedia.org/wiki/Insertion_sort</a></p><p><strong>快速排序</strong><br><a href="https://en.wikipedia.org/wiki/Quicksort" target="_blank" rel="noopener">https://en.wikipedia.org/wiki/Quicksort</a></p><p><strong>归并排序</strong><br><a href="https://en.wikipedia.org/wiki/Merge_sort" target="_blank" rel="noopener">https://en.wikipedia.org/wiki/Merge_sort</a></p><p><strong>希尔排序</strong><br><a href="https://en.wikipedia.org/wiki/Shellsort" target="_blank" rel="noopener">https://en.wikipedia.org/wiki/Shellsort</a></p><p><strong>计数排序</strong><br><a href="https://en.wikipedia.org/wiki/Counting_sort" target="_blank" rel="noopener">https://en.wikipedia.org/wiki/Counting_sort</a></p><p><strong>基数排序</strong><br><a href="https://en.wikipedia.org/wiki/Radix_sort" target="_blank" rel="noopener">https://en.wikipedia.org/wiki/Radix_sort</a></p><p><strong>桶排序</strong><br><a href="https://en.wikipedia.org/wiki/Bucket_sort" target="_blank" rel="noopener">https://en.wikipedia.org/wiki/Bucket_sort</a></p><p><strong>堆排序</strong><br><a href="https://en.wikipedia.org/wiki/Heapsort" target="_blank" rel="noopener">https://en.wikipedia.org/wiki/Heapsort</a></p><h2 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h2><p>所有的排序算法接口都是相同的，也就是 <code>vector&lt;int&gt; xxxSort(vector&lt;int&gt;&amp; nums)</code> 。只需要你传入一个 <code>vector&lt;int&gt;</code> 类型的数组，就能返回排序后的结果。</p><p>运行下来可以发现，桶排序速度是比较快的。而冒泡排序、选择排序和插入排序因为时间复杂度太高无法通过本题，基数排序因为无法处理负数也不能通过本题。</p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">{</span><span class="token keyword">public</span><span class="token operator">:</span>    vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span> <span class="token function">sortArray</span><span class="token punctuation">(</span>vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span><span class="token operator">&amp;</span> nums<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">return</span> <span class="token function">quickSort</span><span class="token punctuation">(</span>nums<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">// 冒泡排序（超时）</span>    vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span> <span class="token function">bubbleSort</span><span class="token punctuation">(</span>vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span><span class="token operator">&amp;</span> nums<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">int</span> n <span class="token operator">=</span> nums<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> n<span class="token punctuation">;</span> <span class="token operator">++</span>i<span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> j <span class="token operator">=</span> n<span class="token number">-2</span><span class="token punctuation">;</span> j <span class="token operator">>=</span> i<span class="token punctuation">;</span> <span class="token operator">--</span>j<span class="token punctuation">)</span> <span class="token punctuation">{</span>                <span class="token keyword">if</span> <span class="token punctuation">(</span>nums<span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">></span> nums<span class="token punctuation">[</span>j<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                    <span class="token function">swap</span><span class="token punctuation">(</span>nums<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">,</span> nums<span class="token punctuation">[</span>j<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token punctuation">}</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span>        <span class="token keyword">return</span> nums<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">// 选择排序（超时）</span>    vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span> <span class="token function">selectSort</span><span class="token punctuation">(</span>vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span><span class="token operator">&amp;</span> nums<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">int</span> n <span class="token operator">=</span> nums<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> n<span class="token punctuation">;</span> <span class="token operator">++</span>i<span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">int</span> idx <span class="token operator">=</span> i<span class="token punctuation">;</span>            <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> j <span class="token operator">=</span> i<span class="token punctuation">;</span> j <span class="token operator">&lt;</span> n<span class="token punctuation">;</span> <span class="token operator">++</span>j<span class="token punctuation">)</span> <span class="token punctuation">{</span>                <span class="token keyword">if</span> <span class="token punctuation">(</span>nums<span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">&lt;</span> nums<span class="token punctuation">[</span>idx<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                    idx <span class="token operator">=</span> j<span class="token punctuation">;</span>                <span class="token punctuation">}</span>            <span class="token punctuation">}</span>            <span class="token function">swap</span><span class="token punctuation">(</span>nums<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">,</span> nums<span class="token punctuation">[</span>idx<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">return</span> nums<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">// 插入排序（超时）</span>    vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span> <span class="token function">insertSort</span><span class="token punctuation">(</span>vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span><span class="token operator">&amp;</span> nums<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">int</span> n <span class="token operator">=</span> nums<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> n<span class="token punctuation">;</span> <span class="token operator">++</span>i<span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> j <span class="token operator">=</span> i<span class="token punctuation">;</span> j <span class="token operator">></span> <span class="token number">0</span> <span class="token operator">&amp;&amp;</span> nums<span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">&lt;</span> nums<span class="token punctuation">[</span>j<span class="token number">-1</span><span class="token punctuation">]</span><span class="token punctuation">;</span> <span class="token operator">--</span>j<span class="token punctuation">)</span> <span class="token punctuation">{</span>                <span class="token function">swap</span><span class="token punctuation">(</span>nums<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">,</span> nums<span class="token punctuation">[</span>j<span class="token number">-1</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span>        <span class="token keyword">return</span> nums<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">// 快速排序（24 ms）</span>    <span class="token keyword">void</span> <span class="token function">qSort</span><span class="token punctuation">(</span>vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span><span class="token operator">&amp;</span> nums<span class="token punctuation">,</span> <span class="token keyword">int</span> l<span class="token punctuation">,</span> <span class="token keyword">int</span> r<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>l <span class="token operator">>=</span> r<span class="token punctuation">)</span> <span class="token keyword">return</span><span class="token punctuation">;</span>        <span class="token keyword">int</span> m <span class="token operator">=</span> l<span class="token punctuation">;</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> l<span class="token punctuation">;</span> i <span class="token operator">&lt;</span> r<span class="token punctuation">;</span> <span class="token operator">++</span>i<span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>nums<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">&lt;</span> nums<span class="token punctuation">[</span>r<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                <span class="token function">swap</span><span class="token punctuation">(</span>nums<span class="token punctuation">[</span>m<span class="token operator">++</span><span class="token punctuation">]</span><span class="token punctuation">,</span> nums<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span>        <span class="token function">swap</span><span class="token punctuation">(</span>nums<span class="token punctuation">[</span>m<span class="token punctuation">]</span><span class="token punctuation">,</span> nums<span class="token punctuation">[</span>r<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token function">qSort</span><span class="token punctuation">(</span>nums<span class="token punctuation">,</span> l<span class="token punctuation">,</span> m<span class="token number">-1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token function">qSort</span><span class="token punctuation">(</span>nums<span class="token punctuation">,</span> m<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">,</span> r<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span> <span class="token function">quickSort</span><span class="token punctuation">(</span>vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span><span class="token operator">&amp;</span> nums<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">int</span> n <span class="token operator">=</span> nums<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token function">qSort</span><span class="token punctuation">(</span>nums<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> n<span class="token number">-1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">return</span> nums<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">// 归并排序（192 ms）</span>    vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span> <span class="token function">mSort</span><span class="token punctuation">(</span>vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span><span class="token operator">&amp;</span> nums<span class="token punctuation">,</span> <span class="token keyword">int</span> l<span class="token punctuation">,</span> <span class="token keyword">int</span> r<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>l <span class="token operator">>=</span> r<span class="token punctuation">)</span> <span class="token keyword">return</span> <span class="token punctuation">{</span>nums<span class="token punctuation">[</span>l<span class="token punctuation">]</span><span class="token punctuation">}</span><span class="token punctuation">;</span>        <span class="token keyword">int</span> m <span class="token operator">=</span> l<span class="token operator">+</span><span class="token punctuation">(</span>r<span class="token operator">-</span>l<span class="token punctuation">)</span><span class="token operator">/</span><span class="token number">2</span><span class="token punctuation">;</span>        vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span> lnums <span class="token operator">=</span> <span class="token function">mSort</span><span class="token punctuation">(</span>nums<span class="token punctuation">,</span> l<span class="token punctuation">,</span> m<span class="token punctuation">)</span><span class="token punctuation">;</span>        vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span> rnums <span class="token operator">=</span> <span class="token function">mSort</span><span class="token punctuation">(</span>nums<span class="token punctuation">,</span> m<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">,</span> r<span class="token punctuation">)</span><span class="token punctuation">;</span>        vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span> res<span class="token punctuation">;</span>        <span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">,</span> j <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>        <span class="token keyword">while</span> <span class="token punctuation">(</span>i <span class="token operator">&lt;=</span> m<span class="token operator">-</span>l <span class="token operator">&amp;&amp;</span> j <span class="token operator">&lt;=</span> r<span class="token operator">-</span>m<span class="token number">-1</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>lnums<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">&lt;</span> rnums<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                res<span class="token punctuation">.</span><span class="token function">push_back</span><span class="token punctuation">(</span>lnums<span class="token punctuation">[</span>i<span class="token operator">++</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>                res<span class="token punctuation">.</span><span class="token function">push_back</span><span class="token punctuation">(</span>rnums<span class="token punctuation">[</span>j<span class="token operator">++</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span>        <span class="token keyword">while</span> <span class="token punctuation">(</span>i <span class="token operator">&lt;=</span> m<span class="token operator">-</span>l<span class="token punctuation">)</span> <span class="token punctuation">{</span>            res<span class="token punctuation">.</span><span class="token function">push_back</span><span class="token punctuation">(</span>lnums<span class="token punctuation">[</span>i<span class="token operator">++</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">while</span> <span class="token punctuation">(</span>j <span class="token operator">&lt;=</span> r<span class="token operator">-</span>m<span class="token number">-1</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            res<span class="token punctuation">.</span><span class="token function">push_back</span><span class="token punctuation">(</span>rnums<span class="token punctuation">[</span>j<span class="token operator">++</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">return</span> res<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span> <span class="token function">mergeSort</span><span class="token punctuation">(</span>vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span><span class="token operator">&amp;</span> nums<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">int</span> n <span class="token operator">=</span> nums<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        nums <span class="token operator">=</span> <span class="token function">mSort</span><span class="token punctuation">(</span>nums<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> n<span class="token number">-1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">return</span> nums<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">// 归并排序 + 非递归（80 ms）</span>    vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span> <span class="token function">mergeSortNR</span><span class="token punctuation">(</span>vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span><span class="token operator">&amp;</span> nums<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">int</span> n <span class="token operator">=</span> nums<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> len <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span> len <span class="token operator">&lt;</span> n<span class="token punctuation">;</span> len <span class="token operator">&lt;&lt;=</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> l <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> l <span class="token operator">&lt;</span> n<span class="token operator">-</span>len<span class="token punctuation">;</span> l <span class="token operator">+</span><span class="token operator">=</span> <span class="token number">2</span><span class="token operator">*</span>len<span class="token punctuation">)</span> <span class="token punctuation">{</span>                <span class="token keyword">int</span> m <span class="token operator">=</span> l<span class="token operator">+</span>len<span class="token number">-1</span><span class="token punctuation">;</span>                <span class="token keyword">int</span> r <span class="token operator">=</span> <span class="token function">min</span><span class="token punctuation">(</span>n<span class="token number">-1</span><span class="token punctuation">,</span> l<span class="token operator">+</span><span class="token number">2</span><span class="token operator">*</span>len<span class="token number">-1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span> res<span class="token punctuation">;</span>                <span class="token keyword">int</span> i <span class="token operator">=</span> l<span class="token punctuation">,</span> j <span class="token operator">=</span> m<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">;</span>                <span class="token keyword">while</span> <span class="token punctuation">(</span>i <span class="token operator">&lt;=</span> m <span class="token operator">&amp;&amp;</span> j <span class="token operator">&lt;=</span> r<span class="token punctuation">)</span> <span class="token punctuation">{</span>                    <span class="token keyword">if</span> <span class="token punctuation">(</span>nums<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">&lt;</span> nums<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                        res<span class="token punctuation">.</span><span class="token function">push_back</span><span class="token punctuation">(</span>nums<span class="token punctuation">[</span>i<span class="token operator">++</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                    <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>                        res<span class="token punctuation">.</span><span class="token function">push_back</span><span class="token punctuation">(</span>nums<span class="token punctuation">[</span>j<span class="token operator">++</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                    <span class="token punctuation">}</span>                <span class="token punctuation">}</span>                <span class="token keyword">while</span> <span class="token punctuation">(</span>i <span class="token operator">&lt;=</span> m<span class="token punctuation">)</span> <span class="token punctuation">{</span>                    res<span class="token punctuation">.</span><span class="token function">push_back</span><span class="token punctuation">(</span>nums<span class="token punctuation">[</span>i<span class="token operator">++</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token punctuation">}</span>                <span class="token keyword">while</span> <span class="token punctuation">(</span>j <span class="token operator">&lt;=</span> r<span class="token punctuation">)</span> <span class="token punctuation">{</span>                    res<span class="token punctuation">.</span><span class="token function">push_back</span><span class="token punctuation">(</span>nums<span class="token punctuation">[</span>j<span class="token operator">++</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token punctuation">}</span>                <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> l<span class="token punctuation">;</span> i <span class="token operator">&lt;=</span> r<span class="token punctuation">;</span> <span class="token operator">++</span>i<span class="token punctuation">)</span> <span class="token punctuation">{</span>                    nums<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> res<span class="token punctuation">[</span>i<span class="token operator">-</span>l<span class="token punctuation">]</span><span class="token punctuation">;</span>                <span class="token punctuation">}</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span>        <span class="token keyword">return</span> nums<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">// 希尔排序（40 ms）</span>    vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span> <span class="token function">shellSort</span><span class="token punctuation">(</span>vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span><span class="token operator">&amp;</span> nums<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">int</span> n <span class="token operator">=</span> nums<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> gap <span class="token operator">=</span> n<span class="token operator">/</span><span class="token number">2</span><span class="token punctuation">;</span> gap <span class="token operator">></span> <span class="token number">0</span><span class="token punctuation">;</span> gap <span class="token operator">/</span><span class="token operator">=</span> <span class="token number">2</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> gap<span class="token punctuation">;</span> i <span class="token operator">&lt;</span> n<span class="token punctuation">;</span> <span class="token operator">++</span>i<span class="token punctuation">)</span> <span class="token punctuation">{</span>                <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> j <span class="token operator">=</span> i<span class="token punctuation">;</span> j<span class="token operator">-</span>gap <span class="token operator">>=</span> <span class="token number">0</span> <span class="token operator">&amp;&amp;</span> nums<span class="token punctuation">[</span>j<span class="token operator">-</span>gap<span class="token punctuation">]</span> <span class="token operator">></span> nums<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">;</span> j <span class="token operator">-</span><span class="token operator">=</span> gap<span class="token punctuation">)</span> <span class="token punctuation">{</span>                    <span class="token function">swap</span><span class="token punctuation">(</span>nums<span class="token punctuation">[</span>j<span class="token operator">-</span>gap<span class="token punctuation">]</span><span class="token punctuation">,</span> nums<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token punctuation">}</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span>        <span class="token keyword">return</span> nums<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">// 计数排序（32 ms）</span>    vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span> <span class="token function">countSort</span><span class="token punctuation">(</span>vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span><span class="token operator">&amp;</span> nums<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">int</span> n <span class="token operator">=</span> nums<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>n<span class="token punctuation">)</span> <span class="token keyword">return</span> <span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">;</span>        <span class="token keyword">int</span> minv <span class="token operator">=</span> <span class="token operator">*</span><span class="token function">min_element</span><span class="token punctuation">(</span>nums<span class="token punctuation">.</span><span class="token function">begin</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> nums<span class="token punctuation">.</span><span class="token function">end</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">int</span> maxv <span class="token operator">=</span> <span class="token operator">*</span><span class="token function">max_element</span><span class="token punctuation">(</span>nums<span class="token punctuation">.</span><span class="token function">begin</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> nums<span class="token punctuation">.</span><span class="token function">end</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">int</span> m <span class="token operator">=</span> maxv<span class="token operator">-</span>minv<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">;</span>        vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span> <span class="token function">count</span><span class="token punctuation">(</span>m<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> n<span class="token punctuation">;</span> <span class="token operator">++</span>i<span class="token punctuation">)</span> <span class="token punctuation">{</span>            count<span class="token punctuation">[</span>nums<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token operator">-</span>minv<span class="token punctuation">]</span><span class="token operator">++</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span> res<span class="token punctuation">;</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> m<span class="token punctuation">;</span> <span class="token operator">++</span>i<span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> j <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> j <span class="token operator">&lt;</span> count<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span> <span class="token operator">++</span>j<span class="token punctuation">)</span> <span class="token punctuation">{</span>                res<span class="token punctuation">.</span><span class="token function">push_back</span><span class="token punctuation">(</span>i<span class="token operator">+</span>minv<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span>        <span class="token keyword">return</span> res<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">// 基数排序（不适用于负数）</span>    vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span> <span class="token function">radixSort</span><span class="token punctuation">(</span>vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span><span class="token operator">&amp;</span> nums<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">int</span> n <span class="token operator">=</span> nums<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">int</span> maxv <span class="token operator">=</span> <span class="token operator">*</span><span class="token function">max_element</span><span class="token punctuation">(</span>nums<span class="token punctuation">.</span><span class="token function">begin</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> nums<span class="token punctuation">.</span><span class="token function">end</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">int</span> maxd <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>        <span class="token keyword">while</span> <span class="token punctuation">(</span>maxv <span class="token operator">></span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            maxv <span class="token operator">/</span><span class="token operator">=</span> <span class="token number">10</span><span class="token punctuation">;</span>            maxd<span class="token operator">++</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span> <span class="token function">count</span><span class="token punctuation">(</span><span class="token number">10</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token function">rank</span><span class="token punctuation">(</span>n<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">int</span> base <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>        <span class="token keyword">while</span> <span class="token punctuation">(</span>maxd <span class="token operator">></span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            count<span class="token punctuation">.</span><span class="token function">assign</span><span class="token punctuation">(</span><span class="token number">10</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> n<span class="token punctuation">;</span> <span class="token operator">++</span>i<span class="token punctuation">)</span> <span class="token punctuation">{</span>                count<span class="token punctuation">[</span><span class="token punctuation">(</span>nums<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token operator">/</span>base<span class="token punctuation">)</span><span class="token operator">%</span><span class="token number">10</span><span class="token punctuation">]</span><span class="token operator">++</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>            <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> <span class="token number">10</span><span class="token punctuation">;</span> <span class="token operator">++</span>i<span class="token punctuation">)</span> <span class="token punctuation">{</span>                count<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">+</span><span class="token operator">=</span> count<span class="token punctuation">[</span>i<span class="token number">-1</span><span class="token punctuation">]</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>            <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> n<span class="token number">-1</span><span class="token punctuation">;</span> i <span class="token operator">>=</span> <span class="token number">0</span><span class="token punctuation">;</span> <span class="token operator">--</span>i<span class="token punctuation">)</span> <span class="token punctuation">{</span>                rank<span class="token punctuation">[</span><span class="token operator">--</span>count<span class="token punctuation">[</span><span class="token punctuation">(</span>nums<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token operator">/</span>base<span class="token punctuation">)</span><span class="token operator">%</span><span class="token number">10</span><span class="token punctuation">]</span><span class="token punctuation">]</span> <span class="token operator">=</span> nums<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>            <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> n<span class="token punctuation">;</span> <span class="token operator">++</span>i<span class="token punctuation">)</span> <span class="token punctuation">{</span>                nums<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> rank<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>            maxd<span class="token operator">--</span><span class="token punctuation">;</span>            base <span class="token operator">*</span><span class="token operator">=</span> <span class="token number">10</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">return</span> nums<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">// 桶排序 (20 ms)</span>    vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span> <span class="token function">bucketSort</span><span class="token punctuation">(</span>vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span><span class="token operator">&amp;</span> nums<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">int</span> n <span class="token operator">=</span> nums<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">int</span> maxv <span class="token operator">=</span> <span class="token operator">*</span><span class="token function">max_element</span><span class="token punctuation">(</span>nums<span class="token punctuation">.</span><span class="token function">begin</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> nums<span class="token punctuation">.</span><span class="token function">end</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">int</span> minv <span class="token operator">=</span> <span class="token operator">*</span><span class="token function">min_element</span><span class="token punctuation">(</span>nums<span class="token punctuation">.</span><span class="token function">begin</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> nums<span class="token punctuation">.</span><span class="token function">end</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">int</span> bs <span class="token operator">=</span> <span class="token number">1000</span><span class="token punctuation">;</span>        <span class="token keyword">int</span> m <span class="token operator">=</span> <span class="token punctuation">(</span>maxv<span class="token operator">-</span>minv<span class="token punctuation">)</span><span class="token operator">/</span>bs<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">;</span>        vector<span class="token operator">&lt;</span>vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span> <span class="token operator">></span> <span class="token function">bucket</span><span class="token punctuation">(</span>m<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> n<span class="token punctuation">;</span> <span class="token operator">++</span>i<span class="token punctuation">)</span> <span class="token punctuation">{</span>            bucket<span class="token punctuation">[</span><span class="token punctuation">(</span>nums<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token operator">-</span>minv<span class="token punctuation">)</span><span class="token operator">/</span>bs<span class="token punctuation">]</span><span class="token punctuation">.</span><span class="token function">push_back</span><span class="token punctuation">(</span>nums<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">int</span> idx <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> m<span class="token punctuation">;</span> <span class="token operator">++</span>i<span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">int</span> sz <span class="token operator">=</span> bucket<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            bucket<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token function">quickSort</span><span class="token punctuation">(</span>bucket<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> j <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> j <span class="token operator">&lt;</span> sz<span class="token punctuation">;</span> <span class="token operator">++</span>j<span class="token punctuation">)</span> <span class="token punctuation">{</span>                nums<span class="token punctuation">[</span>idx<span class="token operator">++</span><span class="token punctuation">]</span> <span class="token operator">=</span> bucket<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span>        <span class="token keyword">return</span> nums<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">// 堆排序（32 ms）</span>    <span class="token keyword">void</span> <span class="token function">adjust</span><span class="token punctuation">(</span>vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span><span class="token operator">&amp;</span> nums<span class="token punctuation">,</span> <span class="token keyword">int</span> p<span class="token punctuation">,</span> <span class="token keyword">int</span> s<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token number">2</span><span class="token operator">*</span>p<span class="token operator">+</span><span class="token number">1</span> <span class="token operator">&lt;</span> s<span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">int</span> c1 <span class="token operator">=</span> <span class="token number">2</span><span class="token operator">*</span>p<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">;</span>            <span class="token keyword">int</span> c2 <span class="token operator">=</span> <span class="token number">2</span><span class="token operator">*</span>p<span class="token operator">+</span><span class="token number">2</span><span class="token punctuation">;</span>            <span class="token keyword">int</span> c <span class="token operator">=</span> <span class="token punctuation">(</span>c2<span class="token operator">&lt;</span>s <span class="token operator">&amp;&amp;</span> nums<span class="token punctuation">[</span>c2<span class="token punctuation">]</span><span class="token operator">></span>nums<span class="token punctuation">[</span>c1<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token operator">?</span> c2 <span class="token operator">:</span> c1<span class="token punctuation">;</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>nums<span class="token punctuation">[</span>c<span class="token punctuation">]</span> <span class="token operator">></span> nums<span class="token punctuation">[</span>p<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token function">swap</span><span class="token punctuation">(</span>nums<span class="token punctuation">[</span>c<span class="token punctuation">]</span><span class="token punctuation">,</span> nums<span class="token punctuation">[</span>p<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token keyword">else</span> <span class="token keyword">break</span><span class="token punctuation">;</span>            p <span class="token operator">=</span> c<span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span>    vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span> <span class="token function">heapSort</span><span class="token punctuation">(</span>vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span><span class="token operator">&amp;</span> nums<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">int</span> n <span class="token operator">=</span> nums<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> n<span class="token operator">/</span><span class="token number">2</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span> i <span class="token operator">>=</span> <span class="token number">0</span><span class="token punctuation">;</span> <span class="token operator">--</span>i<span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token function">adjust</span><span class="token punctuation">(</span>nums<span class="token punctuation">,</span> i<span class="token punctuation">,</span> n<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> n<span class="token number">-1</span><span class="token punctuation">;</span> i <span class="token operator">></span> <span class="token number">0</span><span class="token punctuation">;</span> <span class="token operator">--</span>i<span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token function">swap</span><span class="token punctuation">(</span>nums<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">,</span> nums<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token function">adjust</span><span class="token punctuation">(</span>nums<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> i<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">return</span> nums<span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> 编程算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> leetcode </tag>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Kali Linux安全测试笔记</title>
      <link href="/2019/09/30/kali-linux-an-quan-ce-shi-bi-ji/"/>
      <url>/2019/09/30/kali-linux-an-quan-ce-shi-bi-ji/</url>
      
        <content type="html"><![CDATA[<h1 id="Kali-Linux安全测试笔记"><a href="#Kali-Linux安全测试笔记" class="headerlink" title="Kali Linux安全测试笔记"></a>Kali Linux安全测试笔记</h1><hr><h2 id="Task1-Kali-Linux渗透测试介绍"><a href="#Task1-Kali-Linux渗透测试介绍" class="headerlink" title="Task1. Kali Linux渗透测试介绍"></a>Task1. Kali Linux渗透测试介绍</h2><p>###渗透测试标准——PETS<br>1.前期交互阶段<br>2.情报收集阶段<br>3.威胁建模阶段<br>4.漏洞分析阶段<br>5.渗透攻击阶段<br>6.后渗透测试阶段<br>7.渗透测试报告</p><p>###安全测试误区</p><ul><li>扫描器就是一切<ul><li>忽视业务逻辑中的漏洞</li></ul></li></ul><p>###Kali Linux 介绍</p><ol><li>FHS标准目录结构</li><li>定制内核</li><li>基于Debian的Linux版本</li><li>支持ARM和手机平台<br>手机上mapHunter???</li></ol><p>###Kali Linux 策略</p><ul><li>ROOT 用户策略 （默认ROOT）</li><li>网络服务策略 （默认网络服务关闭）<br>需手动启动</li><li>更新升级策略</li></ul><p>###关于本教程</p><ul><li>Kali 很强大，但不是全部</li><li>实践是最好的老师</li><li>自行补充所需安全工具，独一无二的Kali</li></ul><h2 id="Task2-Kali-Linux渗透测试介绍"><a href="#Task2-Kali-Linux渗透测试介绍" class="headerlink" title="Task2. Kali Linux渗透测试介绍"></a>Task2. Kali Linux渗透测试介绍</h2><p><strong>*时间有限，暂时跳过这一章视频</strong><br>1.安装文件计算哈希值比对<br>2.U盘启动盘安装<br>  使用官方软件UnitBootin<br>3.制作启动光盘安装</p><p>安装Linux 内核头文件<br>apt-get 基于debian的Linux软件包管理软件  自动连接官网下载源</p><pre><code>apt-get install linux-headers-${uname -r}</code></pre><p>uname -r 查询机器版本</p><p>安装VMTOOLS</p><p><strong>uname -r ：</strong>显示操作系统的发行版号<br><strong>uname -a ：</strong>显示系统名、节点名称、操作系统的发行版号、操作系统版本、运行系统的机器 ID 号。</p><p>apt-get update 连接官网更新软件包索引文件、升级的不是软件包本身，而是索引</p><h2 id="Task3-Kali-Linux安装-持久加密USB安装、熟悉环境、熟悉BASH命令1"><a href="#Task3-Kali-Linux安装-持久加密USB安装、熟悉环境、熟悉BASH命令1" class="headerlink" title="Task3. Kali Linux安装 持久加密USB安装、熟悉环境、熟悉BASH命令1"></a>Task3. Kali Linux安装 持久加密USB安装、熟悉环境、熟悉BASH命令1</h2><p>dmesg  查看系统变化</p><p>###Task4 熟悉环境 Bash命令</p><ul><li>登录密码</li><li>TOP10安全工具</li></ul><p>1.aircrack-ng 无线攻击<br>2.burpsuite 基于Web渗透测试（手动）<br>3.hydra john 密码攻击<br>4.maltego 信息收集（图形化界面）<br>5.metasploit 框架<br>6.nmap网络扫描工具<br>7.owasp-zap 基于web<br>8.Sqlmap 注入<br>9.wireshark 网络数据包</p><ul><li>字体调整</li></ul><p>1.gnome-tweak-tool工具<br>终端输入 gnome-tweaks即可</p><ul><li>监视网络流量</li></ul><p><strong>安装netspeed</strong></p><pre><code>https://blog.csdn.net/penge199761/article/details/79140789</code></pre><ul><li>强行终止程序</li><li>文件目录<br>按功能分类目录 bin、boot、dev、etc、home、lib等</li><li>共享文件</li></ul><p>##熟悉操作Bash命令</p><ul><li><p>ls<br>蓝色-目录  白色-普通文件 绿色-可执行文件  红色-压缩包<br>ls -l 以长格式显示  注意前十个字符 1+9<br>ls -la 多出来以点开始的文件（隐藏文件）<br>ls -lh 以人易读方式显示文件大小 </p></li><li><p>cd  和windows相同<br>cd. 到当前目录<br>cd.. 当上一级目录</p></li><li><p>pwd 查看当前工作目录</p></li><li><p>clear 清空</p></li><li><p>cat 查看文件</p></li><li><p>more 加文件目录 分段查看  q退出查看</p></li><li><p>less 加文件目录 不会显示百分比 q退出查看</p></li><li><p>tail 加文件目录 默认文件最后十行信息<br>tail -n 加文件目录 显示最后n行信息<br>配合 watch命令使用<br>watch -n 2 tail -20 加文件目录 /var/log/messages ，每隔两秒钟刷新查看</p></li><li><p>cp rm 针对文件<br>  rm 删除文件<br>  cp 复制  cp ps ps1 //将ps复制成ps1,针对文件<br>  cp -r Agent/ A   //将Agent文件夹复制成A<br>  rm -r A     //删除文件夹A</p></li><li><p>top 命令<br>查看进程及各种信息、</p></li><li><p>ps命令<br>专门用来查看各种进程信息 + -ef显示更为详细信息</p></li><li><p>grep 命令 筛选信息<br>cat /etc/passwd<br>grep ssh /etc/passwd    //筛选含ssh字符串的行</p></li><li><p>ifconfig 网络<br>ifconfig eth0 down 关闭命令<br>ifconfig eth0 up 打开</p></li><li><p>netstat 查看网络连接信息<br>netstat -pantu 查看与哪些服务器 tcp udp连接</p></li><li><p>管道<br>将多个命令在Linux 同一行输入<br>同一行命令通过管道方式 每个命令间不同关系<br>netstat -pantu |egrep -v ‘0.0.0.0|:::’ 排除？？</p></li><li><p>mount 挂载<br>mount -o loop kali.ios /media/cdrom<br>挂载到目录 查看文件内容</p></li><li><p>dmesg<br>不太懂</p></li><li><p>find 命令<br>查找文件、目录 位置<br>find / -name nmap  从根目录查找名为nmap的文件<br>find / -iname nmap //不区分大小写<br>find . -name ps*    以ps开头的文件</p></li><li><p>whereis 命令<br>查找范围较小 但速度块<br>whereis -b nmap //查找二进制文件</p></li><li><p>vi 命令<br>文本编辑器 vim简称<br>wq 写并退出<br>命令模式下输入内容编辑<br>i 插入<br>输入：或者/即可进入命令模式</p></li><li><p>shell 脚本<br>vi 1.sh<br>#!/bin/bash<br>#! 是所有linux脚本文件开头的符号, 后面的/bin/bash表示是使用/bin/bash为解释器来执行本文件的脚本<br>esc :wq 保存加退出<br>chmod +x 1.sh 增加可执行权限<br>./1.sh 执行脚本</p><p>  #!/bin/bash<br>  for n in seq 9<br>  do<br>  for m in seq $n</p></li></ul><p>##网络配置</p><ul><li>ifconfig<br>ifconfig eth0 指定新ip/子网掩码</li></ul><p>指定网关  route add default gw 192.168.1.1<br> ip 地址 DNS 网关 ，这些。。。。我都不会。。。</p><ul><li>更新升级 <ul><li>apt-get update 更新索引文件</li><li>apt-get upgrade 更新软件包文件</li><li>apt-get update –fix-missing 更新错误索引</li><li>vi /etc/apt/sources.list  更改更新源</li><li>安装软件包</li></ul></li><li>库  apt-get命令</li><li>安装适合的工具软件<br>apt-get install smplayer  //播放器<br>ibus ibus-pinyin<br> flashplugin freemind chromium monodevelop mono-gmcs-y<ul><li>FireFox浏览器插件<br>flashgot | autoproxy |coocie Importer导入cookie<br>cookie manager//   download yotube videos as mp4<br>firebug //  flagfox、   </li></ul></li></ul>]]></content>
      
      
      <categories>
          
          <category> 网络安全 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux </tag>
            
            <tag> 安全测试 </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
