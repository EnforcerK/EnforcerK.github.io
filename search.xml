<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>Network Protocols and Architecture (2)</title>
      <link href="/2020/06/03/network-protocols-and-architecture-2/"/>
      <url>/2020/06/03/network-protocols-and-architecture-2/</url>
      
        <content type="html"><![CDATA[<blockquote><p>In this module, you will learn how data frames are created and processed by hosts and switches will be explained. You will also learn what protocols and network designs are needed to transmit data in a network. At the end of this module, you will use a protocol analyzer or “packet sniffer” to open and examine a data packet that has been transmitted across a network.</p></blockquote><p>在该模块，你将学到主机如何创建和处理数据帧以及如何解释交换机这一概念。你还将学到在网络中传输数据所需的协议和网络设计。在本模块最后，你将使用协议分析器或“数据包（分组）嗅探器”打开并检查已通过网络进行传输的数据包。</p><h1 id="Week2"><a href="#Week2" class="headerlink" title="Week2"></a>Week2</h1><h2 id="1-Preparing-Data-for-Transmission"><a href="#1-Preparing-Data-for-Transmission" class="headerlink" title="1. Preparing Data for Transmission"></a>1. Preparing Data for Transmission</h2><h3 id="1-1-Reading-Encapsulation"><a href="#1-1-Reading-Encapsulation" class="headerlink" title="1.1 Reading: Encapsulation"></a>1.1 Reading: Encapsulation</h3><p>类比人类活动中的写信这一动作，引入封装概念。网络上的通信同样需要遵循特定的格式来进行发送和处理。</p><p>The process of placing one message format [the letter] inside another message format （the envelope） is called <code>encapsulation</code>.</p><p>每条计算机消息在发送前都以特定的格式进行封装，叫做<strong>帧</strong>。 一个帧就像一个信封一样，提供了预期目标和源主机的地址。帧的格式与内容取决于发送消息的类型以及通信的通道。如果消息不正确格式化它将不会被目标主机所接收处理。<br>以下动画展示了解封装的过程。<br><img src="http://static.zybuluo.com/Adward-Wang/ju5sxk5jklnk959yc2gfrc5r/Encapsulation.gif" alt="Encapsulation"></p><h3 id="1-2-Framing-the-Message"><a href="#1-2-Framing-the-Message" class="headerlink" title="1.2 Framing the Message"></a>1.2 Framing the Message</h3><p>以太网协议标准定义了网络通信的许多方面，包括帧的格式、帧的大小、时序以及编码。</p><p>以太网间的主机之间发送消息时，主机会按指定标准将消息格式化为帧布局。帧也被称为<strong>第二层</strong>的协议数据单元。这是因为提供帧创建和格式化规则的协议执行在OSI模型的数据链路层（即第二层）的功能。</p><p>以太网帧的格式指定了目标MAC地址和源MAC地址的位置，以及其他信息，包括：</p><ul><li>Preamble（前同步码） for sequencing and timing</li><li>Start of frame delimiter</li><li>Length and type of frame</li><li>Frame check sequence to detect transmission errors</li></ul><p>从目标MAC地址字段到帧检查序列，以太网帧的大小通常限制为最大1518字节，最小大小为64字节。</p><p>前同步码和SFD用于指示帧的开始。它们不用于帧大小的计算。不符合这些限制的帧不被接收主机处理。 除了帧格式，大小和时序外，以太网标准还定义了构成帧的比特如何编码到信道上。比特可以通过铜电缆传输电脉冲，也可以通过光纤传输光脉冲。</p><p>查看以下信息以简要了解框架中的每个字段。</p><p><img src="http://static.zybuluo.com/Adward-Wang/8tcj1u7mlvfj32s4bbwtp3nx/Structure_of_Ethernet_Frame.jpg" alt="Structure_of_Ethernet_Frame"></p><ul><li><p><code>Preamble</code> - Defined pattern of alternating 1 and 0 bits used <strong>to synchronize timing</strong>.<br>用于使NIC卡（接收NIC）与电缆上的位同步。</p></li><li><p><code>SFD</code> - Marks the end of the timing information and start of the frame. 向接收的网卡指示 重要的信息在此之后？？？</p></li><li><p><code>Destination MAC Address</code> - The Destination MAC Address field contains the destination MAC address [receiver]. The destination MAC address can be unicast 单播 （a specific host）, multicast 多播 （a group of hosts）, or broadcast 广播 （all hosts on the local network）.（什么意思？？）</p></li><li><p><code>Source MAC Address</code> - The Source MAC Address field contains the source MAC address （sender）. This is the unicast address of the Ethernet host that transmitted the frame.</p></li><li><p><code>Length / Type</code> - The Length/Type field supports two different uses. A type value indicates which protocol will receive the data. The length indicates the number of bytes of data that follows this field.</p></li><li><p><code>Encapsulated Data</code> - The Data field contains the packet of information being sent. Ethernet requires each frame to be between 64 and 1518 bytes.（虚拟局域网可达1522字节，此处不做讨论）</p></li><li><p><code>FCS</code> - The FCS contains a 4-byte value that is created by the device that sends data and is recalculated by the destination device to check for damaged frames.</p></li></ul><p><strong>维基百科：</strong> <a href="https://zh.wikipedia.org/wiki/%E5%8D%8F%E8%AE%AE%E6%95%B0%E6%8D%AE%E5%8D%95%E5%85%83" target="_blank" rel="noopener">PDU维基百科</a> </p><pre><code>在OSI模型系统里，PDU和最底下四层相关。物理层（一层）PDU指数据位（Bit）。数据链路层（二层）PDU指数据帧（Frame）。网络层（三层）PDU指数据包（Packet）。传输层（四层）PDU指数据段（Segment）。</code></pre><hr><h2 id="2-The-Building-Blocks-of-Ethernet-Networks"><a href="#2-The-Building-Blocks-of-Ethernet-Networks" class="headerlink" title="2. The Building Blocks of Ethernet Networks"></a>2. The Building Blocks of Ethernet Networks</h2><h3 id="2-1-Reading-Why-Networks-Need-Hierarchical-Design？？？"><a href="#2-1-Reading-Why-Networks-Need-Hierarchical-Design？？？" class="headerlink" title="2.1 Reading: Why Networks Need Hierarchical Design？？？"></a>2.1 Reading: Why Networks Need Hierarchical Design？？？</h3><p>问题导向型学习！</p><blockquote><p>Imagine how difficult communication would be if the only way to send a message to someone was to use the person’s name. If there were no street addresses, cities, towns, or country boundaries, delivering a message to a specific person across the world would be nearly impossible.</p></blockquote><p>如果发消息给某人的唯一方式是使用某人的姓名，没有街道地址、城市、乡镇、国界，那在世界间相互通信将会成为一件很困难的事。</p><blockquote><p>On an Ethernet network, the host MAC address is similar to a person’s name. A MAC address indicates the individual identity of a specific host, but it does not indicate where on the network the host is located. If all hosts on the Internet （millions and millions of them） were each identified by only their unique MAC address, imagine how difficult it would be to locate a single one.</p></blockquote><p><strong>Reason 1：</strong> 在以太网网络中，主机的MAC地址类似于一个人的姓名。用来辨认特定主机的身份信息，但是它并不能指示网络中这个主机的位置所在。因此，如果网络上的主机只通过MAC地址来辨别的话， 定位一台主机的位置将十分困难。</p><blockquote><p>Additionally, Ethernet technology generates a large amount of broadcast traffic in order for hosts to communicate. Broadcasts are sent to all hosts within a single network. Broadcasts consume bandwidth and slow network performance. What would happen if the millions of hosts attached to the Internet were all in one Ethernet network and were using broadcasts?</p></blockquote><p><strong>Reason 2：</strong> 以太网技术为了寻找主机进行通信会产生大量广播流量。广播既消耗带宽也会降低网络表现。因此，所有连接到网络上的主机都在一个以太网环境下并都使用广播进行通信 <strong>这是不现实的！</strong></p><blockquote><p>For these two reasons, large Ethernet networks consisting of many hosts are not efficient. It is better to divide larger networks into smaller, more manageable pieces. One way to divide larger networks is to use a hierarchical design model.</p></blockquote><p>因此，使用分层设计模型来划分大型网络更为高效，便于管理。</p><p>View the set of graphics below to see an example of how our physical addresses are part of a hierarchical design that is divided into smaller, more manageable pieces.</p><p><img src="http://static.zybuluo.com/Adward-Wang/whf3vwhjhs6riun3ap0bb6v1/Country_Boundries.gif" alt="Country_Boundries"></p><h3 id="2-2-Benefits-of-a-Hierarchical-Design"><a href="#2-2-Benefits-of-a-Hierarchical-Design" class="headerlink" title="2.2 Benefits of a Hierarchical Design"></a>2.2 Benefits of a Hierarchical Design</h3><blockquote><p>In networking, hierarchical design is used to group devices into multiple networks that are organized in a layered approach. This method of designing networks consists of smaller, more manageable groups that allow local traffic to remain local. Only traffic that is destined for other networks is moved to a higher layer.</p></blockquote><p>分层设计将设备分组到以分层方式组织的多个网络中。这种设计网络的方法由更小、更易于管理的组组成。这些组<strong>允许本地流量留在本地，只有那些发送到其他网络的流量才会被转发到更高的层次</strong>。</p><p>分层设计提高效率、优化功能、提高速度。可以根据需要扩展网络，在不影响现有网络性能的前提下添加额外的本地网络。</p><p>分层设计有三个基本层次：</p><blockquote><ul><li>Access Layer – This layer provides connections to hosts in a local Ethernet network.</li><li>Distribution Layer – This layer interconnects the smaller local networks.</li><li>Core Layer – This layer provides a high-speed connection between distribution layer devices.</li></ul></blockquote><p>访问层 —— 提供到本地以太网网络中的主机的连接<br>分布层 —— 将较小的本地网络互联<br>核心层 —— 提供分布层设备间的高速连接</p><blockquote><p>With a hierarchical design, there is a need for a logical addressing scheme that can identify the location of a host. The most common addressing scheme on the Internet is Internet Protocol version 4 （IPv4）. Internet Protocol version 6 （IPv6） is the network layer protocol currently being implemented as a replacement to IPv4. IPv4 and IPv6 will coexist for the foreseeable future. From this point on in this course, the term IP will refer to both IPv4 and IPv6.</p></blockquote><p>在分层设计中，需要一种能够<strong>识别主机位置</strong>的<strong>逻辑寻址方案</strong>。Internet上最常见的寻址方案是Internet协议版本4 （IPv4）。Internet协议版本6 （IPv6）是目前正在实现的<strong>网络层协议</strong>，作为IPv4的替代品。在可预见的未来，IPv4和IPv6将会<strong>共存</strong>。从这一点在本课程中，术语IP将指IPv4和IPv6。</p><pre><code>Q：网络中的位置还是实际的物理位置？？？</code></pre><p><strong>维基百科：</strong> <a href="https://en.wikipedia.org/wiki/Hierarchical_internetworking_model" target="_blank" rel="noopener">分层网络模型</a></p><p><img src="http://static.zybuluo.com/Adward-Wang/ehbivjlohtm8lus1cv0n3hku/Layer.jpg" alt="Layer"></p><hr><h2 id="3-Logical-Addressing"><a href="#3-Logical-Addressing" class="headerlink" title="3. Logical Addressing"></a>3. Logical Addressing</h2><h3 id="3-1-Physical-amp-Logical-Addresses"><a href="#3-1-Physical-amp-Logical-Addresses" class="headerlink" title="3.1 Physical &amp; Logical Addresses"></a>3.1 Physical &amp; Logical Addresses</h3><blockquote><p>A person’s name usually does not change. A person’s address on the other hand, relates to where they live and can change. On a host, the MAC address does not change; it is physically assigned to the host NIC and is known as the physical address. The physical address remains the same regardless of where the host is placed on the network.</p></blockquote><p>一个人的姓名通常不会改变，而一个人的地址通常与他们所居住的地方相关而且会改变。在主机上，MAC地址（物理地址）不会改变，他被物理地分配到主机的网卡上。无论主机被放置在网络的何处，物理地址始终不变。</p><blockquote><p>The IP address is similar to the address of a person. It is known as a logical address because it is assigned logically based on where the host is located. The IP address, or network address, is assigned to each host by a network administrator based on the local network.</p></blockquote><p>IP 地址（逻辑地址）则类似于你的地址，因为它基于你主机的位置来进行分配。IP地址，或者说网络地址，由本地网络的网络管理员来分配给每个主机。</p><blockquote><p>IP addresses contain two parts. One part identifies the local network. The network portion of the IP address will be the same for all hosts connected to the same local network. The second part of the IP address identifies the individual host. Within the same local network, the host portion of the IP address is unique to each host.</p></blockquote><p>IP 地址包含两个部分。一部分用来标识本地网络。IP地址的<strong>网络部分</strong>对于连接到相同本地网络的所有主机来说都是相同的。第二部分用来标识单个主机，在相同的本地网络环境下，IP地址的<strong>主机部分</strong>都是唯一的。</p><blockquote><p>Both the physical MAC and logical IP addresses are required for a computer to communicate on a hierarchical network, just like both the name and address of a person are required to send a letter.</p></blockquote><p>计算机在分层网络中进行通信，物理地址和逻辑地址都是必需的。就像写信一样，需要一个人姓名和地址。</p><p>观察下图:</p><p><img src="http://static.zybuluo.com/Adward-Wang/fuuw2vb1gx01mkbaq76vlcxq/Physical_Logical_Address.jpg" alt="Physical_Logical_Address"></p><blockquote><p>假设 我们将数据包从H3发送到H8，它将使用IPv4地址进行通信。源IP地址为 192.168.200.3 ，目标地址为192.168.1.4.这些地址是保持不变的（通信过程中改变了怎么办？？）。<br>那么MAC地址有什么用呢？目标MAC地址用于传送封装的数据包，以太网帧从H3到路由器。以太网帧携带的IPv4数据包有一个H3网卡相关联的源MAC地址。<strong>目的MAC地址将是该网络上路由器接口的MAC地址</strong>。一旦数据包在以太网帧中被送到路由器中，路由器将会移除以太网帧。之后它将会查看数据包中的目标IPv4地址，在路由表中查找。并将该数据包<strong>转发</strong>到另一个192.168.1.0网络。它将被封装在新的以太网帧中。源MAC地址将是路由器的以太网接口，目标MAC。该地址将是主机H8的NIC卡的地址。<strong>这里的关键是IP地址。</strong> 数据包中的目标IPv4地址始终保持不变。而以太网中的MAC则会随着网络的变化而变化（因为设备变化了呀）。<br>对于网络专业人员，重要的是要了解逻辑地址用于端到端传递，以及如何在网络中使用物理地址（在本例中为以太网MAC地址）进行传递。</p></blockquote><blockquote><p>挺有意思的，IP地址是不断变化的，因为由网络管理员进行分配，定时更换。同时，他也是固定的，在网络中发送数据包，源和目标IP地址固定。MAC地址正好相反。。。。</p></blockquote><h3 id="3-2-Video-Examining-Network-Information-on-My-Device"><a href="#3-2-Video-Examining-Network-Information-on-My-Device" class="headerlink" title="3.2 Video: Examining Network Information on My Device"></a>3.2 Video: Examining Network Information on My Device</h3><blockquote><p>查看网络IP配置</p></blockquote><hr><h2 id="4-Starting-with-a-Good-Design"><a href="#4-Starting-with-a-Good-Design" class="headerlink" title="4. Starting with a Good Design"></a>4. Starting with a Good Design</h2><h3 id="4-1-Reading-Access-Distribution-and-Core"><a href="#4-1-Reading-Access-Distribution-and-Core" class="headerlink" title="4.1 Reading: Access, Distribution and Core"></a>4.1 Reading: Access, Distribution and Core</h3><blockquote><p>IP traffic is managed based on the characteristics and devices associated with each of the three layers of the hierarchical network design model: Access, Distribution and Core.</p></blockquote><blockquote><p>IP流量是根据与分层网络设计模型的三层中的每一层相关的特性和设备进行管理的：访问，分发和核心。</p></blockquote><blockquote><p><strong>Access Layer</strong><br>The access layer provides a connection point for end user devices to the network and allows multiple hosts to connect to other hosts through a network device, usually a switch or access point. Typically, all devices within a single access layer will have the same network portion of the IP address.</p></blockquote><blockquote><p>访问层提供终端设备到网络的连接，允许多个主机通过网络设备与其他主机互联，通常是一个交换机或者接入点。典型地，在单个访问层中的所有设备将会拥有相同的IP地址网络部分。</p></blockquote><blockquote><p>If a message is destined for a local host, based on the network portion of the IP address, the message remains local. If it is destined for a different network, it is passed up to the distribution layer. Switches provide the connection to the distribution layer devices, usually a router.</p></blockquote><blockquote><p>如果消息时发往本地主机，基于IP地址的网络部分，消息将留在本地。而如果消息发往其他网络，他将会去往分布层。交换机提供了到分布层设备（通常是路由器）的连接。</p></blockquote><blockquote><p><strong>Distribution Layer</strong><br>The distribution layer provides a connection point for separate networks and controls the flow of information between the networks. It typically contains more powerful switches than the access layer as well as routers for routing between networks. Distribution layer devices control the type and amount of traffic that flows from the access layer to the core layer.</p></blockquote><blockquote><p>分布层提供了各个独立网络的连接点，<strong>控制网络间信息的流动</strong>。它通常包含比访问层更强大的交换机。以及用于网络间路由的路由器。分布层设备<strong>控制了从访问层到核心层流量的类型和总量</strong>。</p></blockquote><blockquote><p>Core Layer<br>The core layer is a high-speed backbone layer with redundant (backup) connections. It is responsible for transporting large amounts of data between multiple end networks. Core layer devices typically include very powerful, high-speed switches and routers. The main goal of the core layer is to transport data quickly.</p></blockquote><blockquote><p>核心层是具有冗余？（备份）连接的告诉主干层。他负责在多个终端网络之间传输大量数据。核心层设备通常包括功能非常强大的高速交换机和路由器。核心层的主要目标是：<strong>快速传输数据</strong>。</p></blockquote><p>The figure below shows the devices most likely to be found in or associated with each layer.</p><p><img src="http://static.zybuluo.com/Adward-Wang/im8jpm85bz24gdcpedx55gwe/Access_Distribution_Core.jpg" alt="Access_Distribution_Core"></p><h3 id="4-2-Reading-Access-Layer-Devices"><a href="#4-2-Reading-Access-Layer-Devices" class="headerlink" title="4.2 Reading: Access Layer Devices"></a>4.2 Reading: Access Layer Devices</h3><p>略</p><h3 id="4-3-Reading-Ethernet-Hubs"><a href="#4-3-Reading-Ethernet-Hubs" class="headerlink" title="4.3 Reading: Ethernet Hubs"></a>4.3 Reading: Ethernet Hubs</h3><blockquote><p>最初的以太网以一条电缆连接所有主机，类似于有线电视连到你家的方式。网络中的所有用户<strong>共享带宽</strong>。</p></blockquote><blockquote><p>随着以太网变得流行，这种方案变得不切实际。工程师开发了一种不同类型的网络技术，使连接和重新连接多个设备到网络变得更容易。第一类网络设备是<strong>以太网集线器</strong>。</p></blockquote><blockquote><p>集线器包含多个端口集线器包含多个端口，这些端口用于将主机连接到网络。集线器是简单的设备，没有必要的电子设备来解码网络上主机之间发送的消息。集线器无法确定哪个主机应收到任何特定消息。集线器仅从一个端口接收电子信号，并在所有其他端口中重新生成（或重复）同一消息。集线器上连接的所有主机<strong>共享带宽</strong>，并且将接收到该消息。主机会忽略未发送给他们的消息。只有在消息的目标地址中指定的主机才能处理消息并响应发件人。</p></blockquote><blockquote><p><strong>一次只能通过以太网集线器发送一条消息</strong>。连接到集线器的两个或更多主机可能尝试同时发送消息。如果发生这种情况，组成消息的电子信号将在集线器上相互碰撞。这称为<strong>碰撞</strong>。主机无法读取该消息，必须重新传输。主机可以接收冲突产生的乱码消息的网络区域称为<strong>冲突域</strong>。由于过多的重传会阻塞网络并降低网络流量，因此现在认为<strong>集线器已过时</strong>，<strong>并且已被以太网交换机取代!!!</strong>。</p></blockquote><p>观看下面的动画，了解设备如何处理使用集线器的网络上广播的信息。</p><p><img src="http://static.zybuluo.com/Adward-Wang/q2i2l3punkfeu49nmg6tfgmd/Ethernet_Hubs.gif" alt="Ethernet_Hubs"></p><h4 id="拓展"><a href="#拓展" class="headerlink" title="拓展"></a>拓展</h4><p><a href="https://zhidao.baidu.com/question/7307966.html" target="_blank" rel="noopener">集线器和交换机的区别</a></p><hr><h2 id="5-Building-a-Better-Access-Layer"><a href="#5-Building-a-Better-Access-Layer" class="headerlink" title="5. Building a Better Access Layer"></a>5. Building a Better Access Layer</h2><h3 id="5-1-Ethernet-Switches"><a href="#5-1-Ethernet-Switches" class="headerlink" title="5.1 Ethernet Switches"></a>5.1 Ethernet Switches</h3><blockquote><p>以太网交换机通常被用于接入层。当一个主机发送消息到连接在同一个交换机网络中的其他主机时，交换机接收并解码以太网帧，读取MAC地址部分。</p></blockquote><blockquote><p>交换机内有一个MAC地址表，包含了一连串的<strong>激活端口</strong>以及连接到它们的<strong>主机MAC地址</strong>。当消息在主机间发送时，交换机检查目的MAC地址是否在表中。如果在，交换机将会在源端口和目标端口间建立一个称为电路的临时连接。 这个新电路提供了两个主机可以通过其通信的专用通道。连接到交换机的其他主机不在此通道上共享带宽，也不会接受未寻址到它们的消息。<strong>主机之间的每个新会话都会建立一个新电路。</strong>这些独立的电路允许多对话同时发生，<strong>且不会发生冲突</strong>！以太网交换机还<strong>允许通过同一根以太网电缆同时发送和接收帧</strong>。通过消除冲突，可以提高网络的性能。</p></blockquote><p><img src="http://static.zybuluo.com/Adward-Wang/s3j4k9vd3sssk5srs1i9n6ti/Ethernet_Switches.jpg" alt="Ethernet_Switches"></p><h3 id="5-2-MAC-Address-Tables"><a href="#5-2-MAC-Address-Tables" class="headerlink" title="5.2 MAC Address Tables"></a>5.2 MAC Address Tables</h3><blockquote><p>Q: 如果交换机收到一条帧指向一个未在MAC地址表中记录的新主机怎么办呢？？？</p></blockquote><blockquote><p>A：如果MAC地址表中无记录的话，交换机没有足够的信息去创建单独的电路。而当交换机无法决定目的主机所在时，它将使用一种称为<strong>泛洪</strong>的进程将消息转发到除发送主机之外的所有附加主机。每个主机将消息中的目标MAC地址与它自己的MAC地址进行比较，但是只有具有正确目标地址的主机才能处理消息并响应发送方。</p></blockquote><blockquote><p>新主机的MAC地址如何进入MAC地址表呢？交换机通过检查主机之间发送的每个帧的<strong>源MAC地址</strong>来构建MAC地址表。当新的主机发送消息或者响应泛洪消息时，交换机会立即获知其MAC地址和其连接的端口（端口已知的，先看看<strong>源MAC地址</strong>在不在MAC地址表里，若不在，添加到端口对应的MAC地址栏）。（牛啤）每次交换机读取新的源MAC地址时，该表都会<strong>动态更新</strong>。通过这种方式，交换机可以快速了解所有连接的主机的MAC地址。</p></blockquote><pre><code>Q： 添加的都是源MAC地址？</code></pre><blockquote><p>观看以下动画来了解交换机中的MAC地址表以及交换机如何获取新的主机。</p></blockquote><p><img src="http://static.zybuluo.com/Adward-Wang/92n85cbmoacmjyzqhd2bv9hh/MAC_Table.gif" alt="MAC_Table"></p><p>PS ： 交换机转发消息 在 数据链路层。</p><pre><code>Q： 以太网帧将目标地址放在前面是为了便于广播比较吗？</code></pre><p><strong>参考视频：</strong> <a href="https://www.coursera.org/learn/network-protocols-architecture/lecture/FbWVT/mac-address-tables" target="_blank" rel="noopener">交换机如何创建MAC地址表：三种可能的转发情况</a></p><hr><h2 id="6-Containing-Broadcasts"><a href="#6-Containing-Broadcasts" class="headerlink" title="6. Containing Broadcasts"></a>6. Containing Broadcasts</h2><h3 id="6-1-What-are-Broadcasts-Anyway"><a href="#6-1-What-are-Broadcasts-Anyway" class="headerlink" title="6.1 What are Broadcasts Anyway?"></a>6.1 What are Broadcasts Anyway?</h3><blockquote><p>当主机需要查找信息而又不确切地知道其他主机可以提供什么信息，或者主机希望及时向同一网络中的所有其他主机提供信息时，广播会非常有用。</p></blockquote><blockquote><p><strong>Q：</strong> 一条消息只能包含一个目标MAC地址，那么对于一个主机来说，怎么才能够在不向每个单独的MAC发送单独消息的情况下与本地网络上的所有其他主机进行通信呢？？？（好问题啊！！！）</p></blockquote><blockquote><p>为了解决这一问题，广播消息将会发送到所有主机都可以识别的唯一MAC地址。广播MAC地址实际上是由<strong>全1组成的48位地址</strong>。而由于MAC地址的长度，通常用十六进制表示。十六进制表示形式的广播MAC地址为 FFFF.FFFF.FFFF</p></blockquote><p><img src="http://static.zybuluo.com/Adward-Wang/7t8qnu15ym75fz2hq7pe8hrr/Broadcast.gif" alt="Broadcast"></p><pre><code>PS: 路由器不会转发广播</code></pre><h3 id="6-2-Broadcast-Domains"><a href="#6-2-Broadcast-Domains" class="headerlink" title="6.2 Broadcast Domains"></a>6.2 Broadcast Domains</h3><blockquote><p>When a host receives a message addressed to the broadcast address, it accepts and processes the message as though the message was addressed directly to it. When a host sends a broadcast message, switches forward the message to every connected host within the same local network. For this reason, a local area network, a network with one or more Ethernet switches, is also referred to as a broadcast domain.</p></blockquote><p>当主机接收到该广播地址的消息时，它将接收并处理该消息，就好像该消息被直接寻址到它一样。当主机发送广播消息时，交换机负责转发给局域网内每个已连的主机。因此，<strong>局域网（具有一个或多个以太网交换机的网络）</strong>也被称为<strong>广播域</strong>。</p><blockquote><p>If too many hosts are connected to the same broadcast domain, broadcast traffic can become excessive. The number of hosts and the amount of network traffic that can be supported on the local network is limited by the capabilities of the switches used to connect them. As the network grows and more hosts are added, network traffic, including broadcast traffic, increases. To improve performance, it is often necessary to divide one local network into multiple networks, or broadcast domains, as shown in the figure. Routers are used to divide the network into multiple broadcast domains.</p></blockquote><p>如果太多主机o连接到同一广播域，则广播流量可能会变得过多。本地网络上可以支持的主机和网络流量受连接它们的交换机功能的限制。随着网络的增长和更多主机的添加，包括广播流量在内的网络流量将增加。为了提高性能，通常需要将一个局域网划分为多个网络或者说广播域，如图所示，<strong>路由器用于将网络划分为多个广播域</strong>。</p><p><img src="http://static.zybuluo.com/Adward-Wang/3jijw1oex84k9jhfm8f4film/Broadcast_Domains.jpg" alt="Broadcast_Domains"></p><h3 id="6-3-Communicating-at-the-Access-Layer"><a href="#6-3-Communicating-at-the-Access-Layer" class="headerlink" title="6.3 Communicating at the Access Layer"></a>6.3 Communicating at the Access Layer</h3><blockquote><p>在本地以太网上，如果目标地址是广播MAC地址，或者与NIC的MAC地址相对应，那么NIC则接受该帧。</p></blockquote><blockquote><p>但是，大多数网络应用程序都依靠逻辑目标IP地址来标识服务器和客户端的位置。下图说明了如果发送主机仅具有目标主机的逻辑IP地址会出现的问题。发送主机如何确定要在帧中放置哪个目标MAC地址呢？？？</p></blockquote><p><img src="http://static.zybuluo.com/Adward-Wang/53cdkbmqu9ajtcnp2lnhcbn3/Communicating_on_the_Access_Layer.jpg" alt="Communicating_at_the_Access_Layer"></p><blockquote><p>发送主机可以使用称为<strong>地址解析协议（ARP）</strong> 的IPv4协议来发现<strong>同一本地网络上</strong>任何主机的MAC地址。IPv6则使用一种称为<strong>邻居发现</strong>的类似方法。</p></blockquote><h3 id="6-4-How-ARP-Works"><a href="#6-4-How-ARP-Works" class="headerlink" title="6.4 How ARP Works"></a>6.4 How ARP Works</h3><blockquote><p>ARP uses a three step process to discover and store the MAC address of a host on the local network when only the IPv4 address of the host is known.<br>当只知道主机的IPv4地址时，ARP使用三个步骤来发现并存储局域网上的主机MAC地址。</p></blockquote><blockquote><ul><li>The sending host creates and sends a frame addressed to a broadcast MAC address. Contained in the frame is a message with the IPv4 address of the intended destination host.<br>发送主机创建并发送一个寻址到广播MAC地址的帧。帧内部有包含目标主机的IPv4地址的消息。</li></ul></blockquote><blockquote><ul><li>Each host on the network receives the broadcast frame and compares the IPv4 address inside the message with its configured IPv4 address. The host with the matching IPv4 address sends its MAC address back to the original sending host.<br>网络上的每个主机接收广播帧，并将消息内的IPv4地址与其配置的IPv4地址进行比较。相匹配的主机将其MAC地址发送回原始发送主机。</li></ul></blockquote><blockquote><ul><li>The sending host receives the message and stores the MAC address and IPv4 address information in a table called an ARP table.<br>发送主机接收消息并将MAC地址和IPv4地址信息存储在一个名为<strong>ARP表</strong>的表中。</li></ul></blockquote><blockquote><p>When the sending host has the MAC address of the destination host in its ARP table, it can send frames directly to the destination without doing an ARP request. Because ARP messages rely on broadcast frames to deliver the requests, all hosts in the local IPv4 network must be in the same broadcast domain.</p></blockquote><blockquote><p>当发送主机在其路由表中有目标主机的MAC地址时，它就能直接将数据帧发送给目标主机而不需要做ARP请求。因为ARP消息依赖于广播帧来发送请求，本地IPv4网络中的所有主机必须在同一个广播域内。</p></blockquote><p>Watch the animation below to see a simplified example of the ARP process.</p><p><img src="http://static.zybuluo.com/Adward-Wang/bwjjcoo214s49prz00vfi3dm/ARP.gif" alt="How ARP Works"></p><pre><code>PS：路由器不会对以太网广播进行转发，ARP请求保留在本地网络中。</code></pre><hr>]]></content>
      
      
      <categories>
          
          <category> 计算机网络 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 网络基础 </tag>
            
            <tag> Cisco </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Internet Connection —— How to Get Online?</title>
      <link href="/2020/05/31/internet-connection-how-to-get-online/"/>
      <url>/2020/05/31/internet-connection-how-to-get-online/</url>
      
        <content type="html"><![CDATA[<h2 id="1、Week1-Communicating-in-a-Connected-World"><a href="#1、Week1-Communicating-in-a-Connected-World" class="headerlink" title="1、Week1:  Communicating in a Connected World"></a>1、Week1:  Communicating in a Connected World</h2><h3 id="1-1-Reading-About-This-Course"><a href="#1-1-Reading-About-This-Course" class="headerlink" title="1.1 Reading: About This Course"></a>1.1 Reading: About This Course</h3><p><strong>挑重点记录！！！</strong><br><strong>学习目标：</strong></p><blockquote><p>At the end of this course, you will be able to:</p></blockquote><blockquote><ul><li>Explain how data networks work.</li><li>Define basic data networking terms.</li><li>Explain what is needed for devices to have network connectivity or Internet access.</li><li>Use the Cisco Packet Tracer simulation and modeling tool to build and test a small data network.</li><li>Identify the devices and component on your home network.</li><li>Build a simple peer-to-peer network.</li></ul></blockquote><h3 id="1-2-Different-Type-of-Networks"><a href="#1-2-Different-Type-of-Networks" class="headerlink" title="1.2 Different Type of Networks"></a>1.2 Different Type of Networks</h3><p>The Internet is considered a <strong>“network of networks”</strong> because it is literally made up of thousands of local networks that are connected to each other.</p><p><img src="http://static.zybuluo.com/Adward-Wang/2hzjiy0ruq39hwr9rx6p0761/Small_Home_Networks.jpg" alt="Small_Home_Networks"></p><blockquote><p>Small home networks connect a few computers to each other and the Internet.</p></blockquote><p><img src="http://static.zybuluo.com/Adward-Wang/v5po95wet5p6xmh7derqnqf2/Small_Office_Home_Office.jpg" alt="Small_Office/Home_Office"></p><blockquote><p>Small Office/Home Office or SOHO network enables computers within a home office or a remote office to connect to a corporate network or access centralized, shared resources.</p></blockquote><p><img src="http://static.zybuluo.com/Adward-Wang/yegv8cql2qwntec8yfcdx4w7/Medium2Large_Networks.jpg" alt="Medium2Large_Networks"></p><blockquote><p>Medium to large networks, such as those used by corporations and schools, can have many locations with hundreds or thousands of interconnected computers.</p></blockquote><p><img src="http://static.zybuluo.com/Adward-Wang/3rmnc3ntmvvln39nm2jg62ei/World_Wide_Networks.jpg" alt="World_Wide_Networks"></p><blockquote><p>The Internet is a network of networks that connects hundreds of millions of computers world-wide.</p></blockquote><h3 id="1-3-Data-on-the-Network"><a href="#1-3-Data-on-the-Network" class="headerlink" title="1.3 Data on the Network"></a>1.3 Data on the Network</h3><p>网络上的所有数据都将以特定的格式转化为比特为进行存储（ASCII码）。<br>人类解释文字和图片，而计算机与网络也只会处理二进制位。</p><blockquote><p>Every input device (mouse, keyboard, voice-activated receiver) will translate human interaction into binary code for the CPU to process and store. Every output device (printer, speakers, monitors, etc.) will take binary data and translate it back into human recognizable form. Within the computer itself, all data is processed and stored as binary.<br>Computers use binary codes to represent and interpret letters, numbers and special characters with bits.<br>A commonly used code is the American Standard Code for Information Interchange <strong>(ASCII)</strong>. With ASCII, each character is represented by eight bits. </p></blockquote><pre><code>For example:    Capital letter: A = 01000001    Number: 9 = 00111001    Special character: # = 00100011</code></pre><h3 id="1-4-Getting-Bits-Moving"><a href="#1-4-Getting-Bits-Moving" class="headerlink" title="1.4 Getting Bits Moving"></a>1.4 Getting Bits Moving</h3><blockquote><p>在数据被转化为一系列的比特位后，它还必须被转化能够通过网络媒体进行传输的信号。<br>媒体有铜线、光纤电缆、以及空气中的电磁波。信号由点或者光模式组成，从一个连接的设备传送到另一个设备。<br>这些模式代表数字位（即数据），并以一系列电脉冲，光脉冲或无线电波的形式从源到目的地跨媒体传播。<br>而信号在到达最终目的地之前可能会被转换多次，因为相应的媒体在源和目的地之间会发生变化。</p></blockquote><p>网络中信号传输有三种常用方法：</p><ul><li>电信号： 将数据转化为电脉冲通过铜线传输</li><li>光信号： 将电信号转化为光脉冲</li></ul><pre><code>     Q： 不能直接将数据转化为光脉冲吗？？？</code></pre><ul><li>无线信号： 使用红外线、微波或者无线电通过<strong>空气</strong>实现传播</li></ul><p>小型网络环境一般使用铜线或者无线进行网络通信，而大型网络一般使用光纤进行可靠的远距离通信。</p><p><img src="http://static.zybuluo.com/Adward-Wang/owcqacpdrxwvbfat4rsi44l6/Three_signals.gif" alt="Three_signals"></p><h3 id="1-5-速度相关概念"><a href="#1-5-速度相关概念" class="headerlink" title="1.5 速度相关概念"></a>1.5 速度相关概念</h3><p>使用   speedtest.net 测试带宽<br><strong>Throughput</strong> is the amount of data sent and received over a connection, including any delays that might occur.<br><strong>Bandwidth</strong> is the capacity of a medium to carry data. （theoretically）</p><h3 id="1-6-网络组件"><a href="#1-6-网络组件" class="headerlink" title="1.6 网络组件"></a>1.6 网络组件</h3><p>现代网络中，计算机主机可以是客户端、服务器或者两者皆是。</p><blockquote><p>The software installed on the computer determines which role the computer plays.</p></blockquote><blockquote><p><strong>Servers</strong> are hosts that have software installed that enable them to provide information, like email or web pages, to other hosts on the network.</p></blockquote><p>每个服务都要求独立的服务器软件。例如，主机需要web服务器软件才能向网络提供web服务。 在网上所访问的每个服务都是由连接到全球Internet的网络上某个位置的服务器提供的。</p><blockquote><p><strong>Clients</strong> are computer hosts that have software installed that enable them to request and display the information obtained from the server. An example of client software is a web browser, such as Internet Explorer, Safari, Mozilla Firefox, or Chrome.</p></blockquote><p><img src="http://static.zybuluo.com/Adward-Wang/3p6dw1uxzlvp1j9wdkq30gne/Client_Server.jpeg" alt="Client_Server"></p><pre><code>The File Server stores corporate end-user files in a central location. The client devices access these files with client software such as Windows Explorer.The Web Server runs web server software and clients use their browser software, such as Windows Internet Explorer, to access web pages on the server.The Email Server runs email server software and clients use their mail client software, such as Microsoft Outlook, to access email on the server.</code></pre><h3 id="1-7-网络基础设施"><a href="#1-7-网络基础设施" class="headerlink" title="1.7 网络基础设施"></a>1.7 网络基础设施</h3><p>网络基础设施包含三类硬件：</p><ul><li>中间设备</li><li>终端设备</li><li>网络媒介</li></ul><p><img src="http://static.zybuluo.com/Adward-Wang/vw9ye7adtxk9isuhz256bskg/Examples_of_Intermediate_Devices.png" alt="Examples_of_Intermediate_Devices"></p><p><img src="http://static.zybuluo.com/Adward-Wang/fk0cwxmiw997jv0syvgqim00/Examples_of_End_Devices.jpg" alt="Examples_of_End_Devices"></p><p><img src="http://static.zybuluo.com/Adward-Wang/nw29dsgubzv8mzhk4sn6asro/Examples_of_Network_Media.jpg" alt="Examples_of_Network_Media"></p><p><strong>终端设备（主机）：</strong></p><blockquote><p>形成用户和底层通信网络之间的接口。</p></blockquote><blockquote><p>In order for the intended recipient to receive the message, devices in the network must be uniquely identified. In networks, this is done by assigning each host a unique address. In most networks today, an <strong>IP address</strong> is used. When a host initiates communication, it uses the address of the destination host to specify where the message should be sent.</p></blockquote><p><img src="http://static.zybuluo.com/Adward-Wang/1nff4encbv15xg6rvb4wmzup/data_flowing.gif" alt="data_flowing"></p><h2 id="2、Week2-Getting-Online"><a href="#2、Week2-Getting-Online" class="headerlink" title="2、Week2: Getting Online"></a>2、Week2: Getting Online</h2><h3 id="2-1、-手机通信"><a href="#2-1、-手机通信" class="headerlink" title="2.1、 手机通信"></a>2.1、 手机通信</h3><blockquote><p>手机使用 <strong>无线电</strong> 将声音信号传送到位于特定地理区域的发射塔的天线上。当打电话时，声音信号从一个塔传到另一个塔，直到传送到目的地。它还可以直接从手机发送短信。最常见的移动电话网络称为GSM网络，是“全球移动通信系统”的缩写。</p></blockquote><h3 id="2-2-不同类型的网络（通信即网络？）"><a href="#2-2-不同类型的网络（通信即网络？）" class="headerlink" title="2.2 不同类型的网络（通信即网络？）"></a>2.2 不同类型的网络（通信即网络？）</h3><p>除了GSM 和3G/4G 网络以外，智能手机还可以连接到一些其他类型的网络。</p><ul><li>GPS 全球定位系统 使用卫星发射信号，手机接收到这些信号并计算出手机的当前位置（误差一般在十米之内）</li><li>Wi-Fi </li><li>蓝牙</li><li>NFC（Near Field Communication）让数据在极短的距离间进行通信（几厘米）</li></ul><h3 id="2-3-网络组件的类型"><a href="#2-3-网络组件的类型" class="headerlink" title="2.3 网络组件的类型"></a>2.3 网络组件的类型</h3><blockquote><ol><li>Hosts 主机</li><li>Peripherals 外围设备（外设）</li><li>Networking devices 网络设备（即中间设备）</li><li>Network media 网络媒介</li></ol></blockquote><p><strong>Hosts</strong> are any devices that send and receive messages directly across the network.（与网络直接通信）</p><p><img src="http://static.zybuluo.com/Adward-Wang/ymyab42b07e3hq0omxne9nd7/Hosts.png" alt="Hosts"></p><p><strong>共享外设</strong> 不与网络直接相连，而是连接到主机。主机负责跨网络共享外设。主机上配置了软件，使网络上的用户能够使用外设。</p><p><img src="http://static.zybuluo.com/Adward-Wang/jy6bixf318m5yy7t3nnq4v32/Peripherals.png" alt="Peripherals"></p><p><strong>网络设备</strong> 与网络媒介都用于互连主机，网络设备也叫做“中间设备”，因为他通常位于消息在源主机和目标主机之间所经过的路径上。</p><p><img src="http://static.zybuluo.com/Adward-Wang/kqzkne0gu8yz6gtv6lvg98h3/Network_Devices.png" alt="Network_Devices"></p><p><strong>网络媒介</strong> 描述了有线网络中使用的电缆、电线，以及无线网络中使用的无线电。而这些有线和无线网络提供了各种网络组件之间的消息传播路径。</p><p><img src="http://static.zybuluo.com/Adward-Wang/3zo59mc0y38y7cvsf727mxze/Network_Media.png" alt="Network_Media"></p><blockquote><p><code>注意：</code>一些设备可以扮演不只一种角色，这取决于它们是如何连接到网络的。举个例子： 一台直接连到主机上的打印机是个 <strong>外设</strong>，而一台直接连接到网络设备并直接参与网络通信的打印机是一个 <strong>主机</strong>。</p></blockquote><hr><h4 id="拓展"><a href="#拓展" class="headerlink" title="拓展"></a>拓展</h4><p><strong>以太网</strong> 是局域网中常用的技术，后来在1983年标准化为 <strong>IEEE 802.3</strong>。 设备都使用以太网网络接口卡（NIC）来访问网络。每个以太网卡都有一个永久嵌入在网卡上的唯一地址，称为媒体访问控制地址（即MAC地址、物理地址）.</p><p><strong>网络图</strong> 分为物理拓扑图与逻辑拓扑图</p><p><strong>物理拓扑图</strong> 显示各种设备如何相连的，显示了设备的位置，所插入的交换机、连接到因特网的路由器以及各个主机的连接方式。如图所示：</p><p><img src="http://static.zybuluo.com/Adward-Wang/g5nyly3osaddyvw4g6hkkblx/Physical_Topology.jpg" alt="Physical_Topology"></p><p><strong>逻辑拓扑图</strong> 更关心如何处理网络的各个区域，以及如何到达这些区域。还显示在网络的不同区域使用的不同协议类型。</p><p>如图所示，显示了每个建筑的IP地址，显示它们通过以太网连接。</p><p><img src="http://static.zybuluo.com/Adward-Wang/2zohik3y089tdqo5b9v1tlnk/Logical_Topology.jpg" alt="Logical_Topology"></p><h3 id="2-4-连接终端设备"><a href="#2-4-连接终端设备" class="headerlink" title="2.4 连接终端设备"></a>2.4 连接终端设备</h3><blockquote><p>为了物理连接到网络,终端用户必须具有网卡。网卡(NIC)是使设备能够连接到有线或无线网络媒介的硬件。它可以集成到主板中，也可以单独安装。</p></blockquote><blockquote><p>除了物理连接外，要让设备连接到网络，还需要对操作系统进行配置。终端设备需要IP地址和其他信息，以便在网络中将其识别。<br>如图，IP配置的三个部分必须正确，设备才能在网络上发送和接收信息。</p></blockquote><ul><li>IP地址 - 标识网络上的主机</li><li>子网掩码 - 用于标识主机所连接的网络</li><li>默认网关 - 标识主机用来访问Internet或另一个远程网络的<strong>网络设备</strong></li></ul><p><img src="http://static.zybuluo.com/Adward-Wang/98s0i4tmkfvw9w7r4y300yqn/Addressing_End_Devices.jpg" alt="Addressing_End_Devices"></p><h3 id="2-5-在Windows-上配置IP地址"><a href="#2-5-在Windows-上配置IP地址" class="headerlink" title="2.5 在Windows 上配置IP地址"></a>2.5 在Windows 上配置IP地址</h3><p><img src="http://static.zybuluo.com/Adward-Wang/ckguxkvjak95iudfax3q4mmw/%E7%BD%91%E7%BB%9C%E5%92%8C%E5%85%B1%E4%BA%AB%E4%B8%AD%E5%BF%83.png" alt="网络和共享中心"></p><p><img src="http://static.zybuluo.com/Adward-Wang/mnjpbhw61rsl9agacrxrhxbv/%E7%BD%91%E7%BB%9C%E8%BF%9E%E6%8E%A5.png" alt="网络连接"></p><p><img src="http://static.zybuluo.com/Adward-Wang/3gul8r5uz4yy4wo9vhdon3hz/%E6%9C%AC%E5%9C%B0%E8%BF%9E%E6%8E%A5%E5%B1%9E%E6%80%A7.png" alt="本地连接属性"></p><p><img src="http://static.zybuluo.com/Adward-Wang/bef5plphsyupl2izdbndm52k/IPv4%E9%85%8D%E7%BD%AE.png" alt="IPv4配置"></p><blockquote><p>大多数情况下，都可以选择自动获取地址，即从DHCP服务器获取信息。<br>但是，总有我们需要手动配置或者静态配置IPv4地址信息的时候。比如一个服务器、或者说一个打印机。</p></blockquote><p><img src="http://static.zybuluo.com/Adward-Wang/z3fwg7x932fpmp9px5b35nka/%E6%89%8B%E5%8A%A8%E9%85%8D%E7%BD%AEIP.PNG" alt="手动配置IP"></p><blockquote><p>在这里，我们将 IP 地址设为  192.168.1.100， 然后子网掩码保留默认的  255.255.255.0，大多数情况下你都可以将其设为默认， 默认网关 设为 192.168.1.1，这其实是我们的本地路由器IPv4地址，这是我们本地网络的出口，所有的消息将从这里发送到其他的网络。域名服务器地址，我们将其设为 8.8.8.8（谷歌提供）</p></blockquote><p><img src="http://static.zybuluo.com/Adward-Wang/rut25nkefyjqw9b4typisgve/Manual_Dynamic_IP_Configuration.jpg" alt="Manual_Dynamic_IP_Configuration"></p><blockquote><p>DHCP服务器 可以是独立服务器，也可以是路由器的一部分。大多数家庭路由器还装有DHCP服务器。它们同时执行<strong>路由任务</strong>，将数据包从网络转发到Internet服务提供商、到网络，它们同时也充当<strong>DHCP服务器</strong>。它们自动将IPv4地址信息提供给你的电脑和网络上的其他设备。同样，我们只想对那些必须始终具有相同IP地址信息的设备(如打印机或服务器)进行静态配置。</p></blockquote><hr><p><strong>拓展： ICMP</strong></p><blockquote><p>因特网控制消息协议（ICMP）是支持协议在因特网协议套件。网络设备（包括路由器）使用它来发送错误消息和操作信息，例如，这些信息和操作信息指示所请求的服务不可用或者无法访问主机或路由器。ICMP与TCP和UDP等传输协议的不同之处在于 ，它通常不用于在系统之间交换数据，也不被最终用户网络应用程序定期使用（除了ping和traceroute）。</p></blockquote><hr><h2 id="3、Week3-Exploring-Networks-with-Packet-Tracer"><a href="#3、Week3-Exploring-Networks-with-Packet-Tracer" class="headerlink" title="3、Week3: Exploring Networks with Packet Tracer"></a>3、Week3: Exploring Networks with Packet Tracer</h2><blockquote><p>主要介绍如何使用这个软件 以及两个仿真小lab, 不是很难。</p></blockquote><blockquote><p>主界面</p></blockquote><p><img src="http://static.zybuluo.com/Adward-Wang/rhssg903eq3qny3yj4ftesoy/Cisco_Packet_Tracer.jpg" alt="Cisco_Packet_Tracer"></p><blockquote><p>各部分功能介绍</p></blockquote><p><img src="http://static.zybuluo.com/Adward-Wang/bn2tqmw1tb7js4b8kdnwzm9f/PT_Function.png" alt="PT_Function"></p><hr><h2 id="4、Week4-Building-a-Simple-Peer-to-Peer-Networking（构建简单的点对点网络）"><a href="#4、Week4-Building-a-Simple-Peer-to-Peer-Networking（构建简单的点对点网络）" class="headerlink" title="4、Week4: Building a Simple Peer-to-Peer Networking（构建简单的点对点网络）"></a>4、Week4: Building a Simple Peer-to-Peer Networking（构建简单的点对点网络）</h2><h3 id="4-1-什么是网络媒介"><a href="#4-1-什么是网络媒介" class="headerlink" title="4.1 什么是网络媒介"></a>4.1 什么是网络媒介</h3><blockquote><p>现代网络通常使用三种类型的媒介来互联设备、提供数据的传输路径。三种媒介有：</p></blockquote><ul><li>电缆中的铜线</li><li>玻璃或塑料纤维（光纤电缆）</li><li>无线传输</li></ul><blockquote><p>当然，不同的网络媒介有不同的特点与优点。它们有着不同的应用场景，选择网络媒介主要有以下四个主要参考标准：</p></blockquote><ul><li>传输信号的距离</li><li>所安装在的环境</li><li>要求传输的数据总量以及速度</li><li>媒介和安装的成本</li></ul><p><img src="http://static.zybuluo.com/Adward-Wang/ofu5ruqsnqsf8br035omjnp0/Network_Media2.png" alt="Network_Media2.png"></p><hr><p><strong>拓展：常见的网络电缆</strong></p><blockquote><p>1.双绞线</p></blockquote><p><img src="http://static.zybuluo.com/Adward-Wang/uquvhr5slm3vmx663bqqe9gm/Twisted_pair.jpg" alt="Twisted_pair"></p><blockquote><p>现代以太网技术通常使用一种叫双绞线的铜线电缆来互联设备。因为以太网是大多数本地网络的基础。双绞线则是最常用的网络电缆类型之一。为了减少干扰，电线成对地组合在一起。成对的电线是有颜色的，这样你就可以在每一端识别出相同的电线。通常在每一对中，其中一根线是纯色的，它的伙伴是相同颜色的条纹到白色背景上。</p></blockquote><blockquote><p>2.同轴电缆</p></blockquote><p><img src="http://static.zybuluo.com/Adward-Wang/rfsmex0pkxcr6tzg8mpl8vz4/Coaxial_Cable.jpg" alt="Coaxial_Cable"></p><blockquote><p>同轴电缆通常由铜或铝制成，并被有线电视公司用来提供服务。它还用于连接组成卫星通信系统的各种组件。同轴电缆是最早开发的网络布线类型之一。同轴电缆是有线电视公司使用的铜质电缆。同轴电缆具有一个传导信号的刚性铜芯。该芯线通常被一层绝缘层，编织金属屏蔽层和保护套所包围。它用作传输高频或宽带信号的高频传输线。</p></blockquote><blockquote><p>3.光纤</p></blockquote><p><img src="http://static.zybuluo.com/Adward-Wang/cap5awep1y6jigrs6l8ssh67/Fiber-optic.jpg" alt="Fiber-optic"></p><blockquote><p>光纤电缆由玻璃或塑料制成。他们有非常高的带宽，这使他们能够携带非常大量的数据。光纤用于骨干网络、大型企业环境和大型数据中心。它也被电话公司广泛使用。光纤电缆可以是玻璃的，也可以是塑料的，直径和人的头发差不多，可以长距离高速传输数字信息。因为它们使用光而不是电，所以电干扰不会影响信号。光纤电缆和通信一样有很多用途。它们也被用于医学成像、医疗和机械工程检查。</p></blockquote><h3 id="4-2-以太网电缆"><a href="#4-2-以太网电缆" class="headerlink" title="4.2 以太网电缆"></a>4.2 以太网电缆</h3><blockquote><p>大多数家庭和学校的网络都是用双绞铜线连接的。与其他类型的电缆相比，这种类型的电缆价格低廉，容易获得。</p></blockquote><blockquote><p>双绞线由一对或多对绝缘铜线组成，这些铜线被扭在一起并包裹在保护套中。像所有的铜电缆一样，双绞线使用<strong>电脉冲</strong>来传输数据。</p></blockquote><blockquote><p>通过铜线传输的数据对电磁干扰(EMI)很敏感，这会降低电缆的数据传输率。家中常见的会产生电磁干扰的物品包括微波炉和荧光灯具。另一种干扰源，即串扰，发生在电缆长时间捆绑在一起的时候。来自一根电缆的电脉冲可以跨越到相邻的电缆。当电缆安装和终止不当时，这种情况最常见。当数据传输由于串扰等干扰而损坏时，必须重新传输数据。这会降低介质的数据承载能力。</p></blockquote><blockquote><p>下图展示了数据传输是如何被干扰所影响的</p></blockquote><p><img src="http://static.zybuluo.com/Adward-Wang/kpobk4r3dih0hk5566muarkr/cable_affected.jpg" alt="cable_affected"></p><hr><blockquote><p>Addition:<br>双绞线分为UTP（最常用、廉价、高带宽、易安装）和STP（昂贵，不灵活，不常用号，某些电气环境中使用，干扰多。例如在工厂中）</p></blockquote><h3 id="4-3-其他类型的网络电缆"><a href="#4-3-其他类型的网络电缆" class="headerlink" title="4.3 其他类型的网络电缆"></a>4.3 其他类型的网络电缆</h3><p><strong>1、有线电视和卫星电缆</strong></p><blockquote><p>像双绞线一样，同轴电缆以<strong>电信号</strong>的形式传输数据。与UTP相比，它提供了更好的屏蔽，因此可以承载更多数据。同轴电缆通常由铜或铝制成。有线电视公司使用它来提供服务并连接组成卫星通信系统的各种组件。您可能已经熟悉用于将电视机连接到信号源的同轴电缆，无论是有线电视插座，卫星电视还是家中的常规天线。通过添加<strong>电缆调制解调器</strong>，有线电视提供商可以在同一同轴电缆上提供数据和Internet服务以及电视信号和电话。</p></blockquote><blockquote><p>尽管同轴电缆具有改善的数据传输特性，但双绞线电缆已取代了局域网中的同轴电缆。替换的原因之一是，与UTP相比，同轴电缆在物理上更难安装，更昂贵且更难于排除故障。</p></blockquote><p>观看以下同轴电缆构造的动画。</p><p><img src="http://static.zybuluo.com/Adward-Wang/tznhe6e3laor5okguu7lie91/Coaxial_Cable2.jpg" alt="Coaxial_Cable"></p><p><strong>2、光纤</strong></p><blockquote><p>使用<strong>光脉冲</strong>传输数据。广泛运用于企业环境和大型数据中心。光纤电缆由玻璃或塑料构成，两者都不导电。这意味着它不受EMI和RFI的影响，并且适合安装在有干扰的环境中。光纤连接是将网络从一个建筑扩展到另一个建筑的一个很好的选择，这既是出于距离考虑，也是因为光纤比铜电缆更能抵抗室外环境条件。每个光纤电路实际上是<strong>两条光缆</strong>。一个用于传输数据;另一个用于接收数据。</p></blockquote><blockquote><p>光纤链路的带宽可以达到100 Gb/s，而且随着标准的制定和采用，带宽还在不断增加。</p></blockquote><p><img src="http://static.zybuluo.com/Adward-Wang/8ddr7gy5in2iv8o8s4h354q0/fiber-optic-detail.png" alt="fiber-optic-detail"></p><blockquote><p><strong>Jacket</strong><br>Typically a PVC jacket that protects the fiber against abrasion, moisture, and other contaminants. This outer jacket composition can vary depending on the cable usage.</p></blockquote><blockquote><p><strong>Strengthening Material</strong><br>Surrounds the buffer, prevents the fiber cable from being stretched when it is being pulled. The material used is often the same material used to produce bulletproof vests.</p></blockquote><blockquote><p><strong>Buffer</strong><br>Used to help shield the core and cladding from damage.</p></blockquote><blockquote><p><strong>Cladding</strong><br>Made from slightly different chemicals than those used to create the core. It tends to act like a mirror by reflecting light back into the core of the fiber. This keeps light in the core as it travels down the fiber.</p></blockquote><blockquote><p><strong>Core</strong><br>The core is actually the light transmission element at the center of the optical fiber. This core is typically silica or glass. Light pulses travel through the fiber core.</p></blockquote><h3 id="4-4-Peer-to-peer-Networking"><a href="#4-4-Peer-to-peer-Networking" class="headerlink" title="4.4 Peer-to-peer Networking"></a>4.4 Peer-to-peer Networking</h3><blockquote><p>什么是点对点网络呢？？？<br>客户端和服务器软件通常运行在单独的计算机上，但是一台计算机同时运行客户端和服务器软件也是可能的。在小型企业和家庭中，许多计算机充当网络上的服务器和客户端。这种类型的网络称为<strong>点对点网络</strong>。<br>最简单的点对点网络由两台直接连接的计算机组成，使用有线或无线连接。然后，两台计算机都能够使用这个简单的网络彼此交换数据和服务，根据需要充当客户机或服务器。</p></blockquote><blockquote><p>多台个人电脑也可以被连接在一起，以创建一个更大的点对点网络，但这需要一个网络设备，如<strong>交换机</strong>，来连接电脑。</p></blockquote><blockquote><p>点对点环境的主要缺点是，如果主机同时充当客户机和服务器，它的<strong>性能可能会降低</strong>。该图列出了点对点网络的一些优点和缺点。</p></blockquote><blockquote><p>在较大的企业中，由于潜在的高网络流量，通常需要专门的服务器来支持服务请求的数量。</p></blockquote><p><img src="http://static.zybuluo.com/Adward-Wang/ov3gxjiprc3wmsz6px62ywb3/P2P_Network.jpg" alt="P2P_Network"></p><h3 id="4-5-网络有效吗？"><a href="#4-5-网络有效吗？" class="headerlink" title="4.5 网络有效吗？"></a>4.5 网络有效吗？</h3><h4 id="1、ping-命令"><a href="#1、ping-命令" class="headerlink" title="1、ping 命令"></a><strong>1、ping 命令</strong></h4><blockquote><p>测试消息源的IP地址和目的地的IP地址之间的端到端连接。它度量测试消息从源到目的地的往返时间，以及传输是否成功。但是，如果消息没有到达目的地，或者在途中遇到了延迟，就无法确定问题位于何处。</p></blockquote><pre><code>格式：  ping *****        ping 192.168.30.1</code></pre><blockquote><p>观看下面的动画来看ping命令如何运作</p></blockquote><p><img src="http://static.zybuluo.com/Adward-Wang/x4xtccb96b57ys2vbyjq5mk5/ping_command.gif" alt="ping_command"></p><h4 id="2、Traceroute"><a href="#2、Traceroute" class="headerlink" title="2、Traceroute"></a><strong>2、Traceroute</strong></h4><blockquote><p>因特网是不同网络的互联。如图所示，traceroute实用程序可以跟踪消息从源到目标的路由。消息所经过的每个单独的网络被称为一跳。Traceroute显示了整个过程中的每一跳以及消息到达该网络并返回所需的时间。</p></blockquote><p><img src="http://static.zybuluo.com/Adward-Wang/vet0a8j7buneu3eaz811zp34/Traceroute.jpg" alt="Traceroute"></p><blockquote><p>如果出现问题（无法ping通），可以使用traceroute实用程序的输出来帮助确定消息丢失或延迟的位置。<br>traceroute实用程序在Windows环境中称为<code>tracert</code>。可以通过Windows环境中的命令提示符访问它。通常情况下，你可以通过“开始”菜单或“应用程序”屏幕上的命令提示快捷方式打开命令提示，这取决于你使用的是什么版本的Windows。</p></blockquote><blockquote><p><strong>路由器</strong>决定了到达目的地的最佳路径，通过很多路由器我们可以达到所要访问的内容。Traceroute程序报告数据包成功到达的每个路由器，到哪里失败，接下来<strong>针对失败的点</strong>我们再进一步找出失败的原因。</p></blockquote><h3 id="4-6-在PT上构建一个简单的网络"><a href="#4-6-在PT上构建一个简单的网络" class="headerlink" title="4.6 在PT上构建一个简单的网络"></a>4.6 在PT上构建一个简单的网络</h3><blockquote><p>简单的实验，放置主机、交换机，用以太网电缆连接,配置主机ip,用ping 测试主机连接有效性。</p></blockquote><hr><h2 id="学习总结"><a href="#学习总结" class="headerlink" title="学习总结"></a>学习总结</h2><blockquote><p>思科网络基础的第一门课，内容浅显易懂，关键图形化了很多抽象的概念，还有仿真实验工具，总的来说体验很好，算是比较不错的入门课。</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 计算机网络 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 网络基础 </tag>
            
            <tag> Cisco </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Network Protocols and Architecture (1)</title>
      <link href="/2020/05/24/network-protocols-architecture-1/"/>
      <url>/2020/05/24/network-protocols-architecture-1/</url>
      
        <content type="html"><![CDATA[<h1 id="一、Week1"><a href="#一、Week1" class="headerlink" title="一、Week1"></a>一、Week1</h1><h2 id="1-Establishing-the-Rules"><a href="#1-Establishing-the-Rules" class="headerlink" title="1. Establishing the Rules"></a>1. Establishing the Rules</h2><h3 id="1-1-Reading-About-This-Course"><a href="#1-1-Reading-About-This-Course" class="headerlink" title="1.1 Reading: About This Course"></a>1.1 Reading: About This Course</h3><p>有几个这个课程提出的学习目标，等学完用来检测一下自己的学习情况。<br>At the end of this course, you will be able to:</p><ol><li>Explain how protocols and standards benefit a global internetwork.<br>解释协议和标准的作用方式？？？</li><li>Describe how the Ethernet Protocol transmits data within a LAN.<br>描述局域网下以太网协议如何传输数据？？？</li><li>Explain IPv4 addressing and the role of subnet masks.<br>解释IPv4寻址以及子网掩码的作用？？？</li><li>Use Cisco Packet Tracer to connect hosts to a wireless router in a LAN.<br>使用软件在局域网环境下将主机连接到无线路由器</li><li>Use a protocol analyzer or “packet sniffer” to open and examine a data packet that has been transmitted across a network.<br>使用协议分析器或者数据包分析器来打开并检查一个网络上的数据包</li><li>Examine a Windows computer to locate the physical or MAC address used send and receive data.<br>检查Windows计算机，找到用于发送和接收数据的物理地址（或MAC地址）。</li></ol><h3 id="1-2-Reading-Cisco-Packet-Tracer-软件介绍"><a href="#1-2-Reading-Cisco-Packet-Tracer-软件介绍" class="headerlink" title="1.2 Reading: Cisco Packet Tracer 软件介绍"></a>1.2 Reading: Cisco Packet Tracer 软件介绍</h3><h3 id="1-3-Reading-The-Three-Elements"><a href="#1-3-Reading-The-Three-Elements" class="headerlink" title="1.3 Reading: The Three Elements"></a>1.3 Reading: The Three Elements</h3><p>自古至今 任何一种网络的主要目的都是给我们提供一种交流和分享信息的途径。而分享信息则会让人类进步。</p><p>所有通信都以一条消息开始，从一个个体或者设备发送到另一个。而随着科技进步，消息发送、接收、传递的方法都会改变。</p><p>所有通信方法都具有<strong>三个共同要素</strong>：</p><ol><li>Message source or Sender</li><li>Destination or Receiver of the message</li><li>Transmission medium or channel</li></ol><p>Watch the animation below to see how messages are sent and received in human and computer communication.</p><p><img src="http://static.zybuluo.com/Adward-Wang/efjwwht0mklyazyi05h50n4z/The_Three_Elements.gif" alt="The_Three_Elements.gif-222.6kB"></p><h3 id="1-4-Reading-Communication-Protocols"><a href="#1-4-Reading-Communication-Protocols" class="headerlink" title="1.4 Reading: Communication Protocols"></a>1.4 Reading: Communication Protocols</h3><p>日常生活中的通信具有不同形式，不同的应用场景具有不同规则。<br>在开始彼此沟通之前，我们建立规则或协议来管理对话，如图1至图3所示。为了成功地传递和理解消息，必须遵循这些规则或协议。成功的人类交流协议包括:</p><ul><li>An identified sender and receiver    已标志的发送方和接收方</li><li>Agreed upon method of communicating (face-to-face, telephone, letter, photograph) 商定的沟通方式</li><li>Common language and grammar 共同的语言和语法</li><li>Speed and timing of delivery 交付的速度和时间</li><li>Confirmation or acknowledgment requirements 确认需求</li></ul><p>网络通信中使用的技术与人类间对话的基本原理类似。</p><p><img src="http://static.zybuluo.com/Adward-Wang/4jiuu83j1u8wnwln201ulfgj/1Method.jpg" alt="1Method.jpg-41.6kB"><br>Firgure1. Method</p><p><img src="http://static.zybuluo.com/Adward-Wang/l3jhtd0uayq0q2ihiafuz8a1/2Language.jpg" alt="2Language.jpg-39.9kB"><br>Firgure2. Language</p><p><img src="http://static.zybuluo.com/Adward-Wang/0lrqb0rh3tuxso8d0g0fpogp/3Confirmation.jpg" alt="3Confirmation.jpg-40kB"><br>Firgure1. Confirmation</p><h3 id="1-5-Video-Network-Protocols"><a href="#1-5-Video-Network-Protocols" class="headerlink" title="1.5 Video: Network Protocols"></a>1.5 Video: Network Protocols</h3><h3 id="1-6-Reading-Why-Protocols-Matter-为何协议很重要？"><a href="#1-6-Reading-Why-Protocols-Matter-为何协议很重要？" class="headerlink" title="1.6 Reading: Why Protocols Matter 为何协议很重要？"></a>1.6 Reading: Why Protocols Matter 为何协议很重要？</h3><p>In both a wired and wireless environment, a local network is defined as an area where all hosts must “speak the same language” or in computer terms “share a common protocol”.<br>在有线和无线环境中，<strong>局域网</strong>均定义为所有主机必须“说同一语言”或用计算机术语“共享通用协议”的区域。<br>Networking protocols define many aspects of communication over the local network, including: message format, message size, timing, encoding, and message patterns.</p><p>Review the figure below for more information.</p><p><img src="http://static.zybuluo.com/Adward-Wang/b73s0rd7z2s6wdi5s5z9q9vv/Why_Protocols_matter.jpg" alt="Why_Protocols_matter.jpg-36kB"></p><p><strong>Timing</strong><br>Many network communication functions are dependent on timing. Timing determines the speed at which the bits are transmitted across the network. It also affects when an individual host can send data and the total amount of data that can be sent in any one transmission.<br><strong>时序</strong><br>许多网络通信功能取决于时序。时序决定了比特在网络上传输的速度。它还会影响单个主机何时可以发送数据以及在任何一次传输中可以发送的数据总量。</p><p><strong>Message Size</strong> Message可译为报文<br>The rules that govern the size of the pieces communicated across the network are very strict. They can also be different, depending on the channel used. When a long message is sent from one host to another over a network, it may be necessary to break the message into smaller pieces in order to ensure that the message can be delivered reliably.</p><p><strong>Encapsulation</strong> 封装<br>Each message transmitted on a network must include a header that contains addressing information that identifies the source and destination hosts, otherwise it cannot be delivered. Encapsulation is the process of adding this information to the pieces of data that make up the message. In addition to addressing, there may be other information in the header that ensures that the message is delivered to the correct application on the destination host.</p><p><strong>Message Format</strong><br>When a message is sent from source to destination, it must use a specific format or structure. Message formats depend on the type of message and the channel that is used to deliver the message.</p><p><strong>Encoding</strong><br>Messages sent across the network are first converted into bits by the sending host. Each bit is encoded into a pattern of sounds, light waves, or electrical impulses depending on the network media over which the bits are transmitted. The destination host receives and decodes the signals in order to interpret the message.</p><p><strong>Message Patterns</strong><br>Some messages require an acknowledgment before the next message can be sent. This type of request/response pattern is a common aspect of many networking protocols. However, there are other types of messages that may be simply streamed across the network, without concern as to whether or not they reach their destination.<br>（暗示TCP UDP？？？）</p><hr><h2 id="2-So-Who-Makes-the-Rules"><a href="#2-So-Who-Makes-the-Rules" class="headerlink" title="2. So Who Makes the Rules"></a>2. So Who Makes the Rules</h2><h3 id="2-1-Reading-The-Internet-and-Standards"><a href="#2-1-Reading-The-Internet-and-Standards" class="headerlink" title="2.1 Reading: The Internet and Standards"></a>2.1 Reading: The Internet and Standards</h3><p>标准是一组规则，用来决定必须如何做某事。网络和Internet标准确保所有连接到网络的设备以相同的方式实现相同的规则或协议集。使用标准，不同类型的设备可以通过互联网互相发送信息.</p><p><img src="http://static.zybuluo.com/Adward-Wang/xu7c0gjcknd9bnav3vy1561k/Internet_Standards.gif" alt="Internet_Standards.gif-2904.5kB"></p><h3 id="2-2-Reading-Network-Standards-Organizations"><a href="#2-2-Reading-Network-Standards-Organizations" class="headerlink" title="2.2 Reading: Network Standards Organizations"></a>2.2 Reading: Network Standards Organizations</h3><p>Internet标准是讨论，问题解决和测试的全面循环的最终结果。如图所示，这些不同的标准由各种组织开发，发布和维护。当提出新标准时，开发和批准过程的每个阶段都记录在编号为Request for Comments（RFC）的文档中，以便跟踪该标准的演变。Internet标准的RFC由Internet工程任务组（IETF）发布和管理。</p><pre><code>Q: 没有统一的标准码？这段话是不是这个意思？“？</code></pre><p>You can check out the IETF website at <a href="http://ietf.org" target="_blank" rel="noopener">http://ietf.org</a>.</p><p><img src="http://static.zybuluo.com/Adward-Wang/c6g8l3brl0d97n4xkiearecj/n_organization.jpg" alt="n_organization.jpg-64.4kB"></p><hr><h2 id="3-Visualizing-How-Protocols-Work"><a href="#3-Visualizing-How-Protocols-Work" class="headerlink" title="3. Visualizing How Protocols Work"></a>3. Visualizing How Protocols Work</h2><h3 id="3-1-Reading-Stacking-Them-up"><a href="#3-1-Reading-Stacking-Them-up" class="headerlink" title="3.1 Reading: Stacking Them up"></a>3.1 Reading: Stacking Them up</h3><p>主机之间的成功通信需要多种协议之间的交互。而这些协议通过安装在每个主机和网络设备上的软件和硬件来实现。<br>The interaction between the different protocols on a device can be shown as a <strong>protocol stack</strong>, as shown in the figure. A stack illustrates the protocols as a <strong>layered hierarchy</strong>, with each higher-level protocol depending on the services of the protocols shown in the lower levels.（协议栈分层）</p><p>The separation of functions enables each layer in the stack to operate independently of others. For example, you can use your laptop computer connected to a cable modem at home to access your favorite website, or view the same website on your laptop using wireless at the library. The function of the web browser is not affected by the change in the physical location nor the method of connectivity.<br>功能的分离使堆栈中的每一层都可以独立运行。例如，您可以在家里使用连接到电缆调制解调器的便携式计算机访问您喜欢的网站，或在图书馆使用无线方式在便携式计算机上查看同一网站。Web浏览器的功能不受物理位置的更改或连接方法的影响。</p><pre><code>网上的精选摘要TCP/IP（Transmission Control Protocol/Internet Protocol，传输控制协议/网际协议）是指能够在多个不同网络间实现信息传输的协议簇。</code></pre><h3 id="3-2-Reading-Using-a-Layered-Model"><a href="#3-2-Reading-Using-a-Layered-Model" class="headerlink" title="3.2 Reading: Using a Layered Model"></a>3.2 Reading: Using a Layered Model</h3><pre><code>　　tcp/ip是事实标准，分4层。osi模型是国际标准，分7层。讲课的时候，一般把他们综合起来讲，就说是5层。他把网络接口层分开为数据链路层和物理层了。</code></pre><p>分层模型帮助我们可视化各种协议如何协同工作以支持网络通信。分层模型描述了在每一层中发生的协议的操作，以及与它上面和下面的层的交互。分层模型有很多好处:</p><ul><li>协助协议设计，因为在特定层上运行的协议定义了它们所作用的信息，并定义了上下层的接口</li><li>促进竞争，因为来自不同供应商的产品可以一起工作</li><li>允许技术更改在一个层次发生，而不影响其他层次</li><li>提供描述网络功能和功能的通用语言</li></ul><p>第一个网络通信的分层模型创建于20世纪70年代初，被称为Internet模型。它定义了通信成功所必须具备的四类功能。用于Internet通信的一套TCP/IP协议遵循这个模型的结构，如图所示。因此，Internet模型通常称为TCP/IP模型。</p><p><img src="http://static.zybuluo.com/Adward-Wang/j2v62n5f0zrlcwqxmtmq7jej/TCP_IP_Model.jpg" alt="TCP_IP_Model.jpg-43.6kB"></p><h3 id="3-3-Video-Protocols-Stacking-Them-Up"><a href="#3-3-Video-Protocols-Stacking-Them-Up" class="headerlink" title="3.3 Video: Protocols-Stacking Them Up"></a>3.3 Video: Protocols-Stacking Them Up</h3><p><img src="http://static.zybuluo.com/Adward-Wang/x57nw9u8p1uaj9964jg5tpn8/TCP_IP_Model2.jpg" alt="TCP_IP_Model2.jpg-57.9kB"></p><pre><code>**  Q：（每个层次不只有这么多协议，这里只是个范例？）**</code></pre><ul><li>1、The Ethernet protocol is used for NIC card, network interface card to network interface card communications in the same network.  </li><li>2、IP协议（4或6） makes sure that the message gets from the original source to the final destination, whether or not that message is within the same network or has to go across multiple networks</li><li>3、 TCP makes sure that the information, the message gets there reliably</li><li>4、 This case HTTP. HTTP governs the exchange or transfer of HTML</li></ul><h3 id="3-4-Reading-Different-Types-of-Network-Models"><a href="#3-4-Reading-Different-Types-of-Network-Models" class="headerlink" title="3.4 Reading: Different Types of Network Models"></a>3.4 Reading: Different Types of Network Models</h3><p>两种基本类型的模型： 协议模型 &amp; 参考模型</p><ul><li>1、协议模型 —— 该模型与特定协议套件结构非常匹配。协议套件包括一组相关协议，这些协议通常提供与数据网络通信所需的所有功能。<strong>TCP/IP模型</strong>是一个协议模型，因为它描述了<strong>TCP/IP套件</strong>中每一层协议上发生的功能。</li><li>2、参考模型 —— 这种类型的模型描述了必须在特定层完成的功能，但没有确切说明应如何完成功能。参考模型并不打算提供足够的细节来精确定义每个协议在每个层上的工作方式。参考模型的主要目的是帮助更清晰地理解网络通信所需的功能和过程。</li></ul><p>最广为人知的互联网络参考模型是由国际标准化组织（ISO）的开放系统互连项目创建的。它用于数据网络设计，操作规范和故障排除。该模型通常称为OSI模型。<br>下面是关于OSI模型的不同层的更多信息。</p><pre><code>Application 应用层The application layer provides the means for end-to-end connectivity between individuals in the human network using data networks.Presentation 表示层The presentation layer provides for common representation of the data transferred between application layer services.Session 会话层The session layer provides services to the presentation layer to organize its dialogue and to manage data exchange.Transport 传输层The transport layer defines services to segment, transfer, and reassemble the data for individual communications between the end devices.Network 网络层The network layer provides services to exchange the individual pieces of data over the network between identified end devices.Data Link 数据链路层The data link layer protocol describes methods for exchanging data frames between devices over a common medium.Physical 物理层The physical layer protocol describes the mechanical, electrical, functional, and procedural means to activate, maintain, and de-activate physical connections for bit transmission to and from a network device.</code></pre><hr><h2 id="4-Working-with-the-OSI-Model"><a href="#4-Working-with-the-OSI-Model" class="headerlink" title="4. Working with the OSI Model"></a>4. Working with the OSI Model</h2><h3 id="4-1-Reading-Dividing-the-Tasks"><a href="#4-1-Reading-Dividing-the-Tasks" class="headerlink" title="4.1 Reading: Dividing the Tasks"></a>4.1 Reading: Dividing the Tasks</h3><p>OSI 模型将网络通信分解为多个过程。每个过程只是较大任务的一小部分。<br>类比汽车制造厂，装配一辆汽车的复杂任务可以分解为多个子任务让其变得更加简单。</p><p>类似的，OSI模型帮助我们在进行故障排除以识别和解决网络问题时关注于一个层。网络团队经常通过OSI模型层的数量来引用网络中发生的不同功能，OSI模型层指定了该功能。例如，为跨媒体传输而对数据位进行编码的过程发生在第1层，即物理层。数据的格式可以通过笔记本电脑或手机中的网络连接进行解释，该格式描述在第2层，即数据链路层。</p><p><img src="http://static.zybuluo.com/Adward-Wang/rk9pkd3xgcjs8lmr4jrqhea7/OSI7.jpg" alt="OSI7.jpg-64.7kB"></p><h3 id="4-2-Reading-Comparing-the-OSI-and-TCP-Models"><a href="#4-2-Reading-Comparing-the-OSI-and-TCP-Models" class="headerlink" title="4.2 Reading: Comparing the OSI and TCP Models"></a>4.2 Reading: Comparing the OSI and TCP Models</h3><pre><code>The OSI model was created in the early 1980’s as a conceptual reference model with seven layers that specify characteristics and standards for the end-to-end communication process. Its goal was the interoperability of different communications systems.</code></pre><p><code>OSI模型</code>是在1980年代初期创建的，作为概念性参考模型，具有七个层，用于指定端到端通信过程的特征和标准。其目标是实现不同通信系统的互操作性。</p><pre><code>The TCP/IP model is another model with only four layers that relate to the OSI layers. This reference model also provides characteristics and standards for end-to-end communications. The TCP/IP model is more of an implementation model and is currently more widely referenced than the OSI model.</code></pre><p><code>TCP / IP模型</code>是另一个只有四个与OSI层相关的层的模型。该参考模型还提供了端到端通信的特性和标准。 TCP / IP模型更多地是一种 <strong>实现模型</strong>，并且与OSI模型相比，目前被更广泛地引用。</p><pre><code>Because TCP/IP is the protocol suite in use for Internet communications, why do we need to learn the OSI model as well?</code></pre><p>因为<code>TCP/IP</code>是用于互联网通信的<strong>协议套件</strong>，为什么我们还需要学习OSI模型?</p><pre><code>The TCP/IP model is a method of visualizing the interactions of the various protocols that make up the TCP/IP protocol suite. It does not describe general functions that are necessary for all networking communications. It describes the networking functions specific to those protocols in use in the TCP/IP protocol suite. For example: At the network access layer, the TCP/IP protocol suite does not specify which protocols to use when transmitting over a physical medium, nor the method of encoding the signals for transmission. OSI Layers 1 and 2 discuss the necessary procedures to access the media and the physical means to send data over a network.</code></pre><p><code>TCP/IP模型</code>是一种可视化构成<code>TCP/IP协议套件</code>的各种协议的交互的方法。它没有描述所有网络通信所必需的一般功能。它描述了特定于<code>TCP/IP协议套件</code>中使用的那些协议的网络功能。例如:在网络访问层，<code>TCP/IP协议套件</code>没有指定在物理介质上传输时使用哪个协议，也没有指定传输信号的编码方法。OSI第1层和第2层讨论访问媒体的必要程序和通过网络发送数据的物理方法。</p><p>The protocols that make up the TCP/IP protocol suite can be described in terms of the OSI reference model. The functions that occur at the Internet layer in the TCP/IP model are contained in the network layer of the OSI Model, as shown in the figure. The transport layer functionality is the same between both models. However, the network access layer and the application layer of the TCP/IP model are further divided in the OSI model to describe discrete functions that must occur at these layers.<br>可以根据<code>OSI参考模型</code>来描述构成<code>TCP / IP协议套件</code>的协议。如图所示，在<code>TCP / IP模型</code>的Internet层发生的功能包含在<code>OSI模型</code>的网络层中。两种模型之间的传输层功能相同。但是，在OSI模型中进一步划分了<code>TCP / IP模型</code>的网络访问层和应用程序层，以描述必须在这些层上发生的离散功能。</p><p><img src="http://static.zybuluo.com/Adward-Wang/x7anv930y81clfijwf4fs8ye/OSI_TCP_IP.jpg" alt="OSI_TCP_IP.jpg-56.6kB"></p><hr><h2 id="5-Protocols-for-Wired-Networks"><a href="#5-Protocols-for-Wired-Networks" class="headerlink" title="5. Protocols for Wired Networks"></a>5. Protocols for Wired Networks</h2><h3 id="5-1-Reading-Why-Ethernet"><a href="#5-1-Reading-Why-Ethernet" class="headerlink" title="5.1 Reading: Why Ethernet"></a>5.1 Reading: Why Ethernet</h3><p>在网络的早期，每个供应商都使用他们自己的专有方法来互连网络设备和网络协议。如果从不同的供应商购买设备，并不能保证这些设备可以协同工作。来自一个供应商的设备可能无法与来自另一个供应商的设备通信。</p><p>随着网络的日益普及，各种标准应运而生，这些标准定义了不同供应商的网络设备操作规则。标准在很多方面都有利于网络:</p><ul><li>方便设计</li><li>简化产品开发</li><li>促进竞争</li><li>提供一致的互连</li><li>促进培训</li><li>为客户提供更多供应商选择</li></ul><p>目前尚无官方的局域网标准协议，但随着时间的流逝，以太网技术已经变得比其他技术更为普遍。 <strong>以太网协议</strong>定义了如何格式化数据以及如何通过<strong>有线网络</strong>传输数据。以太网标准指定了在OSI模型的第1层和第2层运行的协议。如图所示，它已经成为事实上的标准，这意味着以太网是几乎所有<strong>有线局域网</strong>使用的技术。</p><p><img src="http://static.zybuluo.com/Adward-Wang/darf7635b04vaze25vod75q7/Why_Ethernet.jpg" alt="Why_Ethernet.jpg-40.6kB"></p><h3 id="5-2-Reading-Ethernet-is-Constantly-Evolving"><a href="#5-2-Reading-Ethernet-is-Constantly-Evolving" class="headerlink" title="5.2 Reading: Ethernet is Constantly Evolving"></a>5.2 Reading: Ethernet is Constantly Evolving</h3><pre><code>The Institute of Electrical and Electronic Engineers, or IEEE (pronounced eye-triple-e), maintains the networking standards, including Ethernet and wireless standards. IEEE committees are responsible for approving and maintaining the standards for connections, media requirements and communications protocols. Each technology standard is assigned a number that refers to the committee that is responsible for approving and maintaining the standard. The committee responsible for the Ethernet standards is 802.3.</code></pre><p>电气和电子工程师协会（IEEE，发音为eye-triple-e）维护网络标准，包括以太网和无线标准。IEEE委员会负责批准和维护连接，媒体要求和通信协议的标准。每个技术标准都分配有一个编号，该编号表示负责批准和维护该标准的委员会。负责以太网标准的委员会是<code>802.3</code>。</p><pre><code>Since the creation of Ethernet in 1973, standards have evolved for specifying faster and more flexible versions of the technology. This ability for Ethernet to improve over time is one of the main reasons that it has become so popular. Each version of Ethernet has an associated standard. For example, 802.3 100BASE-T represents the 100 Megabit Ethernet using twisted-pair cable standards. The standard notation translates as:• 100 is the speed in Mb/s• BASE stands for baseband transmission• T stands for the type of cable, in this case, twisted-pair.</code></pre><p>1973年以太网诞生, 标准不断演变，更快速度，更灵活的版本推出。以太网的这种随时间推移不断改进的能力是它变得如此受欢迎的主要原因之一。每个版本的以太网都有一个相关的标准。例如，<code>802.3 100BASE-T</code>表示使用双绞线标准的100兆以太网。标准符号翻译为:</p><ul><li>100Mb/s 带宽</li><li>BASE代表基带传输</li><li>T代表电缆的类型，在这种情况下为双绞线。</li></ul><h3 id="5-3-Reading-Ethernet-Addressing"><a href="#5-3-Reading-Ethernet-Addressing" class="headerlink" title="5.3 Reading: Ethernet Addressing"></a>5.3 Reading: Ethernet Addressing</h3><p>所有通信都需要一种方法来标识源和目标。而人际交流中的来源和目的地由姓名表示。<br>（类比）当别人叫你的名字时，你会听到并作出回应，而听到消息的其他人则会忽略该消息，因为并不是叫他们。</p><p>在以太网中，有一种类似的方法来标识源主机和目标主机。为连接到以太网的每个主机分配一个物理地址，该地址用于标识网络上的主机。</p><p>观看下面的动画，了解如何在主机之间发送以太网帧。</p><p><img src="http://static.zybuluo.com/Adward-Wang/4xhvsaf03b5656u5lvfiw2jn/Ethernet_Addressing.gif" alt="Ethernet_Addressing.gif-381.1kB"></p><h3 id="5-4-Video-Ethernet-Addressing"><a href="#5-4-Video-Ethernet-Addressing" class="headerlink" title="5.4 Video: Ethernet Addressing"></a>5.4 Video: Ethernet Addressing</h3><h3 id="5-5-Lab-Determine-the-MAC-Address-of-a-Host"><a href="#5-5-Lab-Determine-the-MAC-Address-of-a-Host" class="headerlink" title="5.5 Lab-Determine the MAC Address of a Host"></a>5.5 Lab-Determine the MAC Address of a Host</h3><p>六个字节组成<br>前三个为 <code>组织唯一标识符</code> OUI  (Organizationally unique identifier)； 我的是 94-57-A5 ，惠普生产<br>后三个为 <code>接口唯一标识符</code></p>]]></content>
      
      
      <categories>
          
          <category> 计算机网络 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 网络基础 </tag>
            
            <tag> Cisco </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>杂记 0415</title>
      <link href="/2020/04/15/title-za-ji-0415/"/>
      <url>/2020/04/15/title-za-ji-0415/</url>
      
        <content type="html"><![CDATA[<p>貌似很久没更博客了，这些天一直忙着毕业论文的事，虽然现在还没弄好，但我觉得快了（又是我觉得，手动狗头）</p><hr><h3 id="01-读书有感"><a href="#01-读书有感" class="headerlink" title="01 读书有感"></a>01 读书有感</h3><p>昨天在看一本书时，上面写到了这么一段话：</p><blockquote><p>对于计算机开发来说，懂得底层原理，这是技术能力；懂得算法参数，这是方法论。这两者都不是工程能力。而工程能力是把一堆杂乱的数据整理成结构化数据，并运用算法对数据进行加工，得到某些结论。</p></blockquote><p>我被这句话触动了许久，因为我觉得一直以来自己的学习陷入了怪区，零散化没有体系，又或是学习没有目的性，始终抱着学生思维：<code>即做一件事我要从他的相关基础开始学习，等学好了我再去做</code>，其实知识永远学不完的，理论知识只有在实践中才能出真知。 做一件个项目，做一件事，你得清楚地知道你需要哪些知识，哪些知识是重要的，哪些是次要的，做成一个项目你需要做哪些相关的准备工作下一步怎么做等等，这些都需要去考虑，千万不能想着学个透彻，当然，不是说学深入不好，而是有时候面临时间、人力问题，等你准备好了黄花菜都凉了，我觉得那应该叫自我感动，其实是很低效的准备。</p><p><strong>做一件事或者项目应该动手动脑子想想思路</strong>，没有思路可以去网上借鉴别人，再不行找前辈大佬去文，我觉得信息时代带给我最大的便利就是 很多问题我都可以在网上找到答案或者找到人去寻求帮助。</p><p>再之就是，我想了许久，本科学习究竟给我带来了什么？我觉得就是素养、理论基础以及对计算机的热爱，工程能力学校并没有教或者说我学的不够好。所以我现在还是需要去不断提高自己的实践能力，光谈理论都是花架子。企业需要的是可以解决问题有工程能力的人才，而不是会考试或者说谈理论的人。对，我应该早点想清楚这一点的，可是身边也没有人指点我，或许人在某个阶段总会迷茫困惑吧。</p><hr><h3 id="02-观影有感"><a href="#02-观影有感" class="headerlink" title="02 观影有感"></a>02 观影有感</h3><p>前几天，看了一部电影解说，里面有一句话让我印象很深，我就把记了下来。</p><blockquote><p>就好像你是一只拼尽全力从粪坑里爬出来的蛆，你努力蜕壳长上了一双翅膀，可就算别人把你当作鸟类，可你自己却清楚地知道你变成的也只不过是一只苍蝇。当你鼓足勇气想要飞向你爱慕的花朵时，当看到蝴蝶飞来，你总会及时停下望而却步，毕竟在别人眼中，鲜花和蝴蝶才是该有的般配。</p></blockquote><p>这句话很粗，但是我被深深触动了，我来自农村，我也能脑补出那种场景，一瞬间我感觉我就是解说里所说的那只蛆，我在努力地爬出那个坑。下一秒我又努力摇头让自己拒绝这种想法。我或许是苍蝇又或许不是，但是这重要吗？</p><p>我为什么要在意别人的看法呢，我自己有我自己的坚持，有我的尊严去守护。我会去努力爬出这个坑。或许鲜花和蝴蝶才算般配，但是换个角度来说，鲜花会选择蝴蝶是出于选择更好的，那它又真的能够配得上那只不起眼的苍蝇呢？</p><p>这几个月我一直熬夜，或许夜深比较安静，世界仿佛都属于我，又或许深夜我又可以停下来胡思乱想了。傅妈说，贫穷是有后遗症的。我想或许吧，除了有些自卑至少我现在没有体会到什么是所谓的后遗症，我也相信学的东西多了，见识广了，一切都会好，一切的烦恼源自自己的无知</p><hr><h3 id="03-生活有感（胡说八道）"><a href="#03-生活有感（胡说八道）" class="headerlink" title="03 生活有感（胡说八道）"></a>03 生活有感（胡说八道）</h3><p>不知道为什么，自己的消费观和从前有了很大变化，买一个东西更考虑它能带来的用户体验以及能够提高生产力吗。<br>开网盘会员可以提高生产力，节约时间，存放资料等用户，也算作一种投资。<br>网易云音乐可以让我听到我想听的歌，改善我的心情，这些只需要一些小小的金钱投入就能带来回报，为什么不呢？ 为什么我以前就没有这样想呢？</p><p>可能以前消费观太局限性了，现在更考虑投资和产出的比例，可能自己更物质了吧，我也不知道自己究竟是变好或者变坏了，只是觉得这样的观念应该比以前的观念要好，仅此而已。</p><hr><p>算了不早了，睡觉， 胡思乱想 作于 4月15日 凌晨2：31</p>]]></content>
      
      
      <categories>
          
          <category> 浮生日记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 闲人闲语 </tag>
            
            <tag> 杂记 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>MySQL——多表 &amp; 事务</title>
      <link href="/2020/03/24/title-mysql-duo-biao-shi-wu/"/>
      <url>/2020/03/24/title-mysql-duo-biao-shi-wu/</url>
      
        <content type="html"><![CDATA[<h1 id="今日内容"><a href="#今日内容" class="headerlink" title="今日内容"></a>今日内容</h1><pre><code>1. 多表查询2. 事务3. DCL</code></pre><h2 id="多表查询"><a href="#多表查询" class="headerlink" title="多表查询"></a>多表查询</h2><h3 id="一、内连接查询"><a href="#一、内连接查询" class="headerlink" title="一、内连接查询"></a>一、内连接查询</h3><pre><code>    1.隐式内连接：使用where条件 消除无用    SELECT         t1.name, -- 员工表姓名        t1.gender, --员工表性别        t2.name, --部门表名称    FROM        emp t1,        dept t2,    WHERE        t1.dep_id = t2.id;    2. 显示内连接        语法：select 字段列表 from 表名1 （inner） join 表名2 on 条件；        eg:   select *from emp (inner) join dept on emp.dept_id = dept.id;    3. 内连接查询        a. 从哪些表中获取数据        b. 查询条件是什么        c. 查询哪些字段</code></pre><h3 id="二、外连接查询："><a href="#二、外连接查询：" class="headerlink" title="二、外连接查询："></a>二、外连接查询：</h3><pre><code>1.左外连接    语法：select 字段列表 from 表1 left [outer] join 表2 on 条件;    ** 查询的是左表所有数据以及其交集部分2.右外连接    语法：select 字段列表 from 表1 right [outer] join 表2 on 条件;    ** 查询的是右表所有数据以及其交集部分    </code></pre><h3 id="三、子查询"><a href="#三、子查询" class="headerlink" title="三、子查询"></a>三、子查询</h3><pre><code>** 概念：查询中嵌套查询，称嵌套查询为子查询--  查询工资最高的员工信息-- 1. 查询最高工资为多少  9000    SELECT MAX(salary) FROM emp;-- 2.查询员工信息，并且工资等于9000的    SELECT * FROM emp WHERE emp.salary = 9000;-- 一条SQL 完成上述操作. 子查询    SELECT * FROM emp WHERE emp.salary =(SELECT MAX(salary) FROM emp);** 子查询的不同情况    1. 子查询的结果是单行单列的；        * 子查询的结果可以作为条件，使用运算符去判断。运算符: &gt; &gt;= &lt; &lt;= =                       SELECT *FROM emp WHERE emp.salary &lt; (SELECT AVG(salary) FROM emp);    2. 子查询的结果是多行单列的；        * 子查询作为条件，使用运算符in 来判断        -- 查询‘财务部’和‘市场部’所有的员工信息        SELECT id FROM dept WHERE NAME =&#39;财务部&#39; OR NAME =&#39;市场部&#39;;        SELECT * FROM emp WHERE dep_id =3 OR dep_id =2;        --子查询        SELECT * FROM emp WHERE dep_id IN(SELECT id FROM dept WHERE NAME =&#39;财务部&#39; OR NAME =&#39;市场部&#39;);    3. 子查询的结是多行多列的         * 子查询可作为一张虚拟表        -- 查询员工入职日期是2011-11-11号之后的员工信息和部门信息        SELECT *FROM dept t1, (SELECT * FROM emp WHERE emp.join_date &gt;&#39;2011-11-11&#39;) t2        WHERE t1.id =t2.dep_id;</code></pre><h2 id="事务"><a href="#事务" class="headerlink" title="事务"></a>事务</h2><h3 id="一、事务的基本介绍"><a href="#一、事务的基本介绍" class="headerlink" title="一、事务的基本介绍"></a>一、事务的基本介绍</h3><pre><code>1.概念 ：  在实际的开发过程中，一个业务操作如：转账，往往是要多次访问数据库才能完成的。转账是一个用户扣钱，另一个用户加钱。如果其中有一条SQL语句出现异常，这条SQL就可能执行失败。 事务执行是一个整体，所有的SQL语句都必须执行成功。如果其中有1条SQL语句出现异常，则所有的SQL语句都要回滚，整个业务执行失败。 2.具体操作    1. 开启事务： start transaction;    2. 回滚：   roll back;    3. 提交：   commit;    4. MySQL 中事务默认自动提交    * 事务提交的两种方式        * 自动提交：            * MySQL就是自动提交        * 手动提交            * Oracle 默认手动提交事务            * 需要开启事务，再提交    * 修改事务的默认提交方式：        * 查看事务的。。。：SELECT @@autocommit; -- 1代表自动提交 0 代表手动提交        * 修改用SET 关键字：SET ... = 1(0);</code></pre><h3 id="二、事务的四大特征-ACID"><a href="#二、事务的四大特征-ACID" class="headerlink" title="二、事务的四大特征(ACID)"></a>二、事务的四大特征(ACID)</h3><pre><code>1.原子性（atomicy)： 是不可分割的最小操作单位2.持久性 (durability)： 当事务提交或回滚后，数据库会持久化地保存数据3.隔离性((isolation)：多个事务之间，相互独立。4.一致性(consistency)：事务操作前后，数据总量不变</code></pre><h3 id="三、事务的隔离级别（了解）"><a href="#三、事务的隔离级别（了解）" class="headerlink" title="三、事务的隔离级别（了解）"></a>三、事务的隔离级别（了解）</h3><pre><code>*概念：多个事务间隔离，相互独立，但是如果多个事务操作同一批数据，则会引发一些问题，设置不同的隔离级别就可以解决这些问题。*存在问题：    1. 脏读 ：一个事务，读取到另一个事务中没有提交的数据    2.不可重复度（虚读）：在同一个事务中，两次读到的数据不一样    3.幻读： 一个事务操作（DML）数据表中所有记录，另一个事务添加了一条数据，则第一个事务查不到自己的修改。*隔离级别：    1. read uncommitted: 读未提交        * 产生的问题： 脏读、不可重复度、幻读    2. read committed: 读已提交     （Oracle 默认)        * 产生的问题：不可重复读，幻读    3. repeatable read: 可重复读 （MySQL 默认)        * 产生的问题： 幻读    4. serializable: 串行化        * 可以解决所有问题    *注意：隔离级别从小到大安全性越来越高，但是效率越来越低。</code></pre><h2 id="DCL："><a href="#DCL：" class="headerlink" title="DCL："></a>DCL：</h2><pre><code>* SQL 分类    1.   DDL: 操作数据库和表    2.   DML： 增删改表中数据    3.   DQL： 查询表中数据    4.   DCL： 管理用户，授权* DBA： 数据库管理员* DCL： 管理用户，授权    1.管理用户        * 添加用户            * 语法： CREATE USER &#39;用户名&#39;@&#39;主机名&#39; IDENTIFIED BY &#39;密码&#39;;        * 删除用户            * 语法： DROP USER &#39;用户名&#39;@&#39;主机名&#39;;        * 修改用户密码            * 语法： UPDATE USER SET PASSWORD = PASSWORD（&#39;新密码&#39;) WHERE USER = &#39;用户名&#39;;//            SET PASSWORD FOR &#39;用户名’@&#39;主机名&#39;= PASSWORD(&#39;新密码&#39;);        * 查询用户            --1.切换到mysql数据库            USE mysql;            --2.查询user表            SELECT *FROM USER；            通配符：%表示可以在任意主机上登录    2.权限管理：        1.查询权限：            -- SHOW GRANTS FOR &#39;用户名&#39;@&#39;主机名&#39;;        2.授予权限：            -- GRANT 权限列表 ON 数据库名.表名 TO &#39;用户名&#39;@&#39;主机名&#39;;            -- 给与所以权限，在任意数据库任意表上             GRANT ALL ON *.* TO &#39;用户名&#39;@&#39;localhost&#39;;        3.撤销权限：            -- REVOKE 权限列表 ON 数据库名.表名 FROM &#39;用户名&#39;@&#39;主机名&#39;;</code></pre>]]></content>
      
      
      <categories>
          
          <category> 数据库 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> MySQL </tag>
            
            <tag> SQL </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>MySQL——DQL、约束、范式</title>
      <link href="/2020/03/21/title-mysql-xue-xi-dql-yue-shu-fan-shi/"/>
      <url>/2020/03/21/title-mysql-xue-xi-dql-yue-shu-fan-shi/</url>
      
        <content type="html"><![CDATA[<h1 id="内容"><a href="#内容" class="headerlink" title="内容"></a>内容</h1><pre><code>    一、 DQL 查询语句        1.排序查询        2.聚合函数        3.分组查询        4.分页查询    二、约束    三、多表间关系    四、范式    五、数据库备份与还原</code></pre><hr><h2 id="DQL-查询语句"><a href="#DQL-查询语句" class="headerlink" title="DQL 查询语句"></a>DQL 查询语句</h2><h3 id="排序查询"><a href="#排序查询" class="headerlink" title="排序查询"></a>排序查询</h3><p> <strong>语法</strong>：<code>ORDER BY 子句</code><br> <strong>eg:</strong> </p><pre><code>ORDER BY 排序字段1 排序方式1， 排序字段2 排序方式2 ....</code></pre><p><strong>排序方式：</strong>   </p><pre><code>ASC 升序 默认方式DESC 降序 </code></pre><p> <strong>注意：</strong>  如果有多个排序条件，则当前面的条件值相同时才考虑后面的排序条件      </p><h3 id="聚合函数"><a href="#聚合函数" class="headerlink" title="聚合函数"></a>聚合函数</h3><pre><code>    将一列数据作为一个整体，进行纵向计算</code></pre><ol><li>count</li><li>max, min</li><li>sum, avg</li></ol><p><strong>注</strong>：聚合函数的计算排除了 NULL值， </p><p><strong>解决方案：</strong><br>1.一般选择非空的列:主键<br>2.IFNULL</p><p>eg:</p><pre><code>SELECT COUNT(english)) FROM student;//排除NULLSELECT COUNT(IFNULL(english, 0)) FROM student; //有NULL作0</code></pre><h3 id="分组查询"><a href="#分组查询" class="headerlink" title="分组查询"></a>分组查询</h3><p> <strong>语法</strong>：<code>GROUP BY 子句</code><br> <strong>注意!：</strong><br> 1.分组之后查询的字段： 分组字段、聚合函数</p><ol start="2"><li><p>where 和 having 的区别</p><p>a. where 在分组前进行限定，若不满足条件，则不参与分组。having 在分组之后进行线性，若不满足条件，则不会被查询出来。<br>b. where 后不可以跟聚合函数， having 可以进行聚合函数的判断</p></li></ol><p> eg:</p><pre><code>-- 按照性别分组，分别查询男女同学平均分SELECT  sex, AVG(math) FROM student GROUP BY sex;-- 按照性别分组，分别查询男女同学平均分，人数SELECT sex, AVG(math), COUNT(id) FROM student GROUP BY sex;-- 按照性别分组，分别查询男女同学平均分，人数 要求：分数低于70分的人，不参与分组（分组前添加限定条件）SELECT sex, AVG(math), COUNT(id) FROM studentWHERE math&gt; 70 GROUP BY sex;-- 按照性别分组，分别查询男女同学平均分，人数 要求：分数低于70分的人，不参与分组，分组之后，人数要大于两个人(分组之后限定条件）SELECT sex, AVG(math), COUNT(id) numberFROM studentWHERE math&gt;70GROUP BY SEXHAVING number &gt;2; //起别名判断更方便</code></pre><h3 id="分页查询"><a href="#分页查询" class="headerlink" title="分页查询"></a>分页查询</h3><p><strong>语法</strong>：<code>limit 开始的索引， 每页查询的条数;</code><br><strong>公式</strong>： <code>开始的索引 = （当前页码 - 1） *每页显示的条数</code><br>limit 是一个“方言”，不同数据库对应函数不同。<br>eg:</p><pre><code>-- 每页显示三条记录SELECT *FROM student LIMIT 0,3;    --第一页SELECT *FROM student LIMIT 3,3;    --第二页SELECT *FROM student LIMIT 6,3;    --第二页</code></pre><hr><h2 id="约束"><a href="#约束" class="headerlink" title="约束"></a>约束</h2><p><strong>概念：</strong>对表中数据进行限定，保证数据的正确性、有效性、完整性<br><strong>分类：</strong><br>1.主键约束： primary key<br>2.非空约束:  not null<br>3.唯一约束:  unique<br>4.外键约束:  foreign key</p><h3 id="非空约束-NOT-NULL"><a href="#非空约束-NOT-NULL" class="headerlink" title="非空约束 NOT NULL"></a>非空约束 NOT NULL</h3><pre><code>某一列值不能为NULL；</code></pre><p>1.创建表时添加约束</p><pre><code>CRETE TABLE stu{    id INT,    name VARCHAR(20) NOT NULL  --name非空}；-- 删除 name的非空约束ALTER TABLE stu  MODIFY NAME VARCHAR(20);</code></pre><p>2 . 创建表后，添加约束</p><pre><code>       ALTER TABLE stu  MODIFY NAME VARCHAR(20) NOT NULL；</code></pre><h3 id="唯一约束"><a href="#唯一约束" class="headerlink" title="唯一约束"></a>唯一约束</h3><pre><code>某一列值不能重复</code></pre><p><strong>注意</strong>：唯一约束可以NULL值，但只能有一条记录为NULL。<br>1.创建表时添加约束</p><pre><code>CRETE TABLE stu{    id INT,    phone_number VARCHAR(20) UNIQUE  --name非空}；-- 删除唯一约束（错误方法 ×），和删除非空约束不太一样ALTER TABLE stu  MODIFY phone_number VARCHAR(20);-- 删除唯一约束的正确操作ALTER TABLE stu DROP INDEX phone_numher;</code></pre><p>2.创建表后添加约束</p><pre><code>ALTER TABLE stu MODIFY phone_number VARCHAR(20) UNIQUE;</code></pre><h3 id="主键约束"><a href="#主键约束" class="headerlink" title="主键约束"></a>主键约束</h3><p>1、注意：</p><pre><code>1.含义：非空且唯一 2.一张表只能有一个字段为主键3.主键是表中记录的唯一标识</code></pre><p>2、创建表时，添加主键约束</p><pre><code>CREATE TABLE stu{    id INT  PRIMARY KEY, -- 给id 添加主键约束    name VARCHAR(20)};</code></pre><p>3、删除主键</p><pre><code>-- 错误做法 alter table stu modify id int;--正确做法,因为只有一个主键，不必指明ALTER TABLE stu DROP PRIMARY KEY;</code></pre><p>4、创建表后，添加主键</p><pre><code>ALTER TABLE stu MODIFY id INT PRIMARY KEY;</code></pre><p>5、自动增长(一般配合主键使用)</p><pre><code>1.概念：如果某一列为数值类型，使用 auto_increment 可以用来完成值的自动增长2.在创建表时，添加主键约束，并且完成主键自增长(和上条记录相关）create table stu{    id int primary key auto_increment, -- 给id 添加主键约束    name varchar(20)};3. --删除自动增长    alter table stu modiy id int;         (并不会删除主键）4. --添加自动增长    alter table stu modiy id int auto_increment;</code></pre><h3 id="外键约束"><a href="#外键约束" class="headerlink" title="外键约束"></a>外键约束</h3><pre><code>让表间产生关系，保证数据的正确性</code></pre><ol><li><p>创建表时，可以添加外键<br>语法：</p><pre><code>create table 表名{    ...    外键列,    constraint 外键名称 foreign key ( 外键列名称) references 主表名称(主表主键名称)}；</code></pre><p>eg:</p><pre><code>--部门表CREATE TBALE department{        id INT PRIMARY KEY AUTO_INCREMENT,        dep_name VARCHAR(20),        dep_lacation VARCHAR(20)};--创建员工表    多方、从表CREATE TBALE employee{        id INT PRIMARY KEY AUTO_INCREMENT,        name VARCHAR(20),        age INT,        dep_id INT，    -- 外键对应主表的主键        CONSTRAINT emp_dept_fk FOREIGN KEY(dep_id) REFERENCES department(id);};</code></pre></li><li><p>删除外键</p><pre><code> ALTER TABLE 表名 DROP FOREIGN KEY 外键名称;</code></pre></li><li><p>添加外键</p><pre><code>ALTER TABLE 表名ADD CONSTRAINT 外键名称 FOREIGN   KEY(外键字段名称) REFERENCES 主表名称(主表列名称);</code></pre></li></ol><p>4.级联操作<br>    添加外键时设置级联更新<br>    1.语法：</p><pre><code>        ALTER TABLE 表名        ADD CONSTRAINT 外键名称 FOREIGN   KEY(外键字段名称)         REFERENCES 主表名称(主表列名称)        ON UPDATE CASCADE; --更新</code></pre><p>2.分类：<br>    a.级联更新: ON UPDATE CASCADE （谨慎使用级联)<br>    b.级联删除：ON DELETE CASCADE</p><hr><h2 id="数据库设计"><a href="#数据库设计" class="headerlink" title="数据库设计"></a>数据库设计</h2><h3 id="一-多表之间的关系"><a href="#一-多表之间的关系" class="headerlink" title="一.多表之间的关系"></a>一.多表之间的关系</h3><pre><code>   A.  分类        1.一对一        2.一对多（多对一）            *分析：部分和员工间        3.多对多            *分析：学生和课程选课关系   B.  实现            1.一对多（多对一）            * 实现方式： 在多的一方（从表）建立外键，指向一（主表）的主键        2.多对多 （学生选课）            * 实现方式： 引入中间表             三种方式图解如下  </code></pre><p>一对一关系实现</p><p><img src="http://static.zybuluo.com/Adward-Wang/8vd4dju9cw0au4di3y50ozx4/%E4%B8%80%E5%AF%B9%E4%B8%80%E5%85%B3%E7%B3%BB%E5%AE%9E%E7%8E%B0.bmp" alt="一对一关系实现.bmp-2398.6kB"> </p><p>一对多关系实现            </p><p><img src="http://static.zybuluo.com/Adward-Wang/0y7a3l32se7hnuevbnntdco5/%E4%B8%80%E5%AF%B9%E5%A4%9A%E5%85%B3%E7%B3%BB%E5%AE%9E%E7%8E%B0.bmp" alt="一对多关系实现.bmp-2398.6kB"></p><p> 多对多关系实现</p><p><img src="http://static.zybuluo.com/Adward-Wang/wdwicrsnmlqaod5kl4hqxqdj/%E5%A4%9A%E5%AF%B9%E5%A4%9A%E5%85%B3%E7%B3%BB%E5%AE%9E%E7%8E%B0.bmp" alt="多对多关系实现.bmp-2398.6kB"></p><h3 id="二-数据库设计范式"><a href="#二-数据库设计范式" class="headerlink" title="二.数据库设计范式"></a>二.数据库设计范式</h3><p>1、第一范式（1NF）：数据库表的每一列都是不可分割的原子数据项<br>2、第二范式（2NF）<br>在1NF的基础上，非码属性必须完全依赖于候选码（在1NF基础上消除非主属性对主码的部分函数依赖）<br>3、第三范式（3NF）<br>在2NF基础上，任何非主属性不依赖于其它非主属性（在2NF基础上消除传递依赖）</p><p><strong>对三大范式的通俗理解:</strong></p><pre><code>1.第一范式：    原子性，不可分割2.第二范式：    消除部分依赖（通过表的拆分）3.第三范式：    消除传递依赖（还是通过表的拆分）*** 几个概念        1.函数依赖： A--&gt;B ,如果通过A属性的值，可以确定唯一B属性的值，则称B依赖于A    例如： 学号 --&gt; 姓名  (学号，课程名称） --&gt;分数     2.完全函数依赖： A --&gt; B, 如果A 是一个属性组， 则B属性值的确定需要依赖于A属性组中所有属性的值。    例如 （学号， 课程名称） --&gt;  分数     3.部分函数依赖： A --&gt; B, 如果A是一个属性组，则B属性值的确定只需要依赖A属性组中的某一些值即可。    例如： （学号, 课程名称) --&gt; 姓名     4.传递函数依赖： A--&gt; B, B --&gt;C， 如果通过A属性（属性组）的值，可以确定唯一B属性的值，再通过B属性（属性组）的值可以确定唯一C属性的值，则称C传递函数依赖于 A.     例如： 学号 --&gt; 系名 --&gt; 系主任     5.码： 如果一张表中，一个属性或者属性组 被 其他所有属性所完全依赖，则称这个属性（属性值）为该笔的码。     例如：该表中为（学号，课程名称）            * 主属性： 码属性组中的所有属性            * 非主属性： 不是码中的属性</code></pre><h3 id="数据库的备份和还原"><a href="#数据库的备份和还原" class="headerlink" title="数据库的备份和还原"></a>数据库的备份和还原</h3><p>1.命令行：</p><pre><code>备份语法： mysqldump -u用户名 -p密码 数据库名称 &gt;保存路径还原：     1.登录数据库    2.创建数据库   create database ***    3.使用数据库   use ***    4.执行文件（ source  数据库路径）</code></pre><p>2.图形界面<br>    导出sql 文件<br>    用Navicat导入时，我发现不能直接导入数据，必须新建数据库，再在表里右键选择导入sql  文件。</p><hr><h2 id="总结："><a href="#总结：" class="headerlink" title="总结："></a>总结：</h2><p>这算是在MySQL 基础上进一步说了一些知识了，关于 范式的内容也明白清晰了不少，还是觉得sql语句应该多用才能孰能生巧，并且应用到实际开发过程中，不能纸上谈兵！！！</p>]]></content>
      
      
      <categories>
          
          <category> 数据库 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> MySQL </tag>
            
            <tag> SQL </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java 基础</title>
      <link href="/2020/03/14/title-java-ji-chu/"/>
      <url>/2020/03/14/title-java-ji-chu/</url>
      
        <content type="html"><![CDATA[<h2 id="Day04"><a href="#Day04" class="headerlink" title="Day04"></a>Day04</h2><h3 id="IntelliJ使用小技巧"><a href="#IntelliJ使用小技巧" class="headerlink" title="IntelliJ使用小技巧"></a>IntelliJ使用小技巧</h3><ul><li>输入<code>Psvm</code>自动生成主方法入口</li><li>输入<code>sout</code>自动生成输出语句</li><li>Alt 加数字 4 打开运行输出框</li><li>快捷键设置 Settings - Keymap - Default copy - Code - Completion - Basic(打开提示信息）</li><li>x.fori自动生成 x次for循环</li><li>shift + F6 修改同一变量 </li></ul><h3 id="Intellij-常用快捷键"><a href="#Intellij-常用快捷键" class="headerlink" title="Intellij 常用快捷键"></a>Intellij 常用快捷键</h3><ul><li><code>Alt+Enter</code> 导入包，自动修正代码</li><li><code>Ctrl+Y</code> 删除光标所在行</li><li><code>Ctrl+D</code> 复制光标所在行的内容，插入光标位置下面</li><li><code>Ctrl+Alt+L</code> 格式化代码 （实用）</li><li><code>Ctrl+/</code> 单行注释</li><li><code>Ctrl+Shift+/</code> 选中代码注释，多行注释，再按取消注释</li><li><code>Alt+Ins</code> 自动生成代码，toString，get，set等方法</li><li><code>Alt+Shift+上下箭头</code> 移动当前代码行</li></ul><p>IntelliJ自动保存代码修改</p><p><strong>导入Module:</strong> File -&gt; Project Settings -&gt; Modules -&gt; Import…</p><h3 id="方法的定义格式"><a href="#方法的定义格式" class="headerlink" title="方法的定义格式"></a>方法的定义格式</h3><pre><code>/*方法其实就是若干语句的功能集合*/</code></pre><p>参数 + 返回值  </p><p>定义方法的完整格式：</p><pre><code>修饰符 返回值类型 方法名称（参数类型 参数名称, ...){方法体return 返回值;}</code></pre><h3 id="方法重载（Overload"><a href="#方法重载（Overload" class="headerlink" title="方法重载（Overload)"></a>方法重载（Overload)</h3><p>对于功能相似的方法，方法的名称一样，但是参数列表不一样。 调用时根据输入的参数来对应。</p><p><strong>注意事项：</strong>方法重载与下列因素相关<br>1.参数个数不同<br>2.参数类型不同<br>3.参数多类型顺序不同（int double 与 double int）</p><p><strong>注意事项：</strong>方法重载与下列因素相关<br>1.与参数名称无关<br>2.与方法返回值类型无关！错误写法，区分不开。</p><hr><h2 id="Day05-数组"><a href="#Day05-数组" class="headerlink" title="Day05 数组"></a>Day05 数组</h2><h3 id="数组初始化"><a href="#数组初始化" class="headerlink" title="数组初始化"></a>数组初始化</h3><p>1.动态初始化（指定长度）： </p><pre><code>//动态初始化元素有默认值</code></pre><p>数据类型 [] 数组名称 = new 数据类型[数组长度]</p><pre><code>int []arrays = new int[5];</code></pre><p>2.静态初始化（指定内容,自动推算长度）:</p><p>数据类型 [] 数组名称 = new 数据类型[] {元素1， 元素2  …};</p><pre><code>int[] arrayA = new int[] {5, 15, 25};String[] arrayB = new String[]{ &quot;hello&quot;, &quot;world&quot;};</code></pre><p>省略版：<br>  数据类型 [] 数组名称 = {元素1， 元素2， …};</p><pre><code>  int[] arrayC = {10， 20， 30}；</code></pre><p><strong>PS：</strong>静态、动态初始化标准格式均可以拆分成两个步骤。但静态初始化省略格式不可以拆。</p><pre><code>int [] arrayA ;array = new int[]{5, 15, 25};</code></pre><p><strong>PS：</strong> 直接打印数组名称，得到的是数组对应的内存地址哈希值。</p><h3 id="Java中的内存划分"><a href="#Java中的内存划分" class="headerlink" title="Java中的内存划分"></a>Java中的内存划分</h3><p>Java的内存划分为5个部分</p><pre><code>1.栈（Stack): 存放的都是方法中得局部变量。方法的运行一定要在栈当中运行！    局部变量：方法的参数，或者是方法{}内部的变量    作用域：一旦超出作用域，立刻从栈内存中消失。2.堆（Heap):凡是new出来的东西，都在堆当中。    堆内存里面的东西都有一个地址值：16进制    堆内存里面的数据，都有默认值。规则...3.方法区（Method Area): 存储 .class相关信息，包含方法的信息。4.本地方法栈(Native Method Stack): 与操作系统相关。5.寄存器（pc Register): 与CPU相关。</code></pre><h3 id="数组长度"><a href="#数组长度" class="headerlink" title="数组长度"></a>数组长度</h3><p>Array.length();<br>数组一旦创建，程序运行期间，长度不可改变。</p><hr><h2 id="Day06-类、对象、封装、构造方法、"><a href="#Day06-类、对象、封装、构造方法、" class="headerlink" title="Day06 类、对象、封装、构造方法、"></a>Day06 类、对象、封装、构造方法、</h2><h3 id="面向对象三大基本特征"><a href="#面向对象三大基本特征" class="headerlink" title="面向对象三大基本特征"></a>面向对象三大基本特征</h3><pre><code>封装、继承、多态</code></pre><h3 id="类"><a href="#类" class="headerlink" title="类"></a>类</h3><ul><li>包括 属性 和 行为；</li><li>类是对象的模板，对象是类的实例。</li><li>成员方法不能用 static 关键字修饰  public void </li><li>成员变量 直接定义在类内，在方法外。</li></ul><h3 id="类的使用"><a href="#类的使用" class="headerlink" title="类的使用"></a>类的使用</h3><ol><li>导入包： 之处需要使用的类的位置</li></ol><pre><code>    import 包名称.类名称;    import  xyz.enforcerK.demo1.Student;对于和当前类属于同一包的情况，可以省略导入语句。</code></pre><ol start="2"><li><p>创建：</p><pre><code> 格式：  类名称   对象名 = new  类名称; Studnet stu = new Student();</code></pre></li><li><p>使用：</p></li></ol><pre><code>    使用成员变量：  对象名.成员变量    使用成员方法：  对象名.成员方法名（参数）</code></pre><p><strong>PS：</strong> 使用对象类型作为方法的返回值<br>返回的是对象的地址</p><h3 id="成员变量和局部变量的区别"><a href="#成员变量和局部变量的区别" class="headerlink" title="成员变量和局部变量的区别"></a>成员变量和局部变量的区别</h3><p><strong>1.定义位置不同</strong><br>局部变量：在方法的内部<br>成员变量：在方法的外部，直接写在类当中</p><p><strong>2.作用域不同</strong><br>局部变量：只有在方法当中可以用<br>成员变量：整个类全部可以通用</p><p><strong>3.默认值不同</strong><br>局部变量：没有默认值，若使用，必须手动进行赋值。<br>成员变量：有默认值，规则和数组相同。</p><p>4.内存中位置不同<br>局部变量：位于栈内存<br>成员变量：位于堆内存</p><p>5.生命周期不同<br>局部变量：随着方法进栈而诞生，随着方法出栈而消失。<br>成员变量：随着对象创建而诞生，随着对象被垃圾回收而消失。</p><h3 id="面向对象的封装性"><a href="#面向对象的封装性" class="headerlink" title="面向对象的封装性"></a>面向对象的封装性</h3><p>封装在Java中的体现：（将细节隐藏，对外界不可见） </p><ol><li><p>方法就是一种封装</p></li><li><p>关键字 <code>private</code> 也是一种封装。（在本类中仍可正常访问，但是超出范围不能再<strong>直接</strong>访问，可以用 setter、 getter(boolean类型用is<em>*</em>)方法间接访问 ） </p><h3 id="this-关键字"><a href="#this-关键字" class="headerlink" title="this 关键字"></a>this 关键字</h3><p>this.<em>*</em>    用于重名时区分成员变量和局部变量<br>通过谁调用的方法，谁就是this. </p></li></ol><h3 id="构造方法"><a href="#构造方法" class="headerlink" title="构造方法"></a>构造方法</h3><p>构造方法是专门用来创建对象的方法，<strong>当我们通过关键字new来创建对象时，其实就是在调用构造方法。</strong></p><pre><code>public 类名称(参数类型 参数名称）{    方法体}</code></pre><p><strong>注意事项：</strong><br>1.构造方法的名称必须和所在的类名称完全一样，包括大小写<br>2.构造方法不要写返回值类型，void也不用<br>3.构造方法不能return返回值<br>4.没有编写任何构造方法，编译器会默认构造一个无任何功能的构造方法<br>5.一旦编写了<strong>至少一个</strong>构造方法，编译器将不会默认构造。<br>6.构造方法可以重载（方法名相同，参数列表不同）</p><pre><code>public class Student{    public Student(){        System.out.println(&quot;构造方法执行啦!&quot;);     }}</code></pre><h3 id="定义一个标准的类"><a href="#定义一个标准的类" class="headerlink" title="定义一个标准的类"></a>定义一个标准的类</h3><p>一个标准的类通常由以下四个部分组成</p><p>1.所有的成员边拉你个都要使用private 关键字修饰</p><ol start="2"><li>为每一个成员变量编写一对Getter/Setter 方法</li><li>编写一个无参数的构造方法</li><li>编写一个全参数的构造方法</li></ol><p>这样标准的类也叫作 Java Bean</p><p>使用 <code>Code -&gt; Generate</code> 或 <code>Alt + Insert</code> 自动生成 Getter/Setter方法。</p><p>Generate 里面的 Constructor 生成 None/全选 生成 无参或全参构造方法。 </p><hr><h2 id="Day07-Scanner类-、Random类、-ArrayList类"><a href="#Day07-Scanner类-、Random类、-ArrayList类" class="headerlink" title="Day07 Scanner类 、Random类、 ArrayList类"></a>Day07 Scanner类 、Random类、 ArrayList类</h2><p>java.lang包下的内容不需要手动导入</p><h3 id="Scanner类"><a href="#Scanner类" class="headerlink" title="Scanner类"></a>Scanner类</h3><pre><code>import java.util.Scanner;Scannner sc = new Scanner(System.in);int num  = sc.nextInt();String str = sc. next();</code></pre><h3 id="匿名对象"><a href="#匿名对象" class="headerlink" title="匿名对象"></a>匿名对象</h3><p>格式： <code>new 类名称;</code><br>new 类名().方法() = “ “;</p><p><strong>PS:</strong> 匿名对象只有使用一次，如果确定有一个对象只需要使用唯一的一次，就可以使用匿名对象。</p><h4 id="匿名对象作为函数的参数和返回值"><a href="#匿名对象作为函数的参数和返回值" class="headerlink" title="匿名对象作为函数的参数和返回值"></a>匿名对象作为函数的参数和返回值</h4><h3 id="Random类"><a href="#Random类" class="headerlink" title="Random类"></a>Random类</h3><p>用来生成随机数</p><pre><code>import java.util.Random;Random r = new Random();    //留空即可int num = r.nextInt();</code></pre><h4 id="Random类生成指定范围内数字"><a href="#Random类生成指定范围内数字" class="headerlink" title="Random类生成指定范围内数字"></a>Random类生成指定范围内数字</h4><pre><code>int num = r.nextInt(bound: 3); //左闭右开  生成 0, 1, 2中随机数</code></pre><p>整体加一 生成[1, bound]</p><h3 id="ArrayList集合"><a href="#ArrayList集合" class="headerlink" title="ArrayList集合"></a>ArrayList集合</h3><pre><code>数组长度不可变，ArrayList 可变</code></pre><p>ArrayList &lt; E:泛型&gt;<br><strong>泛型：</strong> 装在集合内的所有元素，都是统一类型。</p><p><strong>PS:</strong><br>1.泛型只能是引用类型，不能是基本类型。<br>2.对于ArrayList 集合来说，直接打印得到的不是地址，是内容，若内容为空，打印的是 [];</p><pre><code>import java.util.ArrayList;// 从jdk1.7+开始，右侧尖括号内可不写内容，但是尖括号不可省略。ArrayList &lt;String&gt; list = new ArrayList&lt;&gt;();System.out.println(lsit); //[]//向集合中添加一些数据list.add(&quot;AA&quot;);sout(list); //[AA]list.add(&quot;BB&quot;);list.add(&quot;CC&quot;);sout(list); //[AA, BB, CC]</code></pre><h4 id="ArrayList常用方法"><a href="#ArrayList常用方法" class="headerlink" title="ArrayList常用方法"></a>ArrayList常用方法</h4><p><code>public boolean add(E e):</code> 向集合中添加元素，参数类型和泛型一致。<br><code>public E get(int index):</code> 从集合中获取元素，参数是索引编号，返回对应位置元素。<br><code>public E remove(int index):</code> 从集合当中删除元素，参数是索引编号，返回值就是被删除的元素。<br><code>public int size():</code> 获取集合的尺寸长度，即返回值就是集合当中包含的元素个数。</p><p><strong>PS：</strong> ArrayList 中的add 方法一定会成功，其他的集合类型不一定。    </p><h4 id="用ArrayList存储基本类型"><a href="#用ArrayList存储基本类型" class="headerlink" title="用ArrayList存储基本类型"></a>用ArrayList存储基本类型</h4><p>得使用包装类</p><pre><code>/*基本类型    包装类（引用类型，包装类都位于java.lang 包下） byte         Byteshort       Short    int         Integerlong        Longchar        Characterfloat       Floatdouble      Doubleboolean     Boolean*/</code></pre><p>//从jdk 1.5+ 支持自动装箱、自动拆箱<br>自动装箱：  基本类型    -&gt;  包装类型<br>自动拆箱：  包装类型    -&gt;  基本类型</p><pre><code>ArrayList &lt;Integer&gt; List = new ArrayList&lt;&gt;();list.add(100);list.add(200):sout(list); //[100, 200]int num = list.get(1);  //200</code></pre><hr><h2 id="Day08-String类、static、-Arrays类、Math类"><a href="#Day08-String类、static、-Arrays类、Math类" class="headerlink" title="Day08 String类、static、 Arrays类、Math类"></a>Day08 String类、static、 Arrays类、Math类</h2><h3 id="String-类"><a href="#String-类" class="headerlink" title="String 类"></a>String 类</h3><p>字符串是常量，创建后不可修改，故可共享使用。<br>效果上相当于char[]字符数组，但底层原理是byte[]字节数组</p><h4 id="创建字符串的常见-3-1-种方式"><a href="#创建字符串的常见-3-1-种方式" class="headerlink" title="创建字符串的常见 3 +1 种方式"></a>创建字符串的常见 3 +1 种方式</h4><p><strong>三种构造方法：</strong><br>1.public String(): 创建一个空白字符串，不含任何内容<br>2.public String(char [] array): 根据字符数组的内容，来创建对应的字符串<br>3.public String(byte[] array):根据字节数组的内容，来创建对应的字符串。<br><strong>一种直接创建：</strong><br>String str = “Hello”;//直接””无需new</p><h4 id="字符串的常量池"><a href="#字符串的常量池" class="headerlink" title="字符串的常量池"></a>字符串的常量池</h4><p>程序当中直接双引号创建的字符串就在字符串常量池中（堆内存中）。</p><p><strong>PS:</strong><br>1.对于引用类型来说，==进行的是地址值得比较。<br>2.双引号直接写的字符串在常量池中，new的不在常量池中。</p><h4 id="字符串内容常见比较方法"><a href="#字符串内容常见比较方法" class="headerlink" title="字符串内容常见比较方法"></a>字符串内容常见比较方法</h4><p><code>public boolean equals(Object obj):</code>参数可以是任何对象，只有参数是一个字符串并且内容相同才会返回true，否则返回 false;<br><code>public boolean equalsIgnoreCase(String str): //英文大小写</code> 忽略大小写，进行内容比较。</p><p><strong>注意事项：</strong><br>1.任何对象都能用Object进行接收<br>2.equals方法具有对称性，即a.equals(b) 和 b.equals(a) 效果相同<br>3.若比较一个常量与一个变量，建议将常量写在前面（细节，否则空指针异常错误 ）</p><h4 id="字符串常用获取方法"><a href="#字符串常用获取方法" class="headerlink" title="字符串常用获取方法"></a>字符串常用获取方法</h4><p><code>public int length():</code> 获取字符串当中含有的字符个数，返回字符串长度<br><code>public string concat(String str):</code>将当前字符串和参数字符串拼接返回新的字符串。<br><code>public char charAt(int index):</code>获取指定索引位置的单个字符（索引从0开始）<br><code>public int indexof(String str):</code> 查找参数字符串在本字符串当中首次出现的索引位置，若没有返回-1</p><h4 id="字符串截取方法"><a href="#字符串截取方法" class="headerlink" title="字符串截取方法"></a>字符串截取方法</h4><p><code>public String substring(int index):</code>截取从参数位置一直到字符串末尾，返回新字符串；<br><code>public String substring(int begin, int end):</code>截取从begin开始，一直到end结束（左闭右开)</p><h4 id="字符串转换相关方法"><a href="#字符串转换相关方法" class="headerlink" title="字符串转换相关方法"></a>字符串转换相关方法</h4><p><code>public char[] toCharArray():</code> 将当前字符串拆分成字符数组作为返回值；<br><code>public byte[] getBytes():</code> 获得当前字符串底层的字节数组；<br><code>public String replace(charSequence ldString, charSequence newString):</code>将所有出现的老字符串替换成为新的字符串，返回替换之后的结果新字符串，备注：charSequence表示可以接受字符串类型；</p><h4 id="字符串分割方法"><a href="#字符串分割方法" class="headerlink" title="字符串分割方法"></a>字符串分割方法</h4><p><code>public String [] split(String regx):</code>按照参数规则，将字符串切分成为若干部分。</p><p><strong>注意：</strong><br>split方法的参数其实是一个正则表达式，若要用英文”.”进行切分，必须写”\.“(两个反斜杠)</p><h3 id="静态static-关键字"><a href="#静态static-关键字" class="headerlink" title="静态static 关键字"></a>静态static 关键字</h3><p>一旦用了static 关键字，那么这样的内容不再属于对象自己，而是<strong>属于类</strong>，所以凡是本类的对象，都<strong>共享一份数据</strong>。</p><h4 id="static-修饰成员变量"><a href="#static-修饰成员变量" class="headerlink" title="static 修饰成员变量"></a>static 修饰成员变量</h4><p>一改全改，全员共享，用作计数。</p><h4 id="static-修饰成员方法"><a href="#static-修饰成员方法" class="headerlink" title="static 修饰成员方法"></a>static 修饰成员方法</h4><p>一旦使用static 修饰成员方法，那么这就成为了静态方法。静态方法不属于对象，而属于类。</p><p>若没有static 关键字，必须首先创建对象，然后通过对象才能使用它。而对于静态方法来说，可以通过对象名进行调用，也可以直接通过类名称来调用（推荐使用)。</p><p>无论是成员变量还是成员方法，若有了static关键字，都推荐通过类名称来进行调用。（本类中的静态方法可以省略类名称）<br><strong>PS：</strong><br>1.静态方法不能直接访问非静态变量（因为在内存中先有静态内容，后有非静态内容）<br>2.静态方法中不能用<code>this</code>关键字,this代表当前对象</p><h4 id="static-内存图-amp-amp-静态代码块"><a href="#static-内存图-amp-amp-静态代码块" class="headerlink" title="static 内存图&amp;&amp; 静态代码块"></a>static 内存图&amp;&amp; 静态代码块</h4><p>方法区中有一块静态区<br><strong>格式：</strong></p><pre><code>public class 类名称{    static{        //静态代码块内容    }}</code></pre><p><strong>特点：</strong><br>当第一次用到本类时，静态代码块执行唯一的一次。静态内容总是优先于非静态内容，所以静态代码块比构造方法先执行。</p><p><strong>静态代码块的典型用途:</strong><br>用来一次性地对静态成员变量进行赋值。</p><h3 id="数组工具类-Arrays"><a href="#数组工具类-Arrays" class="headerlink" title="数组工具类 Arrays"></a>数组工具类 Arrays</h3><p>java.util.Arrays是一个与数组有关的工具类，里面提供了大量静态方法，用来实现数组常见操作。</p><p><code>public static String toString(数组):</code>将参数数组编程字符串（按照默认格式:[元素1，元素2，…])<br><code>public static void sort(数组):</code>按照默认升序对数组元素进行排序</p><p><strong>备注：</strong><br>1.若是数值，sort默认按升序<br>2.若是字符串，按字母升序<br>3.若是自定义的类型，那么这个类需要comparable接口</p><h3 id="数学工具类-Math"><a href="#数学工具类-Math" class="headerlink" title="数学工具类 Math"></a>数学工具类 Math</h3><p>java.util.Math 提供大量的静态方法，完成与数学运算相关的操作。</p><p><code>public static double abs(double num):</code>获取绝对值，有多种重载<br><code>public static double ceil(double num):</code>向上取整<br><code>public statci double floor(double num):</code>向下取整<br><code>public static long round(double num):</code>四舍五入</p><p>Math.PI 代表近似的圆周率常量</p><hr><h2 id="Day09-继承、super、this、抽象类"><a href="#Day09-继承、super、this、抽象类" class="headerlink" title="Day09 继承、super、this、抽象类"></a>Day09 继承、super、this、抽象类</h2><p>继承主要解决的问题： <strong>共性抽取</strong></p><h3 id="继承的格式"><a href="#继承的格式" class="headerlink" title="继承的格式"></a>继承的格式</h3><pre><code>public class 父类名称{    //...}public class 子类名称 extends 父类名称{    //...}</code></pre><h3 id="继承中成员变量的访问特点"><a href="#继承中成员变量的访问特点" class="headerlink" title="继承中成员变量的访问特点"></a>继承中成员变量的访问特点</h3><p>当子父类中有重名变量时，则创建子类对象时，访问有两种方式：<br>1.直接通过子类对象访问成员变量：<br>    等号左边（定义时）是谁，就优先用谁，没有则向上找。<br>2.间接通过成员方法访问成员变量：<br>    该方法属于谁，就优先用谁，没有则向上找。</p><h3 id="区分子类方法中重名的三种变量"><a href="#区分子类方法中重名的三种变量" class="headerlink" title="区分子类方法中重名的三种变量"></a>区分子类方法中重名的三种变量</h3><p>局部变量：          直接写成员变量名<br>本类的成员变量：    this.成员变量名<br>父类的成员变量：    super.成员变量名</p><h3 id="继承中成员方法的访问特点"><a href="#继承中成员方法的访问特点" class="headerlink" title="继承中成员方法的访问特点"></a>继承中成员方法的访问特点</h3><p>若重名怎么办？？？<br>创建的对象（new的)是谁，就优先用谁，若没有则向上找。<br><strong>注意：</strong>无论是成员方法还是成员变量，如果没有都是向上找父类，绝对不会向下找子类。</p><h3 id="继承中方法的覆盖重写（override"><a href="#继承中方法的覆盖重写（override" class="headerlink" title="继承中方法的覆盖重写（override)"></a>继承中方法的覆盖重写（override)</h3><p><strong>概念：</strong>在继承关系当中，方法名称一样，参数列表也一样。<br><strong>重写（Override):</strong> 方法名称相同，参数列表 也一样。覆盖、覆写。<br><strong>重载 (Overload):</strong> 方法名称一样，参数列表 不一样。<br><strong>方法的覆盖重写特点：</strong> 创建的是子类对象，则优先用子类方法。</p><p><strong>覆盖重写的注意事项：</strong><br>1.必须保证父子类之间方法的名称相同，参数列表也相同。<br> @Override 写在方法前面，用来检测是否为有效的覆盖重写方法，（可不写）<br>2.子类方法的返回值类型必须 <strong>小于等于</strong> 父类方法的返回值范围。String &lt; Object<br>3.子类方法的权限必须 <strong>大于等于</strong> 父类方法的权限修饰符。<br>public &gt; protected &gt; (default) &gt; private<br><strong>备注</strong>： default 不是关键字，而是什么都不写，留空。</p><h3 id="方法的覆盖重写-应用场景"><a href="#方法的覆盖重写-应用场景" class="headerlink" title="方法的覆盖重写_应用场景"></a>方法的覆盖重写_应用场景</h3><p><strong>设计原则：</strong> 对于已经投入使用的类，尽量不要进行修改，推荐定义一个新的类，来重复利用其中共性内容，并且添加改动新内容。直接使用super.方法名复用代码。</p><h3 id="继承中，父子类构造方法的访问特点"><a href="#继承中，父子类构造方法的访问特点" class="headerlink" title="继承中，父子类构造方法的访问特点"></a>继承中，父子类构造方法的访问特点</h3><p>1.子类构造方法中有一个默认隐含的”super调用”, 所以一定是先调用的父类构造方法，后执行的子类构造。<br>2.子类构造可以通过super关键字来调用父类重载构造。<br>3.super的父类构造调用，必须是子类构造方法的第一个语句。且一个子类构造方法不能调用多次super构造。<br><strong>总结：</strong><br>子类必须调用父类构造方法，不写则默认有一个super():写了则用写的指定的super调用，super只能有一个，还必须是第一个。</p><h3 id="super-关键字的三种用法"><a href="#super-关键字的三种用法" class="headerlink" title="super 关键字的三种用法"></a>super 关键字的三种用法</h3><p>1.在子类的成员方法中，访问父类的成员变量。<br>2.在子类的成员方法中，访问父类的成员方法。<br>3.在子类的构造方法中，访问父类的构造方法。</p><h3 id="this-关键字的三种用法"><a href="#this-关键字的三种用法" class="headerlink" title="this 关键字的三种用法"></a>this 关键字的三种用法</h3><p>1.在本类的成员方法中，访问本类的成员变量（Not局部变量).<br>2.在本类的成员方法中，访问本类的另一个成员方法（this可省略的)。<br>3.在本类的构造方法中，访问本类的另一个构造方法。<br>（注意：<br>A. this调用也必须是构造方法的第一个语句，唯一一个.<br>B.super和this两种构造调用，不能同时使用）</p><h3 id="java继承的三个特点"><a href="#java继承的三个特点" class="headerlink" title="java继承的三个特点"></a>java继承的三个特点</h3><p>1.单继承，唯一直接父类<br>2.可以多级继承，父类的父类（也叫父类）. java.lang.Object是所有类的祖先类<br>3.一个子类的直接父类是唯一的，但是一个父类可以有很多子类。</p><h3 id="抽象的概念"><a href="#抽象的概念" class="headerlink" title="抽象的概念"></a>抽象的概念</h3><pre><code>图形{    计算面积的方法//抽象方法}正方形、三角形、图形动物{    吃东西的方式//抽象方法}狗吃骨头、猫吃鱼</code></pre><p>如果父类当中的方法不确定如何进行{}方法体实现，那么这应该是就是一个<code>抽象方法</code>。</p><h3 id="抽象方法-和-抽象类"><a href="#抽象方法-和-抽象类" class="headerlink" title="抽象方法 和 抽象类"></a>抽象方法 和 抽象类</h3><p>抽象方法： 返回值类型前加上 <code>abstract</code> 关键字，不写方法体具体内容</p><p>抽象方法所在的类必须是抽行类才行，在class 前加上 abstract 即可。抽象类可以有普通方法。</p><h3 id="抽象类、抽象方法的使用"><a href="#抽象类、抽象方法的使用" class="headerlink" title="抽象类、抽象方法的使用"></a>抽象类、抽象方法的使用</h3><p>1、不能直接创建new 抽象类对象<br>2、必须用一个子类来继承抽象父类<br>3、子类必须覆盖重写抽象父类当中的所有抽象方法。覆盖重写（实现）：去掉抽象方法中的 abstract 关键字，加上方法体。<br>4、创建子类对象进行使用</p><p><strong>注意事项：</strong><br>1.抽象类不能创建对象。<br>2.抽象类中，可以有构造方法，是供子类创建对象时，初始化父类成员使用的。<br>3.<strong>抽象类中，不一定含有抽象方法</strong>，但是有抽象方法的类必定是抽象类。（通常用于某些特殊的类结构设计、设计模式中的适配器模式）<br>4.抽象类的子类，<strong>必须</strong>重写抽象父类中<strong>所有</strong>的抽象方法。否则子类也是一个抽象类。</p><hr><h2 id="Day10-接口、多态"><a href="#Day10-接口、多态" class="headerlink" title="Day10_接口、多态"></a>Day10_接口、多态</h2><p>接口就是一种<strong>公共的规范标准</strong>，只要符合规范标准，就可以通用</p><h3 id="接口的定义基本格式"><a href="#接口的定义基本格式" class="headerlink" title="接口的定义基本格式"></a>接口的定义基本格式</h3><p>/<em>接口就是多个类的公共规范，是一种引用类型，最重要的就是其中的：抽象方法 </em>/</p><p>基本格式：</p><pre><code>public interface 接口名称{    //接口内容}</code></pre><p>接口生成的字节码文件仍然是.class</p><p>若是Java7，那么接口中可以包含：<br>1.常量<br>2.抽象方法</p><p>若是Java8，还可以额外包含有：<br>3.默认方法<br>4.静态方法</p><p>若是Java9,还可以额外包含有：<br>5.私有方法<br>共5种</p><h3 id="接口中抽象方法的定义与使用"><a href="#接口中抽象方法的定义与使用" class="headerlink" title="接口中抽象方法的定义与使用"></a>接口中抽象方法的定义与使用</h3><p>//任何版本的Java 接口中都可以定义抽象方法<br>格式：</p><pre><code>public abstract 返回值类型 方法名称（参数列表）;eg:    public interface MyInterfaceAbstract{            public abstract void methodAbs1();            abstract void methodAbs2();            public void methodAbs3();            void methodAbs4();    }</code></pre><p><strong>注意：</strong><br>1.接口当中的抽象方法，修饰符必须是两个固定的关键字:public abstract<br>2.这两个关键字修饰符，可以选择性地省略。<br>3.方法的三要素，可以随意定义</p><p><strong>接口使用步骤：</strong><br>1.接口不能直接使用，必须有一个实现类来实现该接口。<br>格式：</p><pre><code>public class 实现类名称 implements 接口名称{        //...}</code></pre><p>2.接口的实现类必须覆盖重写（实现）接口中的所有抽象方法（Alt +Enter 快速插入)<br>实现：去掉abstract关键字，加上方法体。<br>3.创建实现类的对象，来进行使用</p><p><strong>注意：</strong><br>如果实现类没有覆盖重写接口中所有的抽象方法，那么这个实现类自己必须是抽象类。</p><h3 id="接口中默认方法的定义与使用"><a href="#接口中默认方法的定义与使用" class="headerlink" title="接口中默认方法的定义与使用"></a>接口中默认方法的定义与使用</h3><p>// 从Java 8开始，接口中可以定义默认方法</p><p><strong>格式：</strong></p><pre><code>public default 返回值类型 方法名称（参数列表）{    方法体}</code></pre><p><strong>备注：</strong><br>接口中的默认方法，可以解决接口升级问题。（接口添加方法，已有的实现类无需做修改）</p><p>默认方法会被实现类继承下去，实现类对象进行调用默认方法，如果实现类中没有，会向上在接口里找。</p><p>即：<br>/<em><br>1.接口的默认方法，可以通过接口实现类对象，直接调用。<br>2.接口的默认方法，也可以被接口实现类进行<em>*覆盖重写</em></em>。</p><h3 id="接口的静态方法定义与使用"><a href="#接口的静态方法定义与使用" class="headerlink" title="接口的静态方法定义与使用"></a>接口的静态方法定义与使用</h3><p>// Java8开始</p><p>格式:</p><pre><code>public static 返回值类型 方法名称(参数列表){            方法体}</code></pre><p><strong>注意：</strong><br>不能通过接口实现类的对象来调用接口当中的静态方法。</p><p><strong>正确用法：</strong><br>通过接口名称，直接调用其中的静态方法。</p><p><strong>格式：</strong></p><pre><code>接口名称.静态方法名(参数);</code></pre><h3 id="接口中私有方法的定义与使用"><a href="#接口中私有方法的定义与使用" class="headerlink" title="接口中私有方法的定义与使用"></a>接口中私有方法的定义与使用</h3><p>/*<br>问题描述:<br>我们需要抽取一个共有方法，用来解决两个默认方法之间重复代码的问题。<br>但是这个共有方法不应该让实现类使用,应是私有化的。</p><p>从java 9 开始，接口中允许定义私有方法。<br>1.普通私有方法，解决多个默认方法之间有重复代码问题。<br>格式：</p><pre><code>private 返回值类型 方法名称（参数列表）{    方法体}</code></pre><p>2.静态私有方法，解决多个静态方法之间重复代码的问题<br>格式：</p><pre><code>private static 返回值类型 方法名称（参数列表）{    方法体}</code></pre><p>*/</p><h3 id="接口中常量的定义与使用"><a href="#接口中常量的定义与使用" class="headerlink" title="接口中常量的定义与使用"></a>接口中常量的定义与使用</h3><p>/*<br>接口当中也可以定义“成员变量”，但是必须使用<code>public static final</code> 三个关键字进行修饰。<br>从效果上看，这其实就是接口的 <code>常量</code></p><p><strong>格式：</strong></p><pre><code>public static final 数据类型 常量名称 = 数据值;//一旦赋值，不可修改</code></pre><p><strong>注意事项：</strong><br>1.接口当中的常量，可以省略 public static final, 不写也一样。<br>2.接口当中的常量，必须进行赋值。<br>3.接口中常量的名称，使用完全大写字母，用下划线进行分割。（推荐命名规则）</p><p><strong>使用：</strong><br>接口名称.常来名称；<br>*/</p><h3 id="接口内容小结"><a href="#接口内容小结" class="headerlink" title="接口内容小结"></a>接口内容小结</h3><p>在java 9+ 版本中，接口的内容可以有：</p><p>1.成员变量其实是常量，<br>格式：</p><pre><code>[public] [static] [final] 数据类型 常量名称 = 数据值;</code></pre><p><strong>注意：</strong><br>    常量必须进行赋值，而且一旦赋值不能改变。<br>    常量名称完全大写，用下划线进行分离</p><p>2.接口中最重要的就是抽象方法，格式：</p><pre><code>[public][abstract] 返回值类型 方法名称（参数列表）;</code></pre><p>注意：实现类必须覆盖重写接口的所有抽象方法，除非实现类是抽象类。</p><p>3.从Java 8开始，接口里允许定义默认方法，格式：</p><pre><code>[public] default 返回值类型 方法名称（参数列表）{方法体}</code></pre><p>注意：默认方法也可以被覆盖重写</p><p>4.从Java 8开始，接口中允许定义静态方法，格式：</p><pre><code>[public] static 返回值类型 方法名称（参数列表）{方法体}</code></pre><p>注意： 应该通过接口名称进行调用，不能通过实现类对象调用接口静态方法</p><p>5.从Java 9 开始，接口里允许定义私有方法，格式：<br>普通私有方法：<code>private 返回值类型 方法名称（参数列表）{方法体}</code><br>静态私有方法：<code>private static 返回值类型 方法名称（参数列表）{方法体}</code><br>注意： private 方法只有接口自己才能调用，不能被实现类或者别人使用。</p><h3 id="实现接口注意事项"><a href="#实现接口注意事项" class="headerlink" title="实现接口注意事项"></a>实现接口注意事项</h3><ol><li><p>接口是没有静态代码块或者构造方法的</p></li><li><p>一个类的直接父类是唯一的，但是一个类可以同时实现多个接口。<br>格式：</p><p> public class MyInterfaceImpl implements MyInterfaceA, MyInterfaceB{</p><pre><code> //覆盖重写所有抽象方法</code></pre><p> }</p></li></ol><p>3.如果实现类所实现的多个接口中，存在重复的抽象方法，那么只需要覆盖重写一次即可<br>4.如果实现类没有覆盖重写所有接口当中的所有抽象方法，那么实现类就必须是一个抽象类<br>5.如果实现类所实现的多个接口当中，存在重复的默认方法，那么实现类一定要对冲突的默认方法进行覆盖重写<br>6.一个类如果直接父类当中的方法和接口当中的默认方法产生了冲突，优先用父类当中的方法。</p><h3 id="接口之间的多继承"><a href="#接口之间的多继承" class="headerlink" title="接口之间的多继承"></a>接口之间的多继承</h3><p>/*<br>1.类与类之间是单继承的。直接父类只有一个<br>2.类与接口之间是多实现的，一个类可以实现多个接口<br>3。接口与接口之间是多继承的</p><p><strong>注意事项：</strong><br>1.多个父接口当中的抽象方法如果重复，没关系<br>2.多个父接口中的默认方法如果重复，那么子接口必须进行默认方法的覆盖重写（带default关键字）</p><p>*/</p><h3 id="多态"><a href="#多态" class="headerlink" title="多态"></a>多态</h3><p>/<em><br>代码中体现多态性，用父类引用指向子类对象。(左父右子)<br><em>*格式：</em></em></p><pre><code>父类名称 对象名 = new 子类名称();Fu obj = new Zi();</code></pre><p>或者</p><pre><code>接口名称 对象名 = new 实现类名称();</code></pre><p>*/</p><h4 id="多态中成员变量的使用特点"><a href="#多态中成员变量的使用特点" class="headerlink" title="多态中成员变量的使用特点"></a>多态中成员变量的使用特点</h4><p>/*<br>访问成员变量的两种方式：<br>1.直接通过对象名称访问成员变量：看等号左边是谁，优先用谁，没有则向上找<br>2.间接通过成员方法访问成员变量，看方法属于谁，优先用谁，没有则向上找</p><p>*/</p><pre><code>Fu obj = new Zi();sout(obj.num);  //假设父子类均有num变量,输出父类中的numobj.showNum();//子类没有覆盖重写，就是父：10//子类如果覆盖重写，就是子：20</code></pre><h4 id="多态中成员方法的使用特点"><a href="#多态中成员方法的使用特点" class="headerlink" title="多态中成员方法的使用特点"></a>多态中成员方法的使用特点</h4><p>/*<br>在多态的代码中，成员方法的访问规则：<br>    new的是谁，就优先用谁，没有则向上找。</p><p>成员方法口诀：编译看左边，运行看右边<br>&amp;&amp;成员变量：编译看左边，运行还看左边<br>*/</p><pre><code>Fu obj = new Zi();  //多态obj.method();   //父子都有，优先用子obj.methodFu(); //子类没有，父类有，向上找到父类obj.methodZi();//报错</code></pre><h4 id="使用多态的好处"><a href="#使用多态的好处" class="headerlink" title="使用多态的好处"></a>使用多态的好处</h4><p>无论右边new的时候换成哪个子类对象，等号左边的调用方法都不会变化。</p><h4 id="对象的向上转型"><a href="#对象的向上转型" class="headerlink" title="对象的向上转型"></a>对象的向上转型</h4><p>1.对象的向上转型，其实就是多态写法<br>格式： <code>父类名称 对象名 = new 子类名称（）；</code><br>eg: <code>Animal animal = new Cat();</code><br>含义：右侧创建一个子类对象，将它当做父类来看待使用。<br><strong>注意：向上转型一定是安全的</strong>.</p><h4 id="对象的向下转型"><a href="#对象的向下转型" class="headerlink" title="对象的向下转型"></a>对象的向下转型</h4><p>/*<br>向上转型一定是安全的.<br>但是也有一个弊端：一旦向上转型为父类，那么就无法调用子类原本特有的内容。</p><p>解决方案： 用对象的向下转型 <code>还原</code><br>*/</p><p>对象的向下转型，就是一个还原的动作。<br><strong>格式：</strong></p><pre><code>子类名称 对象名 = （子类名称）父类对象；</code></pre><p><strong>含义</strong>：将父类对象，<strong>还原</strong>为 本来的 子类对象</p><p><strong>注意事项：</strong><br>a.必须保证对象本来创建的时候，就是猫，才能向下转型为猫。<br>b.如果对象创建的时候本来不是猫，向下转为猫，则会报错（这不废话吗？？？）<br>ClassCastException.</p><h4 id="用instanceof-关键字进行类型判断"><a href="#用instanceof-关键字进行类型判断" class="headerlink" title="用instanceof()关键字进行类型判断"></a>用instanceof()关键字进行类型判断</h4><p>Q：如何才能知道一个父类引用的对象，本来是什么子类？？<br>A：<br><strong>格式：</strong> </p><pre><code>对象 instanceof 类</code></pre><p>返回一个boolean值结果，判断前面的对象能不能当做后面类型的实例</p><hr><h2 id="Day11-final-权限-内部类"><a href="#Day11-final-权限-内部类" class="headerlink" title="Day11 final 权限 内部类"></a>Day11 final 权限 内部类</h2><h3 id="final"><a href="#final" class="headerlink" title="final"></a>final</h3><p>final 关键字代表最终的、不可改变的</p><p>常见四种用法：<br>1.用来修饰一个类<br>2.用来修饰一个方法<br>3.用来修饰一个局部变量<br>4.用来修饰一个成员变量</p><h4 id="final-修饰类"><a href="#final-修饰类" class="headerlink" title="final 修饰类"></a>final 修饰类</h4><p> 格式： <code>public final class 类名{}</code><br> 含义：不可被继承<br> 注意： 其中所有成员方法都无法进行覆盖重写，因为不可被继承。</p><h4 id="final-修饰一个方法"><a href="#final-修饰一个方法" class="headerlink" title="final 修饰一个方法"></a>final 修饰一个方法</h4><p>这个方法是最终方法，无法被覆盖重写。<br>格式： </p><pre><code>修饰符 final 返回值类型 方法名称（参数列表）{    //方法体    }</code></pre><p><strong>注意事项：</strong><br>对于类、方法来说，abstract 与final 关键字不能同时使用，因为矛盾。</p><h4 id="final-修饰局部变量"><a href="#final-修饰局部变量" class="headerlink" title="final 修饰局部变量"></a>final 修饰局部变量</h4><p>一旦使用 final修饰，不可被修改，只要保证唯一一次赋值即可</p><pre><code>final int num;num = 30;</code></pre><p>//对于基本类型来说，不可变说的是变量当中的<strong>数据</strong>不可变<br>//对于引用类型来说，不可变说的是变量当中的<strong>地址值</strong>不可变（数据可变，setter方法） </p><h4 id="final-修饰成员变量"><a href="#final-修饰成员变量" class="headerlink" title="final 修饰成员变量"></a>final 修饰成员变量</h4><p>1、由于成员变量具有默认值，所以用了final之后必须手动赋值<br>2、对于final的成员变量，要么使用直接赋值，要么通过构造方法赋值。（二选一）<br>3.必须保证类当中所有重载的构造方法，都最终会对final的成员变量进行赋值</p><h3 id="四种权限修饰符"><a href="#四种权限修饰符" class="headerlink" title="四种权限修饰符"></a>四种权限修饰符</h3><pre><code>                public &gt;     protected &gt;        (default) &gt;         private同一个类         YES            YES                 YES             YES同一个包         YES            YES                 YES             NO（new *().*)不同包子类      YES             YES                 NO              NO(需导包）不同包非子类    YES               NO                  NO              NO</code></pre><p><strong>注意：</strong>（default）并不是关键字，而是不写<br><strong>助记：</strong>三角形分布（4、3、2、1）、（我自己、我邻居、我儿子、陌生人）、</p><h3 id="内部类"><a href="#内部类" class="headerlink" title="内部类"></a>内部类</h3><h4 id="内部类的概念与分类"><a href="#内部类的概念与分类" class="headerlink" title="内部类的概念与分类"></a>内部类的概念与分类</h4><p>/<em><br>一个事物的内部包含另一个事物，一个类内部包含另一个类<br>Eg:身体和心脏的关系,汽车和发动机</em>/</p><p>分类：<br>1.成员内部类<br>2.局部内部类（包含匿名内部类）</p><h4 id="成员内部类的定义和使用"><a href="#成员内部类的定义和使用" class="headerlink" title="成员内部类的定义和使用"></a>成员内部类的定义和使用</h4><p>定义格式：</p><pre><code>修饰符 class 外部类名称{    修饰符  class 内部类名称{        //...    }    //...}</code></pre><p><strong>注意：</strong>内用外，随意访问，外用内，需要内部类对象</p><p>使用方式：<br>1.间接方式:在外部类的方法当中，使用内部类，然后main只是调用外部类的方法。<br>2.直接方式:公式：</p><pre><code>类名称 对象名 = new 类名称;【外部类名称.内部类名称 对象名 = new 外部类名称().new 内部类名称();】</code></pre><h4 id="内部类的同名变量访问"><a href="#内部类的同名变量访问" class="headerlink" title="内部类的同名变量访问"></a>内部类的同名变量访问</h4><p>Eg：</p><pre><code>//若出现了重名现象，格式 ：     外部类名称.this.外部类成员变量名public class Outer{    int num = 10;       .//外部类成员变量    public class Inner{            int  num =20;   //内部类的成员变量            public void methodInner(){                int num = 30;   //内部类方法的局变量                sout(num);  //30局部变量，就近原则                sout(this.num); //内部类的成员变量                sout(Outer.this.num);   //外部类的成员变量            }    }}</code></pre><h4 id="局部内部类定义"><a href="#局部内部类定义" class="headerlink" title="局部内部类定义"></a>局部内部类定义</h4><p>/<em><br>如果一个类是定义在一个方法内部的，那么这就是一个局部内部类<br>“局部”，只有当前所属的方法才能使用它,出了这个方法就不能用了</em>/</p><p>定义格式：</p><pre><code>修饰符  class 外部类名称{    修饰符 返回值类型 外部类方法名称（参数列表）{        class 局部内部类名称{                //...        }    }}</code></pre><p>使用方法：<br>在外部类方法中 将局部内部类实例化，然后调用内部类方法</p><p>小结一下类的权限修饰符：<br>public &gt; protected &gt; (default) &gt; private</p><p>定义一个类的时候，权限修饰符规则：<br>1.外部类： public / (default)<br>2.成员内部类： 四种都可以<br>3.局部内部类： 什么都不能写</p><h4 id="局部内部类的final问题"><a href="#局部内部类的final问题" class="headerlink" title="局部内部类的final问题"></a>局部内部类的final问题</h4><p>如果希望访问所在方法的局部变量，那么这个局部变量必须是 【有效final的（仅赋值一次或者用final修饰）】</p><h3 id="匿名内部类（重要）"><a href="#匿名内部类（重要）" class="headerlink" title="匿名内部类（重要）"></a>匿名内部类（重要）</h3><p>/*<br>如果接口的实现类（或者父类的子类）只需要使用唯一的一次<br>那么这种情况下就可以省略掉该类的定义，而改为使用【匿名内部类】</p><p><strong>匿名内部类定义格式：</strong></p><pre><code>接口名称 对象名 = new 接口名称(){    //覆盖重写接口中所有抽象方法};// 大括号中的是匿名内部类</code></pre><p> */</p><p>省掉一个单独实现类的定义</p><h4 id="匿名内部类使用注意事项"><a href="#匿名内部类使用注意事项" class="headerlink" title="匿名内部类使用注意事项"></a>匿名内部类使用注意事项</h4><p> 对格式“ new 接口名称(){…}”进行解析<br> 1.new 代表创建对象的动作<br> 2.接口名称就是匿名内部类需要实现的哪个接口<br> 3.{…}这才是匿名内部类的名称</p><p> <strong>另外注意：</strong><br> 1.匿名内部类，在创建对象时，只能使用唯一一次。<br> 如果希望多次创建对象，而且类的内容一样的话，那么就必须使用单独定义的实现类了<br> 2.匿名对象，在【调用方法】的时候，只能调用唯一一次。<br> 如果希望同一个对象，调用多次方法，那么必须给对象起个名字<br> 3.匿名内部类是省略了【实现类/子类名称】，但是匿名对象是省略了【对象名称】<br> 强调：<strong>匿名内部类 ≠ 匿名对象！！！</strong> </p><h3 id="类作为成员变量类型"><a href="#类作为成员变量类型" class="headerlink" title="类作为成员变量类型"></a>类作为成员变量类型</h3><h3 id="接口作为成员变量类型"><a href="#接口作为成员变量类型" class="headerlink" title="接口作为成员变量类型"></a>接口作为成员变量类型</h3><h3 id="接口作为方法的参数或返回值"><a href="#接口作为方法的参数或返回值" class="headerlink" title="接口作为方法的参数或返回值"></a>接口作为方法的参数或返回值</h3>]]></content>
      
      
      <categories>
          
          <category> 编程语言 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>数据库粗略回顾（三）</title>
      <link href="/2020/03/03/title-shu-ju-ku-cu-lue-hui-gu-san/"/>
      <url>/2020/03/03/title-shu-ju-ku-cu-lue-hui-gu-san/</url>
      
        <content type="html"><![CDATA[<h2 id="五、修改数据"><a href="#五、修改数据" class="headerlink" title="五、修改数据"></a>五、修改数据</h2><p>关系数据库的基本操作就是增删改查，即CRUD：Create、Retrieve、Update、Delete。其中，对于查询，我们已经详细讲述了SELECT语句的详细用法。</p><p>而对于增、删、改，对应的SQL语句分别是：</p><ul><li>INSERT：插入新记录；</li><li>UPDATE：更新已有记录；</li><li>DELETE：删除已有记录。</li></ul><h3 id="5-1-Insert"><a href="#5-1-Insert" class="headerlink" title="5.1 Insert"></a>5.1 Insert</h3><p>当我们需要向数据库表中插入一条新记录时，就必须使用<code>INSERT</code>语句。</p><p><strong>Insert 基本语法：</strong></p><pre><code>INSERT INTO &lt;表名&gt; (字段1， 字段2， ...)    VALUES (值1， 值2， ...);</code></pre><p><strong>例如</strong>，我们向students表插入一条新记录，先列举出需要插入的字段名称，然后在VALUES子句中依次写出对应字段的值：</p><pre><code>-- 添加一条新记录INSERT INTO students (class_id, name, gender, score) VALUES (2, &#39;大牛&#39;, &#39;M&#39;, 80);-- 并观察结果SELECT * FROM students;//RESULTS11    2    大牛    M    80</code></pre><p>我们并没有列出id字段, 而id字段是一个自增主键，它的值可以由数据库自己推算出来， 此外，如果一个字段有默认值，那么在INSERT语句中也可以不出现。</p><p><strong>注意</strong>，字段顺序不必和数据库表的字段顺序一致，但值的顺序必须和字段顺序一致。<br>也就是说，可以写INSERT INTO students (score, gender, name, class_id) …，但是对应的VALUES就得变成(80, ‘M’, ‘大牛’, 2)。</p><p>还<strong>可以一次性添加多条记录</strong>，只需要在VALUES子句中指定多个记录值，每个记录是由<strong>(…)</strong>包含的一组值：</p><p>INSERT INTO<br>    students<br>    (class_id, name, gender, score)<br>VALUES<br>    (1, ‘大宝’, ‘M’, 87),<br>    (2, ‘二宝’, ‘M’, 81);</p><p>SELECT *FROM students;</p><h4 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h4><p>使用INSERT，我们就可以一次向一个表中插入一条或多条记录。</p><hr><h3 id="5-2-UPDATE"><a href="#5-2-UPDATE" class="headerlink" title="5.2 UPDATE"></a>5.2 UPDATE</h3><p><strong>UPDATE语句的基本语法是：</strong></p><pre><code>UPDATE &lt;表名&gt; SET 字段1 = 值1, 字段2 =值2, ... WHERE ...;eg:更新id=1的记录UPDATE students    SET name = &#39;大牛&#39;, score = 66    WHERE id =1;-- 查询并观察结果:SELECT * FROM students where id = 1;</code></pre><p>注意到UPDATE语句的WHERE条件和SELECT语句的WHERE条件其实是一样的，因此完<strong>全可以一次更新多条记录</strong>： </p><pre><code>-- 更新id=5,6,7的记录UPDATE students     SET name = &#39;小牛&#39;, score = 77    WHERE  id &gt;=5   AND id &lt;=7;-- 查询并观察结果:SELECT * FROM students;</code></pre><p>在UPDATE语句中，<strong>更新字段时可以使用表达式</strong>。例如，把所有80分以下的同学的成绩加10分：    </p><pre><code>UPDATE  students     SET  score = score +10    WHERE   score &lt; 80;</code></pre><p>SET score=score+10就是给当前行的score字段的值加上了10。</p><p>如果WHERE条件没有匹配到任何记录，UPDATE语句不会报错，也不会有任何记录被更新。例如：</p><pre><code>UPDATE students SET score=100 WHERE id=999;</code></pre><p>最后，要特别小心的是，UPDATE语句可以没有WHERE条件，例如：</p><pre><code>UPDATE students SET score=60;</code></pre><p>这时，整个表的所有记录都会被更新。所以，<strong>在执行UPDATE语句时要非常小心，最好先用SELECT语句来测试WHERE条件是否筛选出了期望的记录集，然后再用UPDATE更新。</strong>    </p><h4 id="MySQL"><a href="#MySQL" class="headerlink" title="MySQL"></a>MySQL</h4><p>在使用MySQL这类真正的关系数据库时，UPDATE语句会返回更新的行数以及WHERE条件匹配的行数。</p><p>例如，更新id=1的记录时：</p><pre><code>mysql&gt; UPDATE students SET name=&#39;大宝&#39; WHERE id=1;Query OK, 1 row affected (0.00 sec)Rows matched: 1  Changed: 1  Warnings: 0</code></pre><p>MySQL会返回1，可以从打印的结果Rows matched: 1 Changed: 1看到。</p><p>当更新id=999的记录时：</p><pre><code>mysql&gt; UPDATE students SET name=&#39;大宝&#39; WHERE id=999;Query OK, 0 rows affected (0.00 sec)Rows matched: 0  Changed: 0  Warnings: 0</code></pre><p>MySQL会返回0，可以从打印的结果Rows matched: 0 Changed: 0看到。</p><h4 id="小结-1"><a href="#小结-1" class="headerlink" title="小结"></a>小结</h4><p>使用UPDATE，我们就可以一次更新表中的一条或多条记录。</p><h3 id="5-3-DELETE"><a href="#5-3-DELETE" class="headerlink" title="5.3 DELETE"></a>5.3 DELETE</h3><p>DELETE语句的基本语法是：</p><pre><code>DELETE FROM &lt;表名&gt; WHERE ...;</code></pre><p>例如，我们想删除students表中id=1的记录</p><pre><code>DELETE FROM students WHERE id=1;-- 查询并观察结果:SELECT * FROM students;</code></pre><p>注意到DELETE语句的WHERE条件也是用来筛选需要删除的行，因此和UPDATE类似，<strong>DELETE语句也可以一次删除多条记录</strong>：</p><pre><code>-- 删除id=5,6,7的记录DELETE FROM students WHERE id&gt;= 5 AND id &lt;= 7;</code></pre><p>如果WHERE条件没有匹配到任何记录，DELETE语句不会报错，也不会有任何记录被删除。(同UPDATE)</p><p>最后，要特别小心的是，和UPDATE类似，不带WHERE条件的DELETE语句会删除整个表的数据：</p><pre><code>DELETE FROM students;</code></pre><p>这时，整个表的所有记录都会被删除。所以，<strong>在执行DELETE语句时也要非常小心，最好先用SELECT语句来测试WHERE条件是否筛选出了期望的记录集，然后再用DELETE删除。</strong></p><h4 id="MySQL-1"><a href="#MySQL-1" class="headerlink" title="MySQL"></a>MySQL</h4><p>在使用MySQL这类真正的关系数据库时，DELETE语句也会返回删除的行数以及WHERE条件匹配的行数。</p><p>例如，分别执行删除id=1和id=999的记录：</p><pre><code>mysql&gt; DELETE FROM students WHERE id=1;Query OK, 1 row affected (0.01 sec)mysql&gt; DELETE FROM students WHERE id=999;Query OK, 0 rows affected (0.01 sec)</code></pre><h4 id="小结-2"><a href="#小结-2" class="headerlink" title="小结"></a>小结</h4><p>使用DELETE，我们就可以一次删除表中的一条或多条记录。</p><hr><h2 id="六、MySQL"><a href="#六、MySQL" class="headerlink" title="六、MySQL"></a>六、MySQL</h2><p>安装完MySQL后，除了MySQL Server，即真正的MySQL服务器外，还附赠一个MySQL Client程序。MySQL Client是一个命令行客户端，可以通过MySQL Client登录MySQL，然后，输入SQL语句并执行。</p><p>打开命令提示符，输入命令<code>mysql -u root -p</code>，<br>提示输入口令。填入MySQL的root口令，如果正确，就连上了MySQL Server，同时提示符变为mysql&gt;</p><p>输入<code>exit</code>断开与MySQL Server的连接并返回到命令提示符。</p><p> <strong>注意</strong>：MySQL Client的可执行程序是mysql，MySQL Server的可执行程序是mysqld。</p><p>MySQL Client和MySQL Server的关系如下： </p><pre><code>┌──────────────┐  SQL   ┌──────────────┐│ MySQL Client │───────&gt;│ MySQL Server │└──────────────┘  TCP   └──────────────┘</code></pre><p>在MySQL Client中输入的SQL语句通过TCP连接发送到MySQL Server。默认端口号是3306，即如果发送到本机MySQL Server，地址就是 <strong>127.0.0.1:3306</strong>。</p><p>也可以只安装MySQL Client，然后连接到远程MySQL Server。假设远程MySQL Server的IP地址是10.0.1.99，那么就使用-h指定IP或域名：</p><pre><code>mysql -h 10.0.1.99 -u root -p</code></pre><p><strong>小结</strong></p><p>命令行程序mysql实际上是MySQL客户端，真正的MySQL服务器程序是mysqld，在后台运行。</p><hr><h3 id="6-1-管理MySQL"><a href="#6-1-管理MySQL" class="headerlink" title="6.1 管理MySQL"></a>6.1 管理MySQL</h3><p>要管理MySQL，可以使用可视化图形界面MySQL Workbench。</p><p>MySQL Workbench可以用可视化的方式查询、创建和修改数据库表，但是，归根到底，MySQL Workbench是一个图形客户端，它对MySQL的操作仍然是发送SQL语句并执行。因此，本质上，MySQL Workbench和MySQL Client命令行都是客户端，和MySQL交互，唯一的接口就是SQL。</p><p>因此，MySQL提供了大量的SQL语句用于管理。虽然可以使用MySQL Workbench图形界面来直接管理MySQL，<strong>但是，很多时候，通过SSH远程连接时，只能使用SQL命令，所以，了解并掌握常用的SQL管理操作是必须的。</strong></p><h4 id="数据库"><a href="#数据库" class="headerlink" title="数据库"></a>数据库</h4><p>在一个运行MySQL的服务器上，实际上可以创建多个数据库（Database）。要列出所有数据库，使用命令：</p><pre><code>mysql&gt; SHOW DATABASES;+--------------------+| Database           |+--------------------+| information_schema || mysql              || performance_schema || shici              || sys                || test               || school             |+--------------------+</code></pre><p>其中，information_schema、mysql、performance_schema和sys是系统库，不要去改动它们。其他的是用户创建的数据库。</p><p>要<strong>创建一个新数据库</strong>，使用命令：</p><pre><code>mysql&gt; CREATE DATABASE test;Query OK, 1 row affected (0.01 sec)(注意结束的分号；)</code></pre><p>要<strong>删除一个数据库</strong>，使用命令：</p><pre><code>mysql&gt; DROP DATABASE test;Query OK, 0 rows affected (0.01 sec) //not DELETE</code></pre><p><strong>注意</strong>：删除一个数据库将导致该数据库的所有表全部被删除。</p><p>对一个数据库进行操作时，要首先将其切换为当前数据库：</p><pre><code>mysql&gt; USE test;Database changed</code></pre><h4 id="表"><a href="#表" class="headerlink" title="表"></a>表</h4><p>列出当前数据库的所有表，使用命令：</p><pre><code>mysql&gt; SHOW TABLES;+---------------------+| Tables_in_test      |+---------------------+| classes             || statistics          || students            || students_of_class1  |+---------------------+</code></pre><p>要查看一个表的结构，使用命令：    </p><pre><code>mysql&gt; DESC students;+----------+--------------+------+-----+---------+----------------+| Field    | Type         | Null | Key | Default | Extra          |+----------+--------------+------+-----+---------+----------------+| id       | bigint(20)   | NO   | PRI | NULL    | auto_increment || class_id | bigint(20)   | NO   |     | NULL    |                || name     | varchar(100) | NO   |     | NULL    |                || gender   | varchar(1)   | NO   |     | NULL    |                || score    | int(11)      | NO   |     | NULL    |                |+----------+--------------+------+-----+---------+----------------+5 rows in set (0.00 sec)</code></pre><p>还可以使用以下命令查看创建表的SQL语句：</p><pre><code>mysql&gt; SHOW CREATE TABLE students;   +----------+-------------------------------------------------------+| students | CREATE TABLE `students` (                             ||          |   `id` bigint(20) NOT NULL AUTO_INCREMENT,            ||          |   `class_id` bigint(20) NOT NULL,                     ||          |   `name` varchar(100) NOT NULL,                       ||          |   `gender` varchar(1) NOT NULL,                       ||          |   `score` int(11) NOT NULL,                           ||          |   PRIMARY KEY (`id`)                                  ||          | ) ENGINE=InnoDB AUTO_INCREMENT=1 DEFAULT CHARSET=utf8 |+----------+-------------------------------------------------------+1 row in set (0.00 sec)</code></pre><p>创建表使用<code>CREATE TABLE</code>语句，而删除表使用<code>DROP TABLE</code>语句：</p><pre><code>mysql&gt; DROP TABLE students;Query OK, 0 rows affected (0.01 sec)</code></pre><p>修改表就比较复杂。如果要给students表<strong>新增一列</strong>birth，使用：</p><pre><code>ALTER TABLE students ADD COLUMN birth VARCHAR(10) NOT NULL;//改变表 students  加一列 birth 数据类型 非空</code></pre><p>要修改birth列，例如把列名改为birthday，类型改为VARCHAR(20)：</p><pre><code>ALTER TABLE students CHANGE COLUMN birth birthday VARCHAR(20) NOT NULL;</code></pre><p>要删除列，使用：</p><pre><code>ALTER TABLE students DROP COLUMN birthday;</code></pre><h4 id="退出MySQL"><a href="#退出MySQL" class="headerlink" title="退出MySQL"></a>退出MySQL</h4><pre><code>mysql&gt; EXITBye</code></pre><p><strong>注意:</strong> <code>EXIT</code>仅仅断开了客户端和服务器的连接，MySQL服务器仍然继续运行。</p><hr><h3 id="6-2-实用SQL语句"><a href="#6-2-实用SQL语句" class="headerlink" title="6.2 实用SQL语句"></a>6.2 实用SQL语句</h3><pre><code>在编写SQL时，灵活运用一些技巧，可以大大简化程序逻辑。</code></pre><h4 id="插入或替换"><a href="#插入或替换" class="headerlink" title="插入或替换"></a>插入或替换</h4><p>如果我们希望插入一条新记录（INSERT），但如果记录已经存在，就先删除原记录，再插入新记录。此时，可以使用<strong>REPLACE语句</strong>，这样就不必先查询，再决定是否先删除再插入：</p><pre><code>REPLACE INTO students (id, class_id, name, gender, score)VALUES (1, 1, &#39;小明&#39;, &#39;F&#39;, 99);</code></pre><p>若id=1的记录不存在，REPLACE语句将插入新记录，否则，当前id=1的记录将被删除，然后再插入新记录。</p><h4 id="插入或更新"><a href="#插入或更新" class="headerlink" title="插入或更新"></a>插入或更新</h4><p>如果我们希望插入一条新记录（INSERT），但如果记录已经存在，就<strong>更新该记录</strong>，此时，可以使用<code>INSERT INTO ... ON DUPLICATE KEY UPDATE ...</code>语句：</p><pre><code>INSERT INTO     students    (id, class_id, name, gender, score)    VALUES    (1, 1, &#39;小明&#39;, &#39;F&#39;, 99)    ON DUPLICATE KEY VALUE     name = &#39;小明&#39;, gender =&#39;F&#39;, score = 99;</code></pre><p><em>若id=1的记录不存在，INSERT语句将插入新记录，否则，当前id=1的记录将被更新，更新的字段由UPDATE指定。</em></p><h4 id="插入或忽略"><a href="#插入或忽略" class="headerlink" title="插入或忽略"></a>插入或忽略</h4><p>如果我们希望插入一条新记录（INSERT），但如果记录已经存在，就啥事也不干直接忽略，此时，可以使用<code>INSERT IGNORE INTO ...</code>语句：</p><pre><code>  INSERT IGNORE INTO students  (id, class_id, name, gender, score)    VALUES    （1, 1, &#39;小明&#39;, &#39;F&#39;, 99);</code></pre><p><em>若id=1的记录不存在，INSERT语句将插入新记录，否则，不执行任何操作。</em></p><h4 id="快照"><a href="#快照" class="headerlink" title="快照"></a>快照</h4><p>如果想要对一个表进行快照，即复制一份当前表的数据到一个新表，可以<strong>结合CREATE TABLE和SELECT：</strong></p><pre><code>-- 对class_id=1的记录进行快照，并存储为新表students_of_class1:CREATE TABLE students_of_class1     SELECT * FROM students     WHERE        class_id = 1;</code></pre><p>新创建的表结构和SELECT使用的表结构完全一致。           </p><h4 id="写入查询结果集"><a href="#写入查询结果集" class="headerlink" title="写入查询结果集"></a>写入查询结果集</h4><p>如果查询结果集需要写入到表中，可以<strong>结合INSERT和SELECT</strong>，将SELECT语句的结果集直接插入到指定表中。</p><p>eg:创建一个统计成绩的表statistics，记录各班的平均成绩：</p><pre><code>CREATE TABLE statistics(    id BIGINT NOT NULL AUTO_INCREMENT,    class_id BIGINT NOT NULL,    average DOUBLE NOT NULL,    PRIMARY KEY(id)    );    //用圆括号 字段名 数据类型 非空    加上主键</code></pre><p>然后，我们就可以用一条语句写入各班的平均成绩：</p><pre><code>INSERT INTO statistics     (class_id, average)    SELECT  class_id, AVG(score)  FROM students GROUP BY class_id;</code></pre><p><strong>确保INSERT语句的列和SELECT语句的列能一一对应</strong>，就可以在statistics表中直接保存查询的结果：</p><pre><code>&gt; SELECT * FROM statistics;+----+----------+--------------+| id | class_id | average      |+----+----------+--------------+|  1 |        1 |         86.5 ||  2 |        2 | 73.666666666 ||  3 |        3 | 88.333333333 |+----+----------+--------------+3 rows in set (0.00 sec)</code></pre><h4 id="强制使用指定索引"><a href="#强制使用指定索引" class="headerlink" title="强制使用指定索引"></a>强制使用指定索引</h4><p>在查询的时候，数据库系统会自动分析查询语句，并选择一个最合适的索引。但是很多时候，数据库系统的查询优化器并不一定总是能使用最优索引。如果我们知道如何选择索引，可以使用<code>FORCE INDEX</code><strong>强制查询使用指定的索引</strong>。<br>例如：</p><pre><code>&gt;SELECT * FROM students FORCE INDEX     (idx_class_id) WHERE   class_id =1 ORDER   BY id DESC;</code></pre><p><strong>指定索引的前提是索引idx_class_id必须存在。</strong></p><hr>]]></content>
      
      
      <categories>
          
          <category> 数据库 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> MySQL </tag>
            
            <tag> SQL </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>数据库粗略回顾（二）</title>
      <link href="/2020/03/03/title-shu-ju-ku-cu-lue-hui-gu-er/"/>
      <url>/2020/03/03/title-shu-ju-ku-cu-lue-hui-gu-er/</url>
      
        <content type="html"><![CDATA[<h2 id="四、查询数据"><a href="#四、查询数据" class="headerlink" title="四、查询数据"></a>四、查询数据</h2><h3 id="4-1-基本查询"><a href="#4-1-基本查询" class="headerlink" title="4.1 基本查询"></a>4.1 基本查询</h3><p>要查询数据库表的数据，我们使用如下的SQL语句：</p><pre><code>SELECT * FROM &lt;表名&gt;</code></pre><p>假设表名是students，要查询students表的所有行，我们用如下SQL语句：    </p><pre><code>SELECT * FROM students</code></pre><p>使用SELECT <em> FROM students时，SELECT是关键字，表示将要执行一个查询，**</em>表示“所有列”**，FROM表示将要从哪个表查询，本例中是students表。</p><p>该SQL将查询出students表的<strong>所有数据</strong>。注意：<strong>查询结果也是一个二维表</strong>，它包含列名和每一行的数据。</p><p>要查询classes表的所有行，我们用如下SQL语句：</p><pre><code>SELECT * FROM classes</code></pre><p>SELECT语句其实并不要求一定要有FROM子句。我们来试试下面的SELECT语句：<br>SELECT语句其实并不要求一定要有FROM子句。我们来试试下面的SELECT语句：</p><pre><code>SELECT 100+200;100 + 200300</code></pre><p>上述查询会直接计算出表达式的结果。虽然SELECT可以用作计算，但它并不是SQL的强项。但是，不带FROM子句的SELECT语句有一个有用的用途，就是用来<strong>判断当前到数据库的连接是否有效</strong>。许多检测工具会执行一条SELECT 1;来测试数据库连接。</p><h4 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h4><p><strong>使用SELECT查询的基本语句SELECT <em> FROM  &lt;表名&gt; 可以查询一个表的所有行和所有列的数据。<br>SELECT查询的结果是一个</em>二维表*。</strong></p><hr><h3 id="4-2-条件查询"><a href="#4-2-条件查询" class="headerlink" title="4.2 条件查询"></a>4.2 条件查询</h3><p>根据条件选择性地获取指定条件的记录例如，查询分数在80分以上的学生记录。在一张表有数百万记录的情况下，获取所有记录不仅费时，还费内存和网络带宽。</p><p>SELECT语句可以通过<strong>WHERE条件</strong>来设定查询条件，查询结果是满足查询条件的记录。例如，要指定条件“分数在80分或以上的学生”，写成WHERE条件就是</p><pre><code>SELECT * FROM students WHERE score &gt;= 80。</code></pre><p>其中，WHERE关键字后面的score &gt;= 80就是条件。score是列名，该列存储了学生的成绩，因此，score &gt;= 80就筛选出了指定条件的记录：</p><p>因此，条件查询的语法就是：</p><pre><code>SELECT * FROM &lt;表名&gt; WHERE &lt;条件表达式&gt;</code></pre><p>条件表达式可以用&lt;条件1&gt; AND &lt;条件2&gt;表达满足条件1并且满足条件2。例如，符合条件“分数在80分或以上”，并且还符合条件“男生”，把这两个条件写出来：</p><pre><code>SELECT * FROM students WHERE score &gt;=80 AND gender = &#39;M&#39;</code></pre><p>第二种条件是&lt;条件1&gt; OR &lt;条件2&gt;，表示满足条件1或者满足条件2。</p><pre><code>SELECT * FROM students WHERE score &gt;= 80 OR gender = &#39;M&#39;</code></pre><p>第三种条件是NOT &lt;条件&gt;，表示“不符合该条件”的记录。<br>eg:</p><pre><code>SELECT * FROM students WHERE NOT class_id =2;</code></pre><p>上述NOT条件<code>NOT class_id = 2</code>其实等价于<code>class_id &lt;&gt; 2</code>，因此，NOT查询不是很常用。</p><p>要组合三个或者更多的条件，就需要用小括号()表示如何进行条件运算。例如，编写一个复杂的条件：分数在80以下或者90以上，并且是男生：</p><pre><code>SELECT * FROM students WHERE (score &lt;80 OR score &gt; 90) AND gender = &#39;M&#39;;</code></pre><p>如果不加括号，条件运算按照NOT、AND、OR的优先级进行，即NOT优先级最高，其次是AND，最后是OR。加上括号可以改变优先级。</p><h4 id="常用的条件表达式"><a href="#常用的条件表达式" class="headerlink" title="常用的条件表达式"></a>常用的条件表达式</h4><p>=   &gt;  &gt;=  &lt;  &lt;= </p><pre><code>&lt;&gt;      不等于      score &lt;&gt; 80    name &lt;&gt; &#39;abc&#39;使用LIKE判断相似    name LIKE &#39;ab%&#39;            name LIKE &#39;%bc%&#39;    %表示任意字符，例如&#39;ab%&#39;将匹配&#39;ab&#39;，&#39;abc&#39;，&#39;abcd&#39;</code></pre><h4 id="小结-1"><a href="#小结-1" class="headerlink" title="小结"></a>小结</h4><p>通过WHERE条件查询，可以筛选出符合指定条件的记录，而不是整个表的所有记录。</p><hr><h3 id="4-3-投影查询"><a href="#4-3-投影查询" class="headerlink" title="4.3 投影查询"></a>4.3 投影查询</h3><p>使用<code>SELECT * FROM &lt;表名&gt; WHERE &lt;条件&gt;</code>可以选出表中的若干条记录。我们注意到返回的二维表结构和原表是相同的，即<strong>结果集的所有列与原表的所有列都一一对应。</strong></p><p>如果我们只希望返回某些列的数据，而不是所有列的数据，我们可以用<strong>SELECT 列1, 列2, 列3 FROM …，</strong>让结果集仅包含指定列。这种操作称为<em>投影查询</em></p><p>例如，从students表中返回id、score和name这三列：</p><pre><code>SELECT id, score, name FROM students;</code></pre><p>这样返回的结果集就只包含了我们指定的列，并且，<strong>结果集的列的顺序和原表可以不一样。</strong></p><p>使用<code>SELECT 列1, 列2, 列3 FROM ...</code>时，还可以给每一列起个别名，这样，结果集的列名就可以与原表的列名不同。它的语法是<code>SELECT 列1 别名1, 列2 别名2, 列3 别名3 FROM ...</code></p><p>例如，以下SELECT语句将列名score重命名为points，而id和name列名保持不变：</p><pre><code>SELECT id, score points, name FROM students;</code></pre><p>投影查询同样可以接WHERE条件，实现复杂的查询：</p><p>SELECT id, score points, name FROM students WHERE gender = ‘M’;</p><h4 id="小结-2"><a href="#小结-2" class="headerlink" title="小结"></a>小结</h4><p>使用SELECT <em>表示查询表的所有列，使用SELECT 列1, 列2, 列3则可以仅返回指定列，这种操作称为<em>*投影</em></em>。</p><p>SELECT语句可以对结果集的列进行<strong>重命名</strong>。</p><hr><h3 id="4-4-排序"><a href="#4-4-排序" class="headerlink" title="4.4 排序"></a>4.4 排序</h3><p>使用SELECT查询时，查询结果集通常是按照id排序的，也就是根据主键排序。如果我们要根据其他条件排序，可以加上ORDER BY子句。<br>例如按照成绩从低到高进行排序：</p><pre><code>SELECT id, name, gender, score FROM students ORDER BY score;</code></pre><p>如果要反过来，按照成绩从高到底排序，我们可以加上 DESC 表示“倒序”：(DESCEND的缩写啊）</p><pre><code>SELECT id, name, gender, score FROM students    ORDER BY score  DESC;</code></pre><p>如果score列有相同的数据，要进一步排序，可以继续添加列名。例如，使用<code>ORDER BY score DESC, gender</code>表示先按score列倒序，如果有相同分数的，再按gender列排序：</p><pre><code>SELECT id, name, gender, score  FROM    students ORDER BY score DESC, gender;</code></pre><p>默认的排序规则是<strong>ASC</strong>：“升序”，即从小到大。ASC可以省略，即ORDER BY score ASC和ORDER BY score效果一样。</p><p>如果有WHERE子句，那么ORDER BY子句要放到WHERE子句后面。例如，查询一班的学生成绩，并按照倒序排序：</p><pre><code>SELECT id, name, gender, socre  FROM students WHERE class_id = 1 ORDER BY score DESC;</code></pre><p>这样，结果集仅包含符合WHERE条件的记录，并按照ORDER BY的设定排序。</p><h4 id="小结-3"><a href="#小结-3" class="headerlink" title="小结"></a>小结</h4><p>使用ORDER BY可以对结果集进行排序；<br>可以对多列进行升序、倒序排序。</p><hr><h3 id="4-5-分页查询"><a href="#4-5-分页查询" class="headerlink" title="4.5 分页查询"></a>4.5 分页查询</h3><p>使用SELECT查询时，如果结果集数据量很大，比如几万行数据，放在一个页面显示的话数据量太大，不如分页显示，每次显示100条。</p><p>分页实际上就是从结果集中“截取”出第M~N条记录。这个查询可以通过<code>LIMIT &lt;M&gt; OFFSET &lt;N&gt;</code>子句实现。<br>我们先把所有学生按照成绩从高到低进行排序：</p><pre><code>SELECT id, name, gender, score FROM students ORDER BY score DESC;</code></pre><p>现在，我们把结果集分页，每页3条记录。要获取第1页的记录，可以使用 LIMIT 3 OFFSET 0：</p><pre><code>SELECT id, name, gender, scoreFROM studentsORDER BY score DESCLIMIT 3 OFFSET 0;</code></pre><p>上述查询LIMIT 3 OFFSET 0表示，<em>对结果集从0号记录开始，最多取3条</em>。<strong>注意SQL记录集的索引从0开始。</strong></p><p>如果要查询第2页，那么我们只需要“跳过”头3条记录，也就是对结果集从3号记录开始查询，把OFFSET设定为3：</p><pre><code>SELECT id, name, gender, scoreFROM studentsORDER BY score DESCLIMIT 3 OFFSET 3;</code></pre><p>类似的，查询第3页的时候，OFFSET应该设定为6:</p><pre><code>SELECT id, name, gender, scoreFROM studentsORDER BY score DESCLIMIT 3 OFFSET 6;</code></pre><p>查询第4页的时候，OFFSET应该设定为9:</p><p>由于第4页只有1条记录，因此最终结果集按实际数量1显示。LIMIT 3表示的意思是“最多3条记录”。</p><p>可见，分页查询的关键在于，首先要确定每页需要显示的结果数量pageSize（这里是3），然后根据当前页的索引pageIndex（从1开始），确定 LIMIT 和 OFFSET 应该设定的值：</p><p>REMEMBER</p><ul><li>LIMIT总是设定为pageSize；</li><li>OFFSET计算公式为pageSize * (pageIndex - 1)。</li></ul><p>这样就能正确查询出第N页的记录集。</p><p>如果原本记录集一共就10条记录，但我们把OFFSET设置为20，会得到什么结果呢？</p><pre><code>SELECT id, name, gender, scoreFROM studentsORDER BY score DESCLIMIT 3 OFFSET 20;</code></pre><p>OFFSET超过了查询的最大数量并不会报错，而是得到一个空的结果集。</p><h4 id="注意"><a href="#注意" class="headerlink" title="注意"></a>注意</h4><p>OFFSET是可选的，如果只写LIMIT 15，那么相当于LIMIT 15 OFFSET 0。</p><p>在MySQL中，LIMIT 15 OFFSET 30还可以<strong>简写</strong>成LIMIT 30, 15。</p><p>使用<code>LIMIT &lt;M&gt; OFFSET &lt;N&gt;</code>分页时，随着N越来越大，查询效率也会越来越低。</p><h4 id="小结-4"><a href="#小结-4" class="headerlink" title="小结"></a>小结</h4><p>使用<code>LIMIT &lt;M&gt; OFFSET &lt;N&gt;</code>可以对结果集进行分页，每次查询返回结果集的一部分；</p><p>分页查询需要先确定每页的数量和当前页数，然后确定LIMIT和OFFSET的值。</p><hr><h3 id="4-6-聚合查询"><a href="#4-6-聚合查询" class="headerlink" title="4.6 聚合查询"></a>4.6 聚合查询</h3><p>对于 统计总数、平均数 这类计算，SQL提供了专门的聚合函数，使用聚合函数进行查询，就是<strong>聚合查询</strong>，它可以快速获得结果。</p><p>以查询students表一共有多少条记录为例，我们可以使用SQL<strong>内置的COUNT()函数</strong>查询：</p><pre><code>SELECT COUNT(*) FROM students;COUNT(*)10</code></pre><p>COUNT(*)表示查询所有列的行数，要注意聚合的计算结果虽然是一个数字，但查询的结果仍然是一个二维表，只是这个二维表只有一行一列，并且列名是COUNT(*)</p><p>通常，使用聚合查询时，我们应该给<strong>结果集的列名</strong>设置一个别名，便于处理结果：</p><pre><code>SELECT COUNT(*) num FROM students;</code></pre><p>COUNT(*)和COUNT(id)（或者score啊，gender啊）实际上是一样的效果。另外注意，聚合查询同样可以使用WHERE条件，因此我们可以方便地统计出有多少男生、多少女生、多少80分以上的学生等：</p><pre><code>SELECT COUNT(*) boys FROM students WHERE  gender = &#39;M&#39;</code></pre><p>除了COUNT()函数外，SQL还提供了如下聚合函数：</p><pre><code>函数    说明SUM    计算某一列的合计值，该列必须为数值类型AVG    计算某一列的平均值，该列必须为数值类型MAX    计算某一列的最大值MIN    计算某一列的最小值</code></pre><p><strong>注意</strong>，MAX()和MIN()函数并不限于数值类型。如果是字符类型，MAX()和MIN()会返回排序最后和排序最前的字符。 (大小写不敏感）</p><p>要统计男生的平均成绩，我们用下面的聚合查询：</p><pre><code>SELECT AVG(score) average FROM students WHERE gender =&#39;M&#39;;</code></pre><p>要特别注意：如果聚合查询的WHERE条件没有匹配到任何行，COUNT()会返回<strong>0</strong>，而SUM()、AVG()、MAX()和MIN()会返回<strong>NULL</strong>：</p><pre><code> 每页3条记录，如何通过聚合查询获得总页数？  SELECT CEILING(COUNT(*) / 3) FROM students;</code></pre><h4 id="分组"><a href="#分组" class="headerlink" title="分组"></a>分组</h4><p>如果我们要统计一班的学生数量，我们知道，可以用SELECT COUNT(*) num FROM students WHERE class_id = 1;。如果要继续统计二班、三班的学生数量，难道必须不断修改WHERE条件来执行SELECT语句吗？</p><p><strong>（我的理解是 ：分组的意义在于可以查询多个同样条件的值）</strong></p><p>对于聚合查询，SQL还提供了“分组聚合”的功能  </p><pre><code>按class_id分组:SELECT MAX(*) num FROM students GROUP BY class_id;//resultnumNULLNULLNULL</code></pre><p>执行这个查询，COUNT()的结果不再是一个，而是3个，这是因为，GROUP BY子句指定了按class_id分组，因此，执行该SELECT语句时，<strong>会把class_id相同的列先分组，再分别计算，因此，得到了3行结果。</strong></p><p>但是这3行结果分别是哪三个班级的，不好看出来，所以我们可以把class_id列也放入结果集中：</p><pre><code>SELECT class_id, COUNT(*) num FROM students GROUP BY class_id; //resultclass_id    num1           42           33           3</code></pre><p>这下结果集就可以一目了然地看出各个班级的学生人数。我们再试试把name放入结果集：</p><pre><code>SELECT name, class_id, COUNT(*) num FROM students GROUP BY class_id;//resultname    class_id    numNULL    1           4NULL    2            3NULL    3            3</code></pre><p>不出意外，执行这条查询我们会得到一个语法错误，因为在任意一个分组中，只有class_id都相同，name是不同的，<strong>SQL引擎不能把多个name的值放入一行记录中</strong>。因此，聚合查询的列中，只能放入分组的列。</p><p>也可以使用多个列进行分组。例如，我们想统计各班的男生和女生人数：</p><pre><code>-- 按class_id, gender分组:SELECT class_id, gender, count(*) num FROM students GROUP BY class_id, gender;   //共 3 * 2  = 6 条记录分别对应各班级的男生和女生人数</code></pre><h4 id="练习"><a href="#练习" class="headerlink" title="练习"></a>练习</h4><p>1.请使用一条SELECT查询查出每个班级的平均分：</p><pre><code> 查出每个班级的平均分，结果集应当有3条记录: SELECT class_id, AVG(score) average_of_class  FROM students GROUP BY class_id（不分组的话不能返回多个啊）//RESULTSclass_id    average_of_class1           86.52            73.666666666666673            89.33333333333333</code></pre><ol start="2"><li><p>请使用一条SELECT查询查出每个班级男生和女生的平均分：</p><pre><code> SELECT class_id, gender, AVG(score) average FROM students GROUP BY class_id, gender;</code></pre></li></ol><pre><code>    //RESULTS    class_id    gender    average        1           M        89        1           F       84        2           F       81        2           M        70        3           F        89.5        3           M       89</code></pre><h4 id="小结-5"><a href="#小结-5" class="headerlink" title="小结"></a>小结</h4><p>使用SQL提供的聚合查询，我们可以方便地计算总数、合计值、平均值、最大值和最小值；<br>聚合查询也可以添加WHERE条件。</p><hr><h3 id="4-7-多表查询"><a href="#4-7-多表查询" class="headerlink" title="4.7 多表查询"></a>4.7 多表查询</h3><p>SELECT查询不但可以从一张表查询数据，还可以从多张表同时查询数据。查询多张表的语法是：<br><code>SELECT * FROM &lt;表1&gt; &lt;表2&gt;。</code></p><p>如，同时从students表和classes表的<strong>“乘积”</strong>，即查询数据，可以这么写：</p><pre><code>SELECT * FROM students, classes;//最后得到了四十条数据 十个人 四个班</code></pre><p>这种一次查询两个表的数据，查询的结果也是一个二维表，它是students表和classes表的“乘积”，即<strong>students表的每一行与classes表的每一行都两两拼在一起返回</strong>。<br>结果集的<strong>列数</strong>是students表和classes表的列数之<strong>和</strong>，<strong>行数</strong>是students表和classes表的行数之<strong>积</strong>。</p><p>这种多表查询又称<strong>笛卡尔查询</strong>，使用笛卡尔查询时要非常小心，由于结果集是目标表的行数乘积，对两个各自有100行记录的表进行笛卡尔查询将返回1万条记录，对两个各自有1万行记录的表进行笛卡尔查询将返回1亿条记录。</p><pre><code>id    class_id    name    gender    score    id    name1    1            小明        M       90    1    一班1    1            小明        M      90    2    二班1    1            小明        M      90    3    三班1    1            小明        M       90    4    四班2    1            小红        F      95    1    一班2    1           小红        F       95    2    二班2    1            小红        F      95    3    三班2    1            小红        F       95    4    四班。。。。。。。。。。。。。。。。。。。。。。。。。。</code></pre><p>上述查询的结果集（省略）有两列id和两列name，两列id是因为其中一列是students表的id，而另一列是classes表的id，但是在结果集中，不好区分。两列name同理</p><p>要解决这个问题，我们仍然可以利用投影查询的“<strong>设置列的别名</strong>”来给两个表各自的id和name列起别名：</p><pre><code>-- set alias:SELECT     students.id     sid,    students.name,    students.gender,    students.score,    class.id    cid,    class.name  cnameFROM students, classes;</code></pre><p><strong>注意</strong>，多表查询时，要使用 <code>表名.列名</code> 这样的方式来引用列和设置别名，这样就避免了结果集的列名重复问题。但是，用<code>表名.列名</code><br>这种方式列举两个表的所有列实在是很麻烦，所以SQL还允许<strong>给表设置一个别名</strong>，让我们在投影查询中引用起来稍微简洁一点：    </p><pre><code>-- set table alias:SELECT    s.id    sid,    s.name,    s.gender,    s.score,    c.id    cid,    c.name  cname    //这里不需要逗号！！！FROM    students    s, classes  c;//细节啊</code></pre><p>注意到FROM子句给表设置别名的语法是FROM &lt;表名1&gt; &lt;别名1&gt;, &lt;表名2&gt; &lt;别名2&gt;。这样我们用别名s和c分别表示students表和classes表。</p><p>多表查询也是可以添加WHERE条件的</p><pre><code>-- set where clause:SELECT     s.id sid,    s.name,    s.gender,    s.score,    c.id cid,    c.name cnameFROM students s, classes cWHERE s.gender = &#39;M&#39;  AND c.id =1//得到 5*1 = 5个记录</code></pre><p>这个查询的结果集每行记录都满足条件s.gender = ‘M’和c.id = 1。添加WHERE条件后结果集的数量大大减少了。    </p><h4 id="小结-6"><a href="#小结-6" class="headerlink" title="小结"></a>小结</h4><ul><li>使用多表查询可以获取M x N行记录；</li><li>多表查询的结果集可能非常巨大，小心使用。</li></ul><hr><h3 id="4-8-连接查询"><a href="#4-8-连接查询" class="headerlink" title="4.8 连接查询"></a>4.8 连接查询</h3><p>连接查询是另一种类型的多表查询。连接查询对多个表进行JOIN运算，简单地说，就是<strong>先确定一个主表作为结果集，然后，把其他表的行有选择性地“连接”在主表结果集上</strong></p><p>例如，我们想要选出students表的所有学生信息，可以用一条简单的SELECT语句完成：</p><pre><code>SELECT     s.id, s.name,     s.class_id, s.gender,    s.score FROM     students s;</code></pre><p>但是，假设我们希望结果集同时包含所在班级的名称，上面的结果集只有class_id列，缺少对应班级的name列。</p><p>现在问题来了，存放班级名称的name列存储在classes表中，只有根据students表的class_id，<strong>找到classes表对应的行，再取出name列</strong>，就可以获得班级名称。</p><p>这时，连接查询就派上了用场。我们先使用最常用的一种<strong>内连接——INNER JOIN</strong>来实现：</p><pre><code>-- 选出所有学生，同时返回班级名称SELECT    s.id,   s.name, s.class_id,    c.name  class_name,    s.gender,   s.scoreFROM    students    sINNER JOIN  classe  cON  s.class_id  =   c.id;id    name    class_id    class_name    gender    score1    小明        1           一班        M        902    小红        1           一班        F        953    小军        1           一班        M        884    小米        1            一班        F        735    小白        2            二班        F        816    小兵        2           二班      M        557    小林        2            二班        M        858    小新        3            三班        F        919    小王        3           三班        M        8910    小丽        3            三班        F        88</code></pre><p>注意INNER JOIN查询的写法是：</p><ul><li>1、先确定主表，仍然使用FROM &lt;表1&gt;的语法；</li><li>2、再确定需要连接的表，使用INNER JOIN &lt;表2&gt;的语法；</li><li>3、然后确定连接条件，使用<code>ON &lt;条件...&gt;</code>，这里的条件是<code>s.class_id = c.id</code>，表示students表的class_id列与classes表的id列相同的行需要连接；</li><li>4、可选：加上WHERE子句、ORDER BY等子句。</li></ul><p>使用别名不是必须的，但可以更好地简化查询语句。</p><p>那什么是内连接（INNER JOIN）呢？先别着急，有内连接（INNER JOIN）就有外连接（OUTER JOIN）。我们把内连接查询改成外连接查询，看看效果：</p><pre><code>-- 使用OUTER JOINSELECT        s.id,   s.name, s.class_id,        c.name  class_name,        s.gender,   s.scoreFROM    students    sRIGHT OUTER JOIN  classe  cON  s.class_id  =   c.id;//结果略</code></pre><p>执行上述RIGHT OUTER JOIN可以看到，和INNER JOIN相比，RIGHT OUTER JOIN多了一行，多出来的一行是“四班”，但是，学生相关的列如name、gender、score都为NULL。</p><p>这也容易理解，因为根据ON条件s.class_id = c.id，classes表的id=4的行正是“四班”，但是，students表中并不存在class_id=4的行。</p><p>有RIGHT OUTER JOIN，就有LEFT OUTER JOIN，以及FULL OUTER JOIN。它们的区别是：</p><ul><li><p>1、INNER JOIN只返回同时存在于两张表的行数据，由于students表的class_id包含1，2，3，classes表的id包含1，2，3，4，所以，INNER JOIN根据条件s.class_id = c.id返回的结果集仅包含1，2，3。</p></li><li><p>2、RIGHT OUTER JOIN返回右表都存在的行。如果某一行仅在右表存在，那么结果集就会以NULL填充剩下的字段。</p></li><li><p>3、LEFT OUTER JOIN则返回左表都存在的行。如果我们给students表增加一行，并添加class_id=5，由于classes表并不存在id=5的行，所以，LEFT OUTER JOIN的结果会增加一行，对应的class_name是NULL：</p></li></ul><pre><code>   -- 先增加一列class_id=5:    INSERT INTO students (class_id, name, gender, score) values (5, &#39;新生&#39;, &#39;M&#39;, 88);    -- 使用LEFT OUTER JOIN    SELECT         s.id, s.name, s.class_id,                 c.name class_name, s.gender,              s.score    FROM students s    LEFT OUTER JOIN classes c    ON s.class_id = c.id;    //RESULTS 多了一行    id    name    class_id    class_name    gender    score    11    新生    5    NULL    M    88</code></pre><p>最后，我们使用FULL OUTER JOIN，它会把两张表的所有记录全部选择出来，并且，自动把对方不存在的列填充为NULL：</p><pre><code>-- 使用FULL OUTER JOINSELECT             s.id, s.name, s.class_id,                 c.name class_name, s.gender,              s.score        FROM students s        FULL OUTER JOIN classes c        ON s.class_id = c.id;        //RESULTS 多了两行id        name    class_id    class_name    gender        score11        新生        5            NULL        M           88 NULL    NULL        NULL        四班        NULL        NULL</code></pre><h4 id="小结-7"><a href="#小结-7" class="headerlink" title="小结"></a>小结</h4><ul><li>总的来说，我觉得<br>INNER JOIN 即  A ∩ B<br>LEFT OUTER JOIN 即 A∪ （A∩B）<br>RIGHT OUTER JOIN 即 B∪ （A∩B）<br>FULL OUTER JOIN 即 A ∪ B<br>（有图更形象）</li><li>JOIN查询需要先确定主表，然后把另一个表的数据“附加”到结果集上；INNER JOIN是最常用的一种JOIN查询，它的语法是    SELECT … FROM &lt;表1&gt; INNER JOIN &lt;表2&gt; ON &lt;条件…&gt;；</li><li>JOIN查询仍然可以使用WHERE条件和ORDER BY排序。</li></ul><hr>]]></content>
      
      
      <categories>
          
          <category> 数据库 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> MySQL </tag>
            
            <tag> SQL </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>数据库粗略回顾（一）</title>
      <link href="/2020/03/01/title-shu-ju-ku-cu-lue-hui-gu-yi/"/>
      <url>/2020/03/01/title-shu-ju-ku-cu-lue-hui-gu-yi/</url>
      
        <content type="html"><![CDATA[<pre><code>本科阶段已经学习过一个学期的数据库，但是很多理论性的知识因为很久不用所以忘得差不多了，现特抽出几天时间简单回顾下。</code></pre><h2 id="一、关系数据库概述"><a href="#一、关系数据库概述" class="headerlink" title="一、关系数据库概述"></a>一、关系数据库概述</h2><p>数据库作为一种专门管理数据的软件。应用程序不需要自己管理数据，而是通过数据库软件提供的<strong>接口</strong>来读写数据。至于数据本身如何存储到文件，那是数据库软件的事情，应用程序自己并不关心：</p><pre><code>┌──────────────┐│ application  │└──────────────┘       ▲│       ││   read││write       ││       │▼┌──────────────┐│   database   │└──────────────┘</code></pre><p>这样一来，编写应用程序的时候，数据读写的功能就被大大地简化了。</p><h3 id="数据模型"><a href="#数据模型" class="headerlink" title="数据模型"></a>数据模型</h3><p>三种</p><ul><li>层次模型</li><li>网状模型</li><li><strong>关系模型</strong></li></ul><p><strong>层次模型</strong>就是以“上下级”的层次关系来组织数据的一种方式，层次模型的数据结构看起来就像一颗树：</p><pre><code>            ┌─────┐            │     │            └─────┘               │       ┌───────┴───────┐       │               │    ┌─────┐         ┌─────┐    │     │         │     │    └─────┘         └─────┘       │               │   ┌───┴───┐       ┌───┴───┐   │       │       │       │┌─────┐ ┌─────┐ ┌─────┐ ┌─────┐│     │ │     │ │     │ │     │└─────┘ └─────┘ └─────┘ └─────┘</code></pre><p><strong>网状模型</strong>把每个数据节点和其他很多节点都连接起来，它的数据结构看起来就像很多城市之间的路网：</p><pre><code>     ┌─────┐      ┌─────┐   ┌─│     │──────│     │──┐   │ └─────┘      └─────┘  │   │    │            │     │   │    └──────┬─────┘     │   │           │           │┌─────┐     ┌─────┐     ┌─────┐│     │─────│     │─────│     │└─────┘     └─────┘     └─────┘   │           │           │   │     ┌─────┴─────┐     │   │     │           │     │   │  ┌─────┐     ┌─────┐  │   └──│     │─────│     │──┘      └─────┘     └─────┘</code></pre><p><strong>关系模型</strong>把数据看作是一个二维表格，任何数据都可以通过行号+列号来唯一确定，<strong><strong>它的数据模型看起来就是一个Excel表</strong></strong>：</p><pre><code>┌─────┬─────┬─────┬─────┬─────┐│     │     │     │     │     │├─────┼─────┼─────┼─────┼─────┤│     │     │     │     │     │├─────┼─────┼─────┼─────┼─────┤│     │     │     │     │     │├─────┼─────┼─────┼─────┼─────┤│     │     │     │     │     │└─────┴─────┴─────┴─────┴─────┘</code></pre><h3 id="数据类型"><a href="#数据类型" class="headerlink" title="数据类型"></a>数据类型</h3><p>对于一个关系表，除了定义每一列的名称外，还需要定义每一列的数据类型。关系数据库支持的标准数据类型包括数值、字符串、时间等：</p><pre><code>名称                  类型            说明INT                    整型            4字节整数类型，范围约+/-21亿BIGINT             长整型           8字节整数类型，范围约+/-922亿亿REAL                浮点型           4字节浮点数，范围约+/-1038DOUBLE                浮点型           8字节浮点数，范围约+/-10308DECIMAL(M,N)        高精度小数    由用户指定精度的小数，例如，DECIMAL(20,10)表示一共20位，其中小数10位，通常用于财务计算CHAR(N)    定长字符串    存储指定长度的字符串，例如，CHAR(100)总是存储100个字符的字符串VARCHAR(N)            变长字符串    存储可变长度的字符串，例如，VARCHAR(100)可以存储0~100个字符的字符串BOOLEAN                布尔类型    存储True或者FalseDATE                日期类型    存储日期，例如，2018-06-22TIME                时间类型    存储时间，例如，12:20:59DATETIME            日期和时间类型    存储日期+时间，例如，2018-06-22 12:20:59</code></pre><p>上述是常用数据类型，很多数据类型还有别名，REAL ——&gt; FLOAT(24), 还有一些不常用的数据类型TINYINT(0~255)、JSON等等。</p><p>选择数据类型的时候，要根据业务规则选择合适的类型。通常来说，BIGINT能满足整数存储的需求，VARCHAR(N)能满足字符串存储的需求，这两种类型是使用最广泛的。</p><h3 id="主流数据库介绍"><a href="#主流数据库介绍" class="headerlink" title="主流数据库介绍"></a>主流数据库介绍</h3><p>目前，主流的关系数据库主要分为以下几类：<br>1.<strong>商用数据库</strong>，例如：Oracle，SQL Server，DB2等；<br>2.<strong>开源数据库</strong>，例如：MySQL，PostgreSQL等；<br>3.<strong>桌面数据库</strong>，以微软Access为代表，适合桌面应用程序使用；<br>4.<strong>嵌入式数据库</strong>，以Sqlite为代表，适合手机应用和桌面程序。</p><h3 id="SQL介绍"><a href="#SQL介绍" class="headerlink" title="SQL介绍"></a>SQL介绍</h3><p>SQL是结构化查询语言的缩写，用来访问和操作数据库系统。不同的数据库，都支持SQL。</p><p>各个不同的数据库对标准的SQL支持不太一致。并且，大部分数据库都在标准的SQL上做了扩展。也就是说，如果只使用标准SQL，<strong>理论上所有数据库都可以支持</strong>，但如果使用某个特定数据库的扩展SQL，换一个数据库就不能执行了。例如，Oracle把自己扩展的SQL称为PL/SQL，Microsoft把自己扩展的SQL称为T-SQL。</p><p><strong>现实情况</strong>是，如果我们只使用标准SQL的核心功能，那么所有数据库通常都可以执行。不常用的SQL功能，不同的数据库支持的程度都不一样。而各个数据库支持的各自扩展的功能，通常我们把它们称之为“方言”。</p><p>总的来说，SQL语言定义了这么几种操作数据库的能力：</p><p>DDL：Data Definition Language<br>DDL允许用户定义数据，也就是<strong>创建表、删除表、修改表结构</strong>这些操作。通常，DDL由数据库管理员执行。</p><p>DML：Data Manipulation Language<br>DML为用户提供<strong>添加、删除、更新数据</strong>的能力，这些是应用程序对数据库的日常操作。</p><p>DQL：Data Query Language<br>DQL允许<strong>用户查询数据</strong>，这也是通常最频繁的数据库日常操作。</p><h3 id="语法特点"><a href="#语法特点" class="headerlink" title="语法特点"></a>语法特点</h3><p>SQL语言关键字不区分大小写，但一般 我们规定SQL关键字大写，表名、列名均使用小写。</p><hr><h2 id="二、安装MySQL"><a href="#二、安装MySQL" class="headerlink" title="二、安装MySQL"></a>二、安装MySQL</h2><pre><code>开源关系数据库，现Oracle 旗下产品</code></pre><p>和其他关系数据库有所不同的是，MySQL本身实际上只是一个SQL接口，它的内部还包含了多种数据引擎，常用的包括：</p><ul><li>InnoDB：由Innobase Oy公司开发的一款支持事务的数据库引擎，2006年被Oracle收购；</li><li>MyISAM：MySQL早期集成的默认数据库引擎，不支持事务。</li></ul><p>MySQL接口和数据库引擎的关系就好比某某浏览器和浏览器引擎（IE引擎或Webkit引擎）的关系。<strong>对用户而言，切换浏览器引擎不影响浏览器界面，<em>切换MySQL引擎不影响自己写的应用程序使用MySQL的接口。</em></strong></p><p>使用MySQL时，不同的表还可以使用不同的数据库引擎。如果你不知道应该采用哪种引擎，记住总是选择InnoDB就好了。</p><p>基于MySQL的衍生版本：MariaDB、Aurora、PolarDB .</p><p>MySQL官方版版本： </p><ul><li><p>Community Edition：社区开源版本，免费；</p></li><li><p>Standard Edition：标准版；</p></li><li><p>Enterprise Edition：企业版；</p></li><li><p>Cluster Carrier Grade Edition：集群版。</p><pre><code> 基本SQL功能相同</code></pre></li></ul><h3 id="安装MySQL"><a href="#安装MySQL" class="headerlink" title="安装MySQL"></a>安装MySQL</h3><p>网 址：<a href="https://dev.mysql.com/downloads/mysql/" target="_blank" rel="noopener">https://dev.mysql.com/downloads/mysql/</a></p><p>Debian和Ubuntu用户可以简单地通过命令</p><pre><code>apt-get install mysql-server</code></pre><p>安装最新的MySQL版本。</p><h3 id="运行MySQL"><a href="#运行MySQL" class="headerlink" title="运行MySQL"></a>运行MySQL</h3><pre><code>MySQL安装后会自动在后台运行。为了验证MySQL安装是否正确，我们需要通过mysql这个命令行程序来连接MySQL服务器。</code></pre><p>在命令提示符下输入<code>mysql -u root -p</code>，然后输入口令，如果一切正确，就会连接到MySQL服务器，同时提示符变为mysql&gt;。</p><p>输入exit退出MySQL命令行。注意，<strong>MySQL服务器仍在后台运行。</strong></p><hr><h2 id="三、关系模型"><a href="#三、关系模型" class="headerlink" title="三、关系模型"></a>三、关系模型</h2><pre><code>关系数据库是建立在关系模型上，而关系模型本质上就是若干个存储数据的二维表，可以把它们看作很多Excel表。</code></pre><p>表的每一行称为<strong>记录</strong>（Record），记录是一个逻辑意义上的数据。</p><p>表的每一列称为<strong>字段</strong>（Column），同一个表的每一行记录都拥有相同的若干字段。</p><p>字段定义了数据类型（整型、浮点型、字符串、日期等），以及是否允许为NULL。注意NULL表示字段数据不存在。<strong>一个整型字段如果为NULL不表示它的值为0，同样的，一个字符串型字段为NULL也不表示它的值为空串’’。</strong></p><pre><code>通常情况下，字段应该避免允许为NULL。不允许为NULL可以简化查询条件，加快查询速度，也利于应用程序读取数据后无需判断是否为NULL。</code></pre><p>和Excel表有所不同的是，关系数据库的表和表之间需要建立<strong>“一对多”，“多对一”和“一对一”</strong>的关系，这样才能够按照应用程序的逻辑来组织和存储数据。</p><p>例如，一个班级表：</p><pre><code>ID         名称              班主任201        二年级一班          王老师202        二年级二班        李老师</code></pre><p>每一行对应着一个班级，而一个班级对应着多个学生，所以<strong>班级表和学生表的关系就是“一对多”</strong>：</p><pre><code>ID    姓名    班级ID    性别    年龄1    小明    201      M       92    小红    202         F       83    小军    202         M       84    小白    201     F       9</code></pre><p>反过来，如果我们先在学生表中定位了一行记录，例如ID=1的小明，要确定他的班级，只需要根据他的“班级ID”对应的值201找到班级表中ID=201的记录，即二年级一班。所以，<strong>学生表和班级表是“多对一”的关系。</strong></p><p>如果我们把班级表分拆得细一点，例如，单独创建一个教师表：</p><pre><code>ID        名称        年龄A1        王老师        26A2        张老师        39A3        李老师      32A4        赵老师      27</code></pre><p>班级表只存储教师ID：</p><pre><code>ID        名称            班主任ID201        二年级一班         A1202     二年级二班        A3</code></pre><p>这样，一个班级总是对应一个教师，<strong>班级表和教师表就是“一对一”关系</strong>。</p><p><strong>在关系数据库中，关系是通过主键和外键来维护的。</strong>我们在后面会分别深入讲解。</p><hr><h3 id="3-1-1-主键"><a href="#3-1-1-主键" class="headerlink" title="3.1.1 主键"></a>3.1.1 主键</h3><p>对于关系表，有个很重要的约束，就是任意两条记录不能重复。不能重复不是指两条记录不完全相同，而是<strong>指能够通过某个字段唯一区分出不同的记录，这个字段被称为<em>主键</em>。</strong></p><p>例如，students表的两行记录：</p><pre><code>id    class_id    name    gender    score1    1            小明        M        902    1            小红        F        95</code></pre><p>假设我们把name字段作为主键，那么通过名字小明或小红就能唯一确定一条记录。但是，这么设定，就没法存储同名的同学了，<strong>因为插入相同主键的两条记录是不被允许的</strong>。</p><p>对主键的要求，最关键的一点是：<strong>记录一旦插入到表中，主键最好不要再修改</strong>，因为主键是用来唯一定位记录的，修改了主键，会造成一系列的影响。</p><p>由于主键的作用十分重要，如何选取主键会对业务开发产生重要影响。如果我们以学生的身份证号作为主键，似乎能唯一定位记录。然而，身份证号也是一种业务场景，如果身份证号升位了，或者需要变更，作为主键，不得不修改的时候，就会对业务产生严重影响。</p><p>所以，选取主键的一个基本原则是：<strong>不使用任何业务相关的字段作为主键。</strong></p><p>因此，身份证号、手机号、邮箱地址这些看上去可以唯一的字段，均<strong>不可</strong>用作主键。</p><p>作为主键最好是<strong>完全业务无关</strong>的字段，我们一般把这个字段命名为id。常见的可作为id字段的类型有：</p><ol><li><strong>自增整数类型</strong>：数据库会在插入数据时自动为每一条记录分配一个<strong>自增整数</strong>，这样我们就完全不用担心主键重复，也不用自己预先生成主键；</li></ol><p>2.<strong>全局唯一GUID类型</strong>：使用一种全局唯一的字符串作为主键，类似8f55d96b-8acc-4636-8cb8-76bf8abc2f57。GUID算法通过网卡MAC地址、时间戳和随机数保证任意计算机在任意时间生成的字符串都是不同的，大部分编程语言都内置了GUID算法，可以自己预算出主键。</p><p>对于大部分应用来说，<strong>通常自增类型的主键就能满足需求</strong>。我们在students表中定义的主键也是BIGINT NOT NULL AUTO_INCREMENT类型。</p><pre><code>如果使用INT自增类型，那么当一张表的记录数超过2147483647（约21亿）时，会达到上限而出错。使用BIGINT自增类型则可以最多约922亿亿条记录。</code></pre><h3 id="3-1-2-联合主键"><a href="#3-1-2-联合主键" class="headerlink" title="3.1.2 联合主键"></a>3.1.2 联合主键</h3><p> 关系数据库实际上还允许通过多个字段唯一标识记录，即两个或更多的字段都设置为主键，这种主键被称为联合主键。</p><p> 对于联合主键，<strong>允许一列主键有重复</strong>，只要不是所有主键列都重复即可：</p><pre><code> id_num              id_type            other columns...    1               A                       ...    2                A                        ...    2                B                       ...</code></pre><p>如果我们把上述表的<strong>id_num和id_type这两列作为联合主键</strong>，那么上面的3条记录都是允许的，因为没有两列主键组合起来是相同的。</p><p>没有必要的情况下，我们尽量不使用联合主键，因为它给关系表带来了复杂度的上升。</p><h3 id="3-1-3-小结"><a href="#3-1-3-小结" class="headerlink" title="3.1.3  小结"></a>3.1.3  小结</h3><p> 主键是关系表中记录的唯一标识。主键的选取非常重要：<strong>主键不要带有业务含义，而应该使用BIGINT自增或者GUID类型。主键也不应该允许NULL。</strong></p><p>可以使用多个列作为联合主键，但联合主键并不常用。</p><hr><h3 id="3-2-1-外键"><a href="#3-2-1-外键" class="headerlink" title="3.2.1  外键"></a>3.2.1  外键</h3><p>当我们用主键唯一标识记录时，我们就可以在 <em>students</em> 表中确定任意一个学生的记录：</p><pre><code>id    name    other columns...1    小明        ...2    小红        ...</code></pre><p>我们还可以在 <em>classes</em> 表中确定任意一个班级记录：</p><pre><code>id    name    other columns...1    一班    ...2    二班    ...</code></pre><p>但是我们如何确定students表的一条记录，例如，id=1的小明，属于哪个班级呢？</p><p>由于一个班级可以有多个学生，在关系模型中，这两个表的关系可以称为<strong>“一对多”</strong>，即一个classes的记录可以对应多个students表的记录。</p><p>为了表达这种一对多的关系，我们需要在students表中加入一列class_id，让它的值与classes表的某条记录相对应：</p><pre><code>id    class_id    name    other columns...1        1        小明        ...2        1       小红        ...5        2        小白        ...</code></pre><p>这样，我们就可以根据class_id这个列直接定位出一个students表的记录应该对应到classes的哪条记录。    </p><p>在students表中，<strong>通过class_id的字段，可以把数据与另一张表关联起来</strong>，这种列称为<strong>外键</strong>。</p><p>外键并不是通过列名实现的，而是<strong>通过定义外键约束实现</strong>的：</p><pre><code>ALTER TABLE studentsADD CONSTRAINT fk_class_idFOREIGN KEY (class_id)REFERENCES classes (id);</code></pre><p>其中，外键约束的名称fk_class_id可以任意，FOREIGN KEY (class_id)指定了class_id作为外键，REFERENCES classes (id)指定了这个外键将关联到classes表的id列（即classes表的主键）。</p><p><strong>通过定义外键约束，关系数据库可以保证无法插入无效的数据</strong>。即如果classes表不存在id=99的记录，students表就无法插入class_id=99的记录。</p><p><em>由于外键约束会降低数据库的性能，大部分互联网应用程序为了追求速度，并不设置外键约束，而是仅靠应用程序自身来保证逻辑的正确性</em>。这种情况下，class_id仅仅是一个普通的列，只是它起到了外键的作用而已。</p><p>要删除一个外键约束，也是通过ALTER TABLE实现的：</p><pre><code>ALTER TABLE studentsDROP FOREIGN KEY fk_class_id;</code></pre><p>注意：<strong>删除外键约束并没有删除外键这一列</strong>。删除列是通过DROP COLUMN …实现的。</p><h3 id="3-2-2-多对多"><a href="#3-2-2-多对多" class="headerlink" title="3.2.2 多对多"></a>3.2.2 多对多</h3><p>通过一个表的外键关联到另一个表，我们可以定义出一对多关系。有些时候，还需要定义“多对多”关系。例如，一个老师可以对应多个班级，一个班级也可以对应多个老师，因此，<strong>班级表和老师表存在多对多关系。</strong></p><p>多对多关系实际上是通过两个一对多关系实现的，即<strong>通过一个中间表，关联两个一对多关系，就形成了多对多关系：</strong></p><p><strong>teachers表：</strong></p><pre><code>id    name1    张老师2    王老师3    李老师4    赵老师</code></pre><p><strong>classes表：</strong></p><pre><code>id    name1    一班2    二班</code></pre><p><strong>中间表teacher_class关联两个一对多关系：</strong></p><pre><code>id    teacher_id    class_id1        1           12       1           23        2            14        2            25        3            16        4            2</code></pre><p>通过中间表teacher_class可知teachers到classes的关系：</p><ul><li>id=1的张老师对应id=1,2的一班和二班；</li><li>id=2的王老师对应id=1,2的一班和二班；</li><li>id=3的李老师对应id=1的一班；</li><li>id=4的赵老师对应id=2的二班。  </li></ul><p>同理可知classes到teachers的关系：</p><ul><li>id=1的一班对应id=1,2,3的张老师、王老师和李老师；</li><li>id=2的二班对应id=1,2,4的张老师、王老师和赵老师；</li></ul><p>因此，通过中间表，我们就定义了一个“多对多”关系。</p><h3 id="3-2-3-一对一"><a href="#3-2-3-一对一" class="headerlink" title="3.2.3 一对一"></a>3.2.3 一对一</h3><pre><code>一对一关系是指，一个表的记录对应到另一个表的唯一一个记录。</code></pre><p>例如，students表的每个学生可以有自己的联系方式，如果<em>把联系方式存入另一个表contacts</em>，我们就可以得到一个“一对一”关系：</p><pre><code>id        student_id        mobile1           1          135xxxx63002            2          138xxxx22093            5          139xxxx8086</code></pre><p>既然是一对一关系，那为啥不给students表增加一个mobile列，这样就能合二为一了？??</p><p>如果业务允许，完全可以把两个表合为一个表。但是，有些时候，如果某个学生没有手机号，那么，contacts表就不存在对应的记录。实际上，<strong>一对一关系准确地说，是contacts表一对一对应students表。</strong>    </p><p>还<strong>有一些应用会把一个大表拆成两个一对一的表，目的是把经常读取和不经常读取的字段分开，以获得更高的性能。</strong>例如，把一个大的用户表分拆为用户基本信息表user_info和用户详细信息表user_profiles，大部分时候，只需要查询user_info表，并不需要查询user_profiles表，这样就提高了查询速度。</p><h3 id="3-2-4-小结"><a href="#3-2-4-小结" class="headerlink" title="3.2.4 小结"></a>3.2.4 小结</h3><pre><code>关系数据库通过外键可以实现一对多、多对多和一对一的关系。外键既可以通过数据库来约束，也可以不设置约束，仅依靠应用程序的逻辑来保证。</code></pre><hr><h3 id="3-3-1-索引"><a href="#3-3-1-索引" class="headerlink" title="3.3.1 索引"></a>3.3.1 索引</h3><pre><code>在关系数据库中，如果有上万甚至上亿条记录，在查找记录的时候，想要获得非常快的速度，就需要使用索引。</code></pre><p><strong>索引</strong>是<strong>关系数据库中对某一列或多个列的值进行<em>预排序</em>的数据结构</strong>。通过使用索引，可以让数据库系统不必扫描整个表，而是直接定位到符合条件的记录，这样就<em>大大加快了查询速度</em>。</p><p>例如，对于students表：</p><pre><code>id        class_id        name    gender        score1            1           小明        M            902            1            小红        F           953           1           小军        M            88</code></pre><p>如果要经常根据score列进行查询，就可以对score列创建索引：</p><pre><code>ALTER TABLE studentsADD INDEX idx_score (score);</code></pre><p>使用 ADD INDEX idx_score (score) 就创建了一个名称为 idx_score ，使用列 score 的索引。索引名称是任意的，索引如果有多列，可以在括号里依次写上，例如：</p><pre><code>ALTER TABLE studentsADD INDEX idx_name_score (name, score);</code></pre><p><strong>索引的效率取决于索引列的值是否散列</strong>，即该列的值如果越<strong>互不相同</strong>，那么索引效率越高。反过来，如果记录的列存在大量相同的值，例如gender列，大约一半的记录值是 M，另一半是 F，因此，对该列创建索引就没有意义。</p><p>可以对一张表创建多个索引。索引的<strong>优</strong>点：提高了查询效率，<strong>缺点</strong>：在插入、更新和删除记录时，需要同时修改索引，因此，<strong>索引越多，插入、更新和删除记录的速度就越慢。</strong></p><p><strong>对于主键，关系数据库会自动对其创建主键索引</strong>。使用主键索引的效率是最高的，因为主键会保证绝对唯一。</p><h3 id="3-3-2-唯一索引"><a href="#3-3-2-唯一索引" class="headerlink" title="3.3.2 唯一索引"></a>3.3.2 唯一索引</h3><p>在设计关系数据表的时候，看上去唯一的列，例如身份证号、邮箱地址等，因为他们具有业务含义，因此不宜作为主键。</p><p>但是，<strong>这些列根据业务要求，又具有唯一性约束</strong>：即不能出现两条记录存储了同一个身份证号。这个时候，就可以给该列添加一个唯一索引。例如，我们假设students表的name不能重复：<br>（即不宜作主键，宜作索引）</p><pre><code>ALTER TABLE studentsADD UNIQUE INDEX uni_name (name);</code></pre><p>通过<strong>UNIQUE关键字</strong>我们就添加了一个唯一索引。<br>也可以只对某一列添加一个唯一约束而不创建唯一索引</p><pre><code>ALTER TABLE studentsADD CONSTRAINT uni_name UNIQUE (name);</code></pre><p>这种情况下，name列没有索引，但仍然具有唯一性保证。</p><p>无论是否创建索引，对于用户和应用程序来说，使用关系数据库不会有任何区别。这里的意思是说，当我们在数据库中查询时，如果有相应的索引可用，数据库系统就会自动使用索引来提高查询效率，如果没有索引，查询也能正常执行，只是速度会变慢。因此，索引可以在使用数据库的过程中逐步优化。</p><h3 id="3-3-3-小结"><a href="#3-3-3-小结" class="headerlink" title="3.3.3 小结"></a>3.3.3 小结</h3><p>通过对数据库表创建索引，可以提高查询速度。</p><p>通过创建唯一索引，可以保证某一列的值具有唯一性。</p><p>数据库索引对于用户和应用程序来说都是<strong>透明的</strong>。</p><hr>]]></content>
      
      
      <categories>
          
          <category> 数据库 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> MySQL </tag>
            
            <tag> SQL </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>十大经典排序算法整理汇总（附代码）</title>
      <link href="/2020/02/16/sort-algorithms/"/>
      <url>/2020/02/16/sort-algorithms/</url>
      
        <content type="html"><![CDATA[<blockquote><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2></blockquote><p>本文整理并总结了十大经典的排序算法（冒泡排序、选择排序、插入排序、快速排序、归并排序、希尔排序、计数排序、基数排序、桶排序、堆排序）的时间复杂度、空间复杂度等性质。</p><p><strong>本文并不会详细讲解每种排序算法的原理</strong>，网上有很多很好的教程，大家可以自己去搜了看。</p><p>最后我还亲自手写了十种排序算法的 c++ 代码，大家可以用来通过 <a href="https://leetcode-cn.com/problems/sort-an-array/" title="LeetCode 912. 排序数组" target="_blank" rel="noopener">LeetCode 912. 排序数组</a> 这道题。</p><h2 id="性质汇总"><a href="#性质汇总" class="headerlink" title="性质汇总"></a>性质汇总</h2><blockquote><p>如果发现表中有错误，请留言告知。</p></blockquote><table><thead><tr><th>算法</th><th>最好</th><th>最坏</th><th>平均</th><th>空间</th><th align="center">稳定性</th><th align="center">是否基于比较</th></tr></thead><tbody><tr><td>冒泡排序</td><td>$O(n)$</td><td>$O(n^2)$</td><td>$O(n^2)$</td><td>$O(1)$</td><td align="center">$\checkmark$</td><td align="center">$\checkmark$</td></tr><tr><td>选择排序</td><td>$O(n^2)$</td><td>$O(n^2)$</td><td>$O(n^2)$</td><td>$O(1)$</td><td align="center">$\times$</td><td align="center">$\checkmark$</td></tr><tr><td>插入排序</td><td>$O(n)$</td><td>$O(n^2)$</td><td>$O(n^2)$</td><td>$O(1)$</td><td align="center">$\checkmark$</td><td align="center">$\checkmark$</td></tr><tr><td>快速排序</td><td>$O(n\log n)$</td><td>$O(n^2)$</td><td>$O(n\log n)$</td><td>$O(\log n)$~$O(n)$</td><td align="center">$\times$</td><td align="center">$\checkmark$</td></tr><tr><td>归并排序</td><td>$O(n\log n)$</td><td>$O(n\log n)$</td><td>$O(n\log n)$</td><td>$O(n)$</td><td align="center">$\checkmark$</td><td align="center">$\checkmark$</td></tr><tr><td>希尔排序</td><td>$O(n^{1.3})$</td><td>$O(n^2)$</td><td>$O(n\log n)$~$O(n^2)$</td><td>$O(1)$</td><td align="center">$\times$</td><td align="center">$\checkmark$</td></tr><tr><td>计数排序</td><td>$O(n+k)$</td><td>$O(n+k)$</td><td>$O(n+k)$</td><td>$O(n+k)$</td><td align="center">$\checkmark$</td><td align="center">$\times$</td></tr><tr><td>基数排序</td><td>$O(nk)$</td><td>$O(nk)$</td><td>$O(nk)$</td><td>$O(n+k)$</td><td align="center">$\checkmark$</td><td align="center">$\times$</td></tr><tr><td>桶排序</td><td>$O(n)$</td><td>$O(n)$</td><td>$O(n)$</td><td>$O(n+m)$</td><td align="center">$\checkmark$</td><td align="center">$\times$</td></tr><tr><td>堆排序</td><td>$O(n\log n)$</td><td>$O(n\log n)$</td><td>$O(n\log n)$</td><td>$O(1)$</td><td align="center">$\times$</td><td align="center">$\checkmark$</td></tr></tbody></table><blockquote><p>如果表格显示有问题的话，还可以直接看下面的汇总图：</p></blockquote><p><img src="1.png" alt="十大经典排序算法性质汇总"></p><h3 id="维基百科"><a href="#维基百科" class="headerlink" title="维基百科"></a>维基百科</h3><p>我觉得还是英文维基百科讲的比较详细、严谨。如果大家看的比较累的话，可以自己百度搜索相应的教程。</p><p><strong>冒泡排序</strong><br><a href="https://en.wikipedia.org/wiki/Bubble_sort" target="_blank" rel="noopener">https://en.wikipedia.org/wiki/Bubble_sort</a></p><p><strong>选择排序</strong><br><a href="https://en.wikipedia.org/wiki/Selection_sort" target="_blank" rel="noopener">https://en.wikipedia.org/wiki/Selection_sort</a></p><p><strong>插入排序</strong><br><a href="https://en.wikipedia.org/wiki/Insertion_sort" target="_blank" rel="noopener">https://en.wikipedia.org/wiki/Insertion_sort</a></p><p><strong>快速排序</strong><br><a href="https://en.wikipedia.org/wiki/Quicksort" target="_blank" rel="noopener">https://en.wikipedia.org/wiki/Quicksort</a></p><p><strong>归并排序</strong><br><a href="https://en.wikipedia.org/wiki/Merge_sort" target="_blank" rel="noopener">https://en.wikipedia.org/wiki/Merge_sort</a></p><p><strong>希尔排序</strong><br><a href="https://en.wikipedia.org/wiki/Shellsort" target="_blank" rel="noopener">https://en.wikipedia.org/wiki/Shellsort</a></p><p><strong>计数排序</strong><br><a href="https://en.wikipedia.org/wiki/Counting_sort" target="_blank" rel="noopener">https://en.wikipedia.org/wiki/Counting_sort</a></p><p><strong>基数排序</strong><br><a href="https://en.wikipedia.org/wiki/Radix_sort" target="_blank" rel="noopener">https://en.wikipedia.org/wiki/Radix_sort</a></p><p><strong>桶排序</strong><br><a href="https://en.wikipedia.org/wiki/Bucket_sort" target="_blank" rel="noopener">https://en.wikipedia.org/wiki/Bucket_sort</a></p><p><strong>堆排序</strong><br><a href="https://en.wikipedia.org/wiki/Heapsort" target="_blank" rel="noopener">https://en.wikipedia.org/wiki/Heapsort</a></p><h2 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h2><p>所有的排序算法接口都是相同的，也就是 <code>vector&lt;int&gt; xxxSort(vector&lt;int&gt;&amp; nums)</code> 。只需要你传入一个 <code>vector&lt;int&gt;</code> 类型的数组，就能返回排序后的结果。</p><p>运行下来可以发现，桶排序速度是比较快的。而冒泡排序、选择排序和插入排序因为时间复杂度太高无法通过本题，基数排序因为无法处理负数也不能通过本题。</p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">{</span><span class="token keyword">public</span><span class="token operator">:</span>    vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span> <span class="token function">sortArray</span><span class="token punctuation">(</span>vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span><span class="token operator">&amp;</span> nums<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">return</span> <span class="token function">quickSort</span><span class="token punctuation">(</span>nums<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">// 冒泡排序（超时）</span>    vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span> <span class="token function">bubbleSort</span><span class="token punctuation">(</span>vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span><span class="token operator">&amp;</span> nums<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">int</span> n <span class="token operator">=</span> nums<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> n<span class="token punctuation">;</span> <span class="token operator">++</span>i<span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> j <span class="token operator">=</span> n<span class="token number">-2</span><span class="token punctuation">;</span> j <span class="token operator">>=</span> i<span class="token punctuation">;</span> <span class="token operator">--</span>j<span class="token punctuation">)</span> <span class="token punctuation">{</span>                <span class="token keyword">if</span> <span class="token punctuation">(</span>nums<span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">></span> nums<span class="token punctuation">[</span>j<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                    <span class="token function">swap</span><span class="token punctuation">(</span>nums<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">,</span> nums<span class="token punctuation">[</span>j<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token punctuation">}</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span>        <span class="token keyword">return</span> nums<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">// 选择排序（超时）</span>    vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span> <span class="token function">selectSort</span><span class="token punctuation">(</span>vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span><span class="token operator">&amp;</span> nums<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">int</span> n <span class="token operator">=</span> nums<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> n<span class="token punctuation">;</span> <span class="token operator">++</span>i<span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">int</span> idx <span class="token operator">=</span> i<span class="token punctuation">;</span>            <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> j <span class="token operator">=</span> i<span class="token punctuation">;</span> j <span class="token operator">&lt;</span> n<span class="token punctuation">;</span> <span class="token operator">++</span>j<span class="token punctuation">)</span> <span class="token punctuation">{</span>                <span class="token keyword">if</span> <span class="token punctuation">(</span>nums<span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">&lt;</span> nums<span class="token punctuation">[</span>idx<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                    idx <span class="token operator">=</span> j<span class="token punctuation">;</span>                <span class="token punctuation">}</span>            <span class="token punctuation">}</span>            <span class="token function">swap</span><span class="token punctuation">(</span>nums<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">,</span> nums<span class="token punctuation">[</span>idx<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">return</span> nums<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">// 插入排序（超时）</span>    vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span> <span class="token function">insertSort</span><span class="token punctuation">(</span>vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span><span class="token operator">&amp;</span> nums<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">int</span> n <span class="token operator">=</span> nums<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> n<span class="token punctuation">;</span> <span class="token operator">++</span>i<span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> j <span class="token operator">=</span> i<span class="token punctuation">;</span> j <span class="token operator">></span> <span class="token number">0</span> <span class="token operator">&amp;&amp;</span> nums<span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">&lt;</span> nums<span class="token punctuation">[</span>j<span class="token number">-1</span><span class="token punctuation">]</span><span class="token punctuation">;</span> <span class="token operator">--</span>j<span class="token punctuation">)</span> <span class="token punctuation">{</span>                <span class="token function">swap</span><span class="token punctuation">(</span>nums<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">,</span> nums<span class="token punctuation">[</span>j<span class="token number">-1</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span>        <span class="token keyword">return</span> nums<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">// 快速排序（24 ms）</span>    <span class="token keyword">void</span> <span class="token function">qSort</span><span class="token punctuation">(</span>vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span><span class="token operator">&amp;</span> nums<span class="token punctuation">,</span> <span class="token keyword">int</span> l<span class="token punctuation">,</span> <span class="token keyword">int</span> r<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>l <span class="token operator">>=</span> r<span class="token punctuation">)</span> <span class="token keyword">return</span><span class="token punctuation">;</span>        <span class="token keyword">int</span> m <span class="token operator">=</span> l<span class="token punctuation">;</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> l<span class="token punctuation">;</span> i <span class="token operator">&lt;</span> r<span class="token punctuation">;</span> <span class="token operator">++</span>i<span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>nums<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">&lt;</span> nums<span class="token punctuation">[</span>r<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                <span class="token function">swap</span><span class="token punctuation">(</span>nums<span class="token punctuation">[</span>m<span class="token operator">++</span><span class="token punctuation">]</span><span class="token punctuation">,</span> nums<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span>        <span class="token function">swap</span><span class="token punctuation">(</span>nums<span class="token punctuation">[</span>m<span class="token punctuation">]</span><span class="token punctuation">,</span> nums<span class="token punctuation">[</span>r<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token function">qSort</span><span class="token punctuation">(</span>nums<span class="token punctuation">,</span> l<span class="token punctuation">,</span> m<span class="token number">-1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token function">qSort</span><span class="token punctuation">(</span>nums<span class="token punctuation">,</span> m<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">,</span> r<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span> <span class="token function">quickSort</span><span class="token punctuation">(</span>vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span><span class="token operator">&amp;</span> nums<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">int</span> n <span class="token operator">=</span> nums<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token function">qSort</span><span class="token punctuation">(</span>nums<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> n<span class="token number">-1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">return</span> nums<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">// 归并排序（192 ms）</span>    vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span> <span class="token function">mSort</span><span class="token punctuation">(</span>vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span><span class="token operator">&amp;</span> nums<span class="token punctuation">,</span> <span class="token keyword">int</span> l<span class="token punctuation">,</span> <span class="token keyword">int</span> r<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>l <span class="token operator">>=</span> r<span class="token punctuation">)</span> <span class="token keyword">return</span> <span class="token punctuation">{</span>nums<span class="token punctuation">[</span>l<span class="token punctuation">]</span><span class="token punctuation">}</span><span class="token punctuation">;</span>        <span class="token keyword">int</span> m <span class="token operator">=</span> l<span class="token operator">+</span><span class="token punctuation">(</span>r<span class="token operator">-</span>l<span class="token punctuation">)</span><span class="token operator">/</span><span class="token number">2</span><span class="token punctuation">;</span>        vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span> lnums <span class="token operator">=</span> <span class="token function">mSort</span><span class="token punctuation">(</span>nums<span class="token punctuation">,</span> l<span class="token punctuation">,</span> m<span class="token punctuation">)</span><span class="token punctuation">;</span>        vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span> rnums <span class="token operator">=</span> <span class="token function">mSort</span><span class="token punctuation">(</span>nums<span class="token punctuation">,</span> m<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">,</span> r<span class="token punctuation">)</span><span class="token punctuation">;</span>        vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span> res<span class="token punctuation">;</span>        <span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">,</span> j <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>        <span class="token keyword">while</span> <span class="token punctuation">(</span>i <span class="token operator">&lt;=</span> m<span class="token operator">-</span>l <span class="token operator">&amp;&amp;</span> j <span class="token operator">&lt;=</span> r<span class="token operator">-</span>m<span class="token number">-1</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>lnums<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">&lt;</span> rnums<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                res<span class="token punctuation">.</span><span class="token function">push_back</span><span class="token punctuation">(</span>lnums<span class="token punctuation">[</span>i<span class="token operator">++</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>                res<span class="token punctuation">.</span><span class="token function">push_back</span><span class="token punctuation">(</span>rnums<span class="token punctuation">[</span>j<span class="token operator">++</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span>        <span class="token keyword">while</span> <span class="token punctuation">(</span>i <span class="token operator">&lt;=</span> m<span class="token operator">-</span>l<span class="token punctuation">)</span> <span class="token punctuation">{</span>            res<span class="token punctuation">.</span><span class="token function">push_back</span><span class="token punctuation">(</span>lnums<span class="token punctuation">[</span>i<span class="token operator">++</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">while</span> <span class="token punctuation">(</span>j <span class="token operator">&lt;=</span> r<span class="token operator">-</span>m<span class="token number">-1</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            res<span class="token punctuation">.</span><span class="token function">push_back</span><span class="token punctuation">(</span>rnums<span class="token punctuation">[</span>j<span class="token operator">++</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">return</span> res<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span> <span class="token function">mergeSort</span><span class="token punctuation">(</span>vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span><span class="token operator">&amp;</span> nums<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">int</span> n <span class="token operator">=</span> nums<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        nums <span class="token operator">=</span> <span class="token function">mSort</span><span class="token punctuation">(</span>nums<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> n<span class="token number">-1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">return</span> nums<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">// 归并排序 + 非递归（80 ms）</span>    vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span> <span class="token function">mergeSortNR</span><span class="token punctuation">(</span>vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span><span class="token operator">&amp;</span> nums<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">int</span> n <span class="token operator">=</span> nums<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> len <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span> len <span class="token operator">&lt;</span> n<span class="token punctuation">;</span> len <span class="token operator">&lt;&lt;=</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> l <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> l <span class="token operator">&lt;</span> n<span class="token operator">-</span>len<span class="token punctuation">;</span> l <span class="token operator">+</span><span class="token operator">=</span> <span class="token number">2</span><span class="token operator">*</span>len<span class="token punctuation">)</span> <span class="token punctuation">{</span>                <span class="token keyword">int</span> m <span class="token operator">=</span> l<span class="token operator">+</span>len<span class="token number">-1</span><span class="token punctuation">;</span>                <span class="token keyword">int</span> r <span class="token operator">=</span> <span class="token function">min</span><span class="token punctuation">(</span>n<span class="token number">-1</span><span class="token punctuation">,</span> l<span class="token operator">+</span><span class="token number">2</span><span class="token operator">*</span>len<span class="token number">-1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span> res<span class="token punctuation">;</span>                <span class="token keyword">int</span> i <span class="token operator">=</span> l<span class="token punctuation">,</span> j <span class="token operator">=</span> m<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">;</span>                <span class="token keyword">while</span> <span class="token punctuation">(</span>i <span class="token operator">&lt;=</span> m <span class="token operator">&amp;&amp;</span> j <span class="token operator">&lt;=</span> r<span class="token punctuation">)</span> <span class="token punctuation">{</span>                    <span class="token keyword">if</span> <span class="token punctuation">(</span>nums<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">&lt;</span> nums<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                        res<span class="token punctuation">.</span><span class="token function">push_back</span><span class="token punctuation">(</span>nums<span class="token punctuation">[</span>i<span class="token operator">++</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                    <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>                        res<span class="token punctuation">.</span><span class="token function">push_back</span><span class="token punctuation">(</span>nums<span class="token punctuation">[</span>j<span class="token operator">++</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                    <span class="token punctuation">}</span>                <span class="token punctuation">}</span>                <span class="token keyword">while</span> <span class="token punctuation">(</span>i <span class="token operator">&lt;=</span> m<span class="token punctuation">)</span> <span class="token punctuation">{</span>                    res<span class="token punctuation">.</span><span class="token function">push_back</span><span class="token punctuation">(</span>nums<span class="token punctuation">[</span>i<span class="token operator">++</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token punctuation">}</span>                <span class="token keyword">while</span> <span class="token punctuation">(</span>j <span class="token operator">&lt;=</span> r<span class="token punctuation">)</span> <span class="token punctuation">{</span>                    res<span class="token punctuation">.</span><span class="token function">push_back</span><span class="token punctuation">(</span>nums<span class="token punctuation">[</span>j<span class="token operator">++</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token punctuation">}</span>                <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> l<span class="token punctuation">;</span> i <span class="token operator">&lt;=</span> r<span class="token punctuation">;</span> <span class="token operator">++</span>i<span class="token punctuation">)</span> <span class="token punctuation">{</span>                    nums<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> res<span class="token punctuation">[</span>i<span class="token operator">-</span>l<span class="token punctuation">]</span><span class="token punctuation">;</span>                <span class="token punctuation">}</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span>        <span class="token keyword">return</span> nums<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">// 希尔排序（40 ms）</span>    vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span> <span class="token function">shellSort</span><span class="token punctuation">(</span>vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span><span class="token operator">&amp;</span> nums<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">int</span> n <span class="token operator">=</span> nums<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> gap <span class="token operator">=</span> n<span class="token operator">/</span><span class="token number">2</span><span class="token punctuation">;</span> gap <span class="token operator">></span> <span class="token number">0</span><span class="token punctuation">;</span> gap <span class="token operator">/</span><span class="token operator">=</span> <span class="token number">2</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> gap<span class="token punctuation">;</span> i <span class="token operator">&lt;</span> n<span class="token punctuation">;</span> <span class="token operator">++</span>i<span class="token punctuation">)</span> <span class="token punctuation">{</span>                <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> j <span class="token operator">=</span> i<span class="token punctuation">;</span> j<span class="token operator">-</span>gap <span class="token operator">>=</span> <span class="token number">0</span> <span class="token operator">&amp;&amp;</span> nums<span class="token punctuation">[</span>j<span class="token operator">-</span>gap<span class="token punctuation">]</span> <span class="token operator">></span> nums<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">;</span> j <span class="token operator">-</span><span class="token operator">=</span> gap<span class="token punctuation">)</span> <span class="token punctuation">{</span>                    <span class="token function">swap</span><span class="token punctuation">(</span>nums<span class="token punctuation">[</span>j<span class="token operator">-</span>gap<span class="token punctuation">]</span><span class="token punctuation">,</span> nums<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token punctuation">}</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span>        <span class="token keyword">return</span> nums<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">// 计数排序（32 ms）</span>    vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span> <span class="token function">countSort</span><span class="token punctuation">(</span>vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span><span class="token operator">&amp;</span> nums<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">int</span> n <span class="token operator">=</span> nums<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>n<span class="token punctuation">)</span> <span class="token keyword">return</span> <span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">;</span>        <span class="token keyword">int</span> minv <span class="token operator">=</span> <span class="token operator">*</span><span class="token function">min_element</span><span class="token punctuation">(</span>nums<span class="token punctuation">.</span><span class="token function">begin</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> nums<span class="token punctuation">.</span><span class="token function">end</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">int</span> maxv <span class="token operator">=</span> <span class="token operator">*</span><span class="token function">max_element</span><span class="token punctuation">(</span>nums<span class="token punctuation">.</span><span class="token function">begin</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> nums<span class="token punctuation">.</span><span class="token function">end</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">int</span> m <span class="token operator">=</span> maxv<span class="token operator">-</span>minv<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">;</span>        vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span> <span class="token function">count</span><span class="token punctuation">(</span>m<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> n<span class="token punctuation">;</span> <span class="token operator">++</span>i<span class="token punctuation">)</span> <span class="token punctuation">{</span>            count<span class="token punctuation">[</span>nums<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token operator">-</span>minv<span class="token punctuation">]</span><span class="token operator">++</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span> res<span class="token punctuation">;</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> m<span class="token punctuation">;</span> <span class="token operator">++</span>i<span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> j <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> j <span class="token operator">&lt;</span> count<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span> <span class="token operator">++</span>j<span class="token punctuation">)</span> <span class="token punctuation">{</span>                res<span class="token punctuation">.</span><span class="token function">push_back</span><span class="token punctuation">(</span>i<span class="token operator">+</span>minv<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span>        <span class="token keyword">return</span> res<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">// 基数排序（不适用于负数）</span>    vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span> <span class="token function">radixSort</span><span class="token punctuation">(</span>vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span><span class="token operator">&amp;</span> nums<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">int</span> n <span class="token operator">=</span> nums<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">int</span> maxv <span class="token operator">=</span> <span class="token operator">*</span><span class="token function">max_element</span><span class="token punctuation">(</span>nums<span class="token punctuation">.</span><span class="token function">begin</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> nums<span class="token punctuation">.</span><span class="token function">end</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">int</span> maxd <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>        <span class="token keyword">while</span> <span class="token punctuation">(</span>maxv <span class="token operator">></span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            maxv <span class="token operator">/</span><span class="token operator">=</span> <span class="token number">10</span><span class="token punctuation">;</span>            maxd<span class="token operator">++</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span> <span class="token function">count</span><span class="token punctuation">(</span><span class="token number">10</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token function">rank</span><span class="token punctuation">(</span>n<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">int</span> base <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>        <span class="token keyword">while</span> <span class="token punctuation">(</span>maxd <span class="token operator">></span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            count<span class="token punctuation">.</span><span class="token function">assign</span><span class="token punctuation">(</span><span class="token number">10</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> n<span class="token punctuation">;</span> <span class="token operator">++</span>i<span class="token punctuation">)</span> <span class="token punctuation">{</span>                count<span class="token punctuation">[</span><span class="token punctuation">(</span>nums<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token operator">/</span>base<span class="token punctuation">)</span><span class="token operator">%</span><span class="token number">10</span><span class="token punctuation">]</span><span class="token operator">++</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>            <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> <span class="token number">10</span><span class="token punctuation">;</span> <span class="token operator">++</span>i<span class="token punctuation">)</span> <span class="token punctuation">{</span>                count<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">+</span><span class="token operator">=</span> count<span class="token punctuation">[</span>i<span class="token number">-1</span><span class="token punctuation">]</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>            <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> n<span class="token number">-1</span><span class="token punctuation">;</span> i <span class="token operator">>=</span> <span class="token number">0</span><span class="token punctuation">;</span> <span class="token operator">--</span>i<span class="token punctuation">)</span> <span class="token punctuation">{</span>                rank<span class="token punctuation">[</span><span class="token operator">--</span>count<span class="token punctuation">[</span><span class="token punctuation">(</span>nums<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token operator">/</span>base<span class="token punctuation">)</span><span class="token operator">%</span><span class="token number">10</span><span class="token punctuation">]</span><span class="token punctuation">]</span> <span class="token operator">=</span> nums<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>            <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> n<span class="token punctuation">;</span> <span class="token operator">++</span>i<span class="token punctuation">)</span> <span class="token punctuation">{</span>                nums<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> rank<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>            maxd<span class="token operator">--</span><span class="token punctuation">;</span>            base <span class="token operator">*</span><span class="token operator">=</span> <span class="token number">10</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">return</span> nums<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">// 桶排序 (20 ms)</span>    vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span> <span class="token function">bucketSort</span><span class="token punctuation">(</span>vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span><span class="token operator">&amp;</span> nums<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">int</span> n <span class="token operator">=</span> nums<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">int</span> maxv <span class="token operator">=</span> <span class="token operator">*</span><span class="token function">max_element</span><span class="token punctuation">(</span>nums<span class="token punctuation">.</span><span class="token function">begin</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> nums<span class="token punctuation">.</span><span class="token function">end</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">int</span> minv <span class="token operator">=</span> <span class="token operator">*</span><span class="token function">min_element</span><span class="token punctuation">(</span>nums<span class="token punctuation">.</span><span class="token function">begin</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> nums<span class="token punctuation">.</span><span class="token function">end</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">int</span> bs <span class="token operator">=</span> <span class="token number">1000</span><span class="token punctuation">;</span>        <span class="token keyword">int</span> m <span class="token operator">=</span> <span class="token punctuation">(</span>maxv<span class="token operator">-</span>minv<span class="token punctuation">)</span><span class="token operator">/</span>bs<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">;</span>        vector<span class="token operator">&lt;</span>vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span> <span class="token operator">></span> <span class="token function">bucket</span><span class="token punctuation">(</span>m<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> n<span class="token punctuation">;</span> <span class="token operator">++</span>i<span class="token punctuation">)</span> <span class="token punctuation">{</span>            bucket<span class="token punctuation">[</span><span class="token punctuation">(</span>nums<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token operator">-</span>minv<span class="token punctuation">)</span><span class="token operator">/</span>bs<span class="token punctuation">]</span><span class="token punctuation">.</span><span class="token function">push_back</span><span class="token punctuation">(</span>nums<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">int</span> idx <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> m<span class="token punctuation">;</span> <span class="token operator">++</span>i<span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">int</span> sz <span class="token operator">=</span> bucket<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            bucket<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token function">quickSort</span><span class="token punctuation">(</span>bucket<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> j <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> j <span class="token operator">&lt;</span> sz<span class="token punctuation">;</span> <span class="token operator">++</span>j<span class="token punctuation">)</span> <span class="token punctuation">{</span>                nums<span class="token punctuation">[</span>idx<span class="token operator">++</span><span class="token punctuation">]</span> <span class="token operator">=</span> bucket<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span>        <span class="token keyword">return</span> nums<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">// 堆排序（32 ms）</span>    <span class="token keyword">void</span> <span class="token function">adjust</span><span class="token punctuation">(</span>vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span><span class="token operator">&amp;</span> nums<span class="token punctuation">,</span> <span class="token keyword">int</span> p<span class="token punctuation">,</span> <span class="token keyword">int</span> s<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token number">2</span><span class="token operator">*</span>p<span class="token operator">+</span><span class="token number">1</span> <span class="token operator">&lt;</span> s<span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">int</span> c1 <span class="token operator">=</span> <span class="token number">2</span><span class="token operator">*</span>p<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">;</span>            <span class="token keyword">int</span> c2 <span class="token operator">=</span> <span class="token number">2</span><span class="token operator">*</span>p<span class="token operator">+</span><span class="token number">2</span><span class="token punctuation">;</span>            <span class="token keyword">int</span> c <span class="token operator">=</span> <span class="token punctuation">(</span>c2<span class="token operator">&lt;</span>s <span class="token operator">&amp;&amp;</span> nums<span class="token punctuation">[</span>c2<span class="token punctuation">]</span><span class="token operator">></span>nums<span class="token punctuation">[</span>c1<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token operator">?</span> c2 <span class="token operator">:</span> c1<span class="token punctuation">;</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>nums<span class="token punctuation">[</span>c<span class="token punctuation">]</span> <span class="token operator">></span> nums<span class="token punctuation">[</span>p<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token function">swap</span><span class="token punctuation">(</span>nums<span class="token punctuation">[</span>c<span class="token punctuation">]</span><span class="token punctuation">,</span> nums<span class="token punctuation">[</span>p<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token keyword">else</span> <span class="token keyword">break</span><span class="token punctuation">;</span>            p <span class="token operator">=</span> c<span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span>    vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span> <span class="token function">heapSort</span><span class="token punctuation">(</span>vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span><span class="token operator">&amp;</span> nums<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">int</span> n <span class="token operator">=</span> nums<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> n<span class="token operator">/</span><span class="token number">2</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span> i <span class="token operator">>=</span> <span class="token number">0</span><span class="token punctuation">;</span> <span class="token operator">--</span>i<span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token function">adjust</span><span class="token punctuation">(</span>nums<span class="token punctuation">,</span> i<span class="token punctuation">,</span> n<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> n<span class="token number">-1</span><span class="token punctuation">;</span> i <span class="token operator">></span> <span class="token number">0</span><span class="token punctuation">;</span> <span class="token operator">--</span>i<span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token function">swap</span><span class="token punctuation">(</span>nums<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">,</span> nums<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token function">adjust</span><span class="token punctuation">(</span>nums<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> i<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">return</span> nums<span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> 编程算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> leetcode </tag>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Kali Linux安全测试笔记</title>
      <link href="/2019/09/30/kali-linux-an-quan-ce-shi-bi-ji/"/>
      <url>/2019/09/30/kali-linux-an-quan-ce-shi-bi-ji/</url>
      
        <content type="html"><![CDATA[<h1 id="Kali-Linux安全测试笔记"><a href="#Kali-Linux安全测试笔记" class="headerlink" title="Kali Linux安全测试笔记"></a>Kali Linux安全测试笔记</h1><hr><h2 id="Task1-Kali-Linux渗透测试介绍"><a href="#Task1-Kali-Linux渗透测试介绍" class="headerlink" title="Task1. Kali Linux渗透测试介绍"></a>Task1. Kali Linux渗透测试介绍</h2><p>###渗透测试标准——PETS<br>1.前期交互阶段<br>2.情报收集阶段<br>3.威胁建模阶段<br>4.漏洞分析阶段<br>5.渗透攻击阶段<br>6.后渗透测试阶段<br>7.渗透测试报告</p><p>###安全测试误区</p><ul><li>扫描器就是一切<ul><li>忽视业务逻辑中的漏洞</li></ul></li></ul><p>###Kali Linux 介绍</p><ol><li>FHS标准目录结构</li><li>定制内核</li><li>基于Debian的Linux版本</li><li>支持ARM和手机平台<br>手机上mapHunter???</li></ol><p>###Kali Linux 策略</p><ul><li>ROOT 用户策略 （默认ROOT）</li><li>网络服务策略 （默认网络服务关闭）<br>需手动启动</li><li>更新升级策略</li></ul><p>###关于本教程</p><ul><li>Kali 很强大，但不是全部</li><li>实践是最好的老师</li><li>自行补充所需安全工具，独一无二的Kali</li></ul><h2 id="Task2-Kali-Linux渗透测试介绍"><a href="#Task2-Kali-Linux渗透测试介绍" class="headerlink" title="Task2. Kali Linux渗透测试介绍"></a>Task2. Kali Linux渗透测试介绍</h2><p><strong>*时间有限，暂时跳过这一章视频</strong><br>1.安装文件计算哈希值比对<br>2.U盘启动盘安装<br>  使用官方软件UnitBootin<br>3.制作启动光盘安装</p><p>安装Linux 内核头文件<br>apt-get 基于debian的Linux软件包管理软件  自动连接官网下载源</p><pre><code>apt-get install linux-headers-${uname -r}</code></pre><p>uname -r 查询机器版本</p><p>安装VMTOOLS</p><p><strong>uname -r ：</strong>显示操作系统的发行版号<br><strong>uname -a ：</strong>显示系统名、节点名称、操作系统的发行版号、操作系统版本、运行系统的机器 ID 号。</p><p>apt-get update 连接官网更新软件包索引文件、升级的不是软件包本身，而是索引</p><h2 id="Task3-Kali-Linux安装-持久加密USB安装、熟悉环境、熟悉BASH命令1"><a href="#Task3-Kali-Linux安装-持久加密USB安装、熟悉环境、熟悉BASH命令1" class="headerlink" title="Task3. Kali Linux安装 持久加密USB安装、熟悉环境、熟悉BASH命令1"></a>Task3. Kali Linux安装 持久加密USB安装、熟悉环境、熟悉BASH命令1</h2><p>dmesg  查看系统变化</p><p>###Task4 熟悉环境 Bash命令</p><ul><li>登录密码</li><li>TOP10安全工具</li></ul><p>1.aircrack-ng 无线攻击<br>2.burpsuite 基于Web渗透测试（手动）<br>3.hydra john 密码攻击<br>4.maltego 信息收集（图形化界面）<br>5.metasploit 框架<br>6.nmap网络扫描工具<br>7.owasp-zap 基于web<br>8.Sqlmap 注入<br>9.wireshark 网络数据包</p><ul><li>字体调整</li></ul><p>1.gnome-tweak-tool工具<br>终端输入 gnome-tweaks即可</p><ul><li>监视网络流量</li></ul><p><strong>安装netspeed</strong></p><pre><code>https://blog.csdn.net/penge199761/article/details/79140789</code></pre><ul><li>强行终止程序</li><li>文件目录<br>按功能分类目录 bin、boot、dev、etc、home、lib等</li><li>共享文件</li></ul><p>##熟悉操作Bash命令</p><ul><li><p>ls<br>蓝色-目录  白色-普通文件 绿色-可执行文件  红色-压缩包<br>ls -l 以长格式显示  注意前十个字符 1+9<br>ls -la 多出来以点开始的文件（隐藏文件）<br>ls -lh 以人易读方式显示文件大小 </p></li><li><p>cd  和windows相同<br>cd. 到当前目录<br>cd.. 当上一级目录</p></li><li><p>pwd 查看当前工作目录</p></li><li><p>clear 清空</p></li><li><p>cat 查看文件</p></li><li><p>more 加文件目录 分段查看  q退出查看</p></li><li><p>less 加文件目录 不会显示百分比 q退出查看</p></li><li><p>tail 加文件目录 默认文件最后十行信息<br>tail -n 加文件目录 显示最后n行信息<br>配合 watch命令使用<br>watch -n 2 tail -20 加文件目录 /var/log/messages ，每隔两秒钟刷新查看</p></li><li><p>cp rm 针对文件<br>  rm 删除文件<br>  cp 复制  cp ps ps1 //将ps复制成ps1,针对文件<br>  cp -r Agent/ A   //将Agent文件夹复制成A<br>  rm -r A     //删除文件夹A</p></li><li><p>top 命令<br>查看进程及各种信息、</p></li><li><p>ps命令<br>专门用来查看各种进程信息 + -ef显示更为详细信息</p></li><li><p>grep 命令 筛选信息<br>cat /etc/passwd<br>grep ssh /etc/passwd    //筛选含ssh字符串的行</p></li><li><p>ifconfig 网络<br>ifconfig eth0 down 关闭命令<br>ifconfig eth0 up 打开</p></li><li><p>netstat 查看网络连接信息<br>netstat -pantu 查看与哪些服务器 tcp udp连接</p></li><li><p>管道<br>将多个命令在Linux 同一行输入<br>同一行命令通过管道方式 每个命令间不同关系<br>netstat -pantu |egrep -v ‘0.0.0.0|:::’ 排除？？</p></li><li><p>mount 挂载<br>mount -o loop kali.ios /media/cdrom<br>挂载到目录 查看文件内容</p></li><li><p>dmesg<br>不太懂</p></li><li><p>find 命令<br>查找文件、目录 位置<br>find / -name nmap  从根目录查找名为nmap的文件<br>find / -iname nmap //不区分大小写<br>find . -name ps*    以ps开头的文件</p></li><li><p>whereis 命令<br>查找范围较小 但速度块<br>whereis -b nmap //查找二进制文件</p></li><li><p>vi 命令<br>文本编辑器 vim简称<br>wq 写并退出<br>命令模式下输入内容编辑<br>i 插入<br>输入：或者/即可进入命令模式</p></li><li><p>shell 脚本<br>vi 1.sh<br>#!/bin/bash<br>#! 是所有linux脚本文件开头的符号, 后面的/bin/bash表示是使用/bin/bash为解释器来执行本文件的脚本<br>esc :wq 保存加退出<br>chmod +x 1.sh 增加可执行权限<br>./1.sh 执行脚本</p><p>  #!/bin/bash<br>  for n in seq 9<br>  do<br>  for m in seq $n</p></li></ul><p>##网络配置</p><ul><li>ifconfig<br>ifconfig eth0 指定新ip/子网掩码</li></ul><p>指定网关  route add default gw 192.168.1.1<br> ip 地址 DNS 网关 ，这些。。。。我都不会。。。</p><ul><li>更新升级 <ul><li>apt-get update 更新索引文件</li><li>apt-get upgrade 更新软件包文件</li><li>apt-get update –fix-missing 更新错误索引</li><li>vi /etc/apt/sources.list  更改更新源</li><li>安装软件包</li></ul></li><li>库  apt-get命令</li><li>安装适合的工具软件<br>apt-get install smplayer  //播放器<br>ibus ibus-pinyin<br> flashplugin freemind chromium monodevelop mono-gmcs-y<ul><li>FireFox浏览器插件<br>flashgot | autoproxy |coocie Importer导入cookie<br>cookie manager//   download yotube videos as mp4<br>firebug //  flagfox、   </li></ul></li></ul>]]></content>
      
      
      <categories>
          
          <category> 网络安全 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux </tag>
            
            <tag> 安全测试 </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
